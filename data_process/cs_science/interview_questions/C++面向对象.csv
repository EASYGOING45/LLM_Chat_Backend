问题,回答,所属分类
C++ 面向对象面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 面向对象的三大特征是哪些？
1. 面向对象的三大特征是哪些？
2. C++中类成员的访问权限
2. C++中类成员的访问权限
3. 多态的实现有哪几种？
3. 多态的实现有哪几种？
4. 动态绑定是如何实现的？
4. 动态绑定是如何实现的？
5. 动态多态有什么作用？有哪些必要条件？
5. 动态多态有什么作用？有哪些必要条件？
6. 纯虚函数有什么作用？如何实现？
6. 纯虚函数有什么作用？如何实现？
7. 虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？
7. 虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？
8. 为什么基类的构造函数不能定义为虚函数？
8. 为什么基类的构造函数不能定义为虚函数？
9. 为什么基类的析构函数需要定义为虚函数？
9. 为什么基类的析构函数需要定义为虚函数？
10. 构造函数和析构函数能抛出异常吗？
10. 构造函数和析构函数能抛出异常吗？
11. 如何让一个类不能实例化？
11. 如何让一个类不能实例化？
12. 多继承存在什么问题？如何消除多继承中的二义性？
12. 多继承存在什么问题？如何消除多继承中的二义性？
13. 如果类A是一个空类，那么sizeof(A)的值为多少？
13. 如果类A是一个空类，那么sizeof(A)的值为多少？
14. 覆盖和重载之间有什么区别？
14. 覆盖和重载之间有什么区别？
15. 拷贝构造函数和赋值运算符重载之间有什么区别？
15. 拷贝构造函数和赋值运算符重载之间有什么区别？
16. 对虚函数和多态的理解
16. 对虚函数和多态的理解
17. 请你来说一下C++中struct和class的区别
17. 请你来说一下C++中struct和class的区别
18. 说说强制类型转换运算符
18. 说说强制类型转换运算符
19. 简述类成员函数的重写、重载和隐藏的区别
19. 简述类成员函数的重写、重载和隐藏的区别
20. 类型转换分为哪几种？各自有什么样的特点？
20. 类型转换分为哪几种？各自有什么样的特点？
21. RTTI是什么？其原理是什么？
21. RTTI是什么？其原理是什么？
22. 说一说c++中四种cast转换
22. 说一说c++中四种cast转换
23. C++的空类有哪些成员函数
23. C++的空类有哪些成员函数
24. 模板函数和模板类的特例化
24. 模板函数和模板类的特例化
25. 为什么析构函数一般写成虚函数
25. 为什么析构函数一般写成虚函数
### 其他C++分类阅读
C++ 基础面试题阅读指南（必看）
C++ 基础面试题阅读指南（必看）
 C++ STL面试题阅读指南（必看）
 C++ STL面试题阅读指南（必看）
C++ 内存管理面试题阅读指南（必看
C++ 内存管理面试题阅读指南（必看
C++面向对象",
面向对象的三大特征是哪些？,C++面向对象,
C++中类成员的访问权限,"C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员
C++面向对象",
多态的实现有哪几种？,"多态分为静态多态和动态多态。其中，静态多态是通过重载和模板技术实现的，在编译期间确定；动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定。
C++面向对象",
动态绑定是如何实现的？,"当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针vptr，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。
C++面向对象",
动态多态有什么作用？有哪些必要条件？,"动态多态的作用：
动态多态的必要条件：
C++面向对象",
纯虚函数有什么作用？如何实现？,"定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。
实现方式是在虚函数声明的结尾加上= 0即可。
C++面向对象",
虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？,"虚函数表是针对类的，类的所有对象共享这个类的虚函数表，因为每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不同，但都指向同一虚函数表。
C++面向对象",
为什么基类的构造函数不能定义为虚函数？,"虚函数的调用依赖于虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。
C++面向对象",
为什么基类的析构函数需要定义为虚函数？,"为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。
C++面向对象",
构造函数和析构函数能抛出异常吗？,C++面向对象,
如何让一个类不能实例化？,"将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为private。
C++面向对象",
多继承存在什么问题？如何消除多继承中的二义性？,"在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；
消除同名二义性的方法：
当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；
消除路径二义性的方法：
C++面向对象",
如果类A是一个空类，那么sizeof(A)的值为多少？,"sizeof(A)的值为1，因为编译器需要区分这个空类的不同实例，分配一个字节，可以使这个空类的不同实例拥有独一无二的地址。
C++面向对象",
覆盖和重载之间有什么区别？,C++面向对象,
拷贝构造函数和赋值运算符重载之间有什么区别？,"一般情况下，类中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数。
C++面向对象",
对虚函数和多态的理解,"多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。
C++面向对象",
请你来说一下C++中struct和class的区别,"在C++中，class和struct做类型定义如下区别：
C++保留struct关键字，主要有如下原因
C++面向对象",
说说C++的四种强制类型转换运算符,"1、reinterpret_cast
reinterpret_cast< type-id > (expression)
type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。
2、const_cast
const_cast (expression)
该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：
3、static_cast
static_cast < type-id > (expression)
该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：
注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。
4、dynamic_cast
有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全
dynamic_cast (expression)
该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*
如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用
dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）
dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全
举个例子：
从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。
C++面向对象",
简述类成员函数的重写、重载和隐藏的区别,"（1）重写和重载主要有以下几点不同。
（2）隐藏和重写、重载有以下几点不同。
「注意」：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完 全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。
C++面向对象",
类型转换分为哪几种？各自有什么样的特点？,"const_cast：用于去除const或volatile属性；
dynamic_cast：用于子类和父类之间的安全转换，可以实现向上向下转换，因为编译器默认向上转换总是安全的，而向下转换时，dynamic_cast具有类型检查的功能；
dynamic_cast转换失败时，对于指针会返回目标类型的nullptr，对于引用会返回bad_cast异常；
reinterpret_cast：用于不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型之间的转换。
C++面向对象",
RTTI是什么？其原理是什么？,"RTTI即运行时类型识别，其功能由两个运算符实现：
C++面向对象",
说一说c++中四种cast转换,"C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast
1、const_cast
2、static_cast
3、dynamic_cast
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
4、reinterpret_cast
5、为什么不使用C的强制转换？
C++面向对象",
C++的空类有哪些成员函数,"「注意」：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是 空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。
C++面向对象",
模板函数和模板类的特例化,"「引入原因」
编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化
「定义」对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上
（1）模板函数特例化
必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参，举例如下：
「本质」特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。
「注意」模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。
（2）类模板特例化
原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template<>表示是一个特例化版本，例如：
「类模板的部分特例化」
不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)
「特例化类中的部分成员」
可以特例化类中的部分成员函数而不是整个类，举个例子：
C++面向对象",
为什么析构函数一般写成虚函数,"由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。举个例子：
将基类的析构函数声明为虚函数：
C++面向对象",
拷贝初始化和直接初始化，初始化和赋值的区别?,"要点就是拷贝初始化和直接初始化调用的构造函数是不一样的，但是当类进行复制时，类会自动生成一个临时的对象，然后再进行拷贝初始化。
C++面向对象",
