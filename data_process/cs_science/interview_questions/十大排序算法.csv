问题,回答,所属分类
漫画：什么是插入排序算法？,"面试官：聊聊插入排序

插入排序是一种比较简单直观的排序算法，适用处理数据量比较少或者部分有序的数据，今天我们来聊聊插入排序





  只见慧能拿出了一副牌，洗了洗牌，然后放在桌子上，从牌顶摸了几张牌




  说着说着慧能又摸了一张牌





  一尘不假思索地回答道



  怎么判断？这一下还把小一尘给问愣住了，但是细想了一下整个过程，一尘答道





  突然之间又学了一个知识点，每次知识都来得猝不及防，一尘心里想到



  慧能拿来了笔和纸准备详细地说说












  早知道就不说这句话了，一尘心里想，但师命难违，还是硬着头皮想了想

一尘：首先我用一个数组存储要排序的数据（无序）

然后我用for循环从前到后遍历整个数组，将无序元素一个一个地插入到正确的位置（排好序的位置），第一个元素我认为它是排好序的，所以我从第二个元素开始遍历

随后，小一尘写下了如下代码


  一尘解释道


一尘：是啊，这个怎么实现呢？咦，我可以用一个临时变量把待插元素（将要插入到有序集合的元素）存起来，然后逐个和有序集合里的元素比较，如果集合里的元素大于待插元素，就将它向后移动一个单元，这样当遇到有序集合中小于等于待插元素的元素时就有地方放待插元素了



小一尘又把插入方法(insertToRightPosition)实现了
i 指向待插元素，j 会遍历有序数组中所有元素，直到找到合适的位置将待插元素(inserted)插入




  下面讨论最坏时间复杂度，即所有元素倒序

这段代码最耗时的地方就花在最内层for循环里面的操作上（比较和移动）了，我只要大概估算出这些操作执行的次数就可以了
对于n个元素，首先我的外层for循环要循环n-1次

然后insertToRightPosition里的内层for循环的循环次数是根据 i 来决定的，i = 1时,循环 1 次，i = 2,循环 2 次，…，i = n-1,循环 n-1次，那总共加起来就是

根据复杂度计算规则，保留高阶项，并去掉系数，那么时间复杂度为O(n^2)






十大排序算法",
漫画：什么是冒泡排序算法？,"面试官： 写一个冒泡排序吧

冒泡排序是一个比较经典和简单的排序算法，今天我们从从算法本身，时间复杂度以及稳定性方面来看看冒泡排序，这些方面也是研究其他排序算法的一般思路
在算法国内，相传有一位大师，他不喜做官，在民间传道受业，弟子三千，人称“克”
有一天，克带着得意弟子谦子去溪边游玩，看到许多大大小小的石头在溪边，克拿起了四个大小不同的石子，摆成一行，如下：

问：“谦子，你如何将这些石子按照从小到大的顺序从左到右依次排列成一行？”
“先找出最大的放在右边，然后再找出次大的，放在最大的左边，按照这个规律就可以依次排好了”，谦子回答道
“那你如何找到最大的呢？”，克问道
“用肉眼看”，谦子弱弱的说了一句
“怎么可以用肉眼看，如果成千上万你也用肉眼看吗？咱们算法国以算法著称，就是让一切问题的解决都可以最终化为一个算法，可以用程序写出来”，克严厉地批评道
“那该如何找最大的呢？”，谦子问道
“你看那水中的鱼，他们时不时地吐出泡泡，那泡泡越往上走就会越大

我们可以借鉴这种思路
从第一个石子开始，让它和右边相邻的石子进行比较，如果左边的石子大于右边的石子，那么就交换两个石子的位置，（也可以左小于右交换，这里采用大于交换），这样每比较一次，大的就跑到右边，直到跑到最右边”，克说道
克看谦子不明白，于是说：“起始时，左下标指向第一个石子，右下标指向第二个石子，然后比较”，说着说着画了一个图

“然后左右下标同时向右移动，再次比较”，克接着说道，手不停的画着

“这样一来，每次比较完，右下标指向的石头就是已经比较过的元素中的最大元素”，克微微笑了一下，看了看谦子，然后又画了一个图

“按照这个做法，这一趟下来所有石子中最大的就跑到最右边了”，谦子悟出了其中的真谛，接着老师的话说了一句，自己在地上也画了一个图

“这是第一趟排序，经过这趟排序之后，最大的就在最右边了，也就是排好序了，那么接下来就从剩下的三个石子中选最大的了，规则就和上面的一样了”，谦子继续说道，并画了一个图

克脸上露出满意的笑容
然后克问，如果有 N 个石子，称从左到右找最大为一趟，那么要排好序需要多少趟？
谦子想了想，说道：“需要N-1次，因为如果因为N-1个数都排好了，那么最后一个数也就不用排了”，顺便画了一个图演示刚才四个石子的情况

“那你能把这个过程用代码实现吗？”，克问道
“这个。。。”，谦子挠了挠头，傻傻地笑了一下，克看了谦子一眼，转而在地下飞速地写了短短的几行代码

谦子心中暗暗惊叹老师的功力
“这个第一层循环是控制趟数，第二行能具体讲讲吗？”，谦子笑了笑问道
“第二层就是控制你第 i+1趟（因为i从0开始）所比较的次数，第 i +1 趟比较了 N – 1 -i 次”，克说道，最后画了两张图


“随着趟数的增加，比较的次数也随之减小，这个规律很容易发现吧”，克说道
谦子点了点头
“那你说说这个算法的时间复杂度吧”，克问道
谦子心里想到：
既然排序完需要3趟，第一趟需要比较3次，第二趟需要比较2次，第三趟需要比较1次，那一共比较了 3 + 2 + 1 次
那推广到数量为 n 的规模的话，那就需要 (n-1) + (n-2) +…+2+1 次，这不就是一个等差数列吗，很显然：

根据复杂度的规则，去掉低阶项（也就是n/2）,并去掉常数系数，那复杂度就是O(n^2)了
“O(n^2)”,谦子想了一会说道
“恩恩，不错”，克说道
“那这个算法稳不稳定呢？”，克又问道
“哦，什么是稳定性？”，谦子问道
“哦，这个还没有给他讲”，克忽然想起来
“所谓稳定性，其实就是说，当你原来待排的元素中间有相同的元素，在没有排序之前它们之间有先后顺序，在排完后它们之间的先后顺序不变，我们就称这个算法是稳定的”，克说道，顺便画了一个图举了一个例子

“看到了吧，原本同样大的石子，蓝色的在绿色的左边，拍完序后蓝色的仍然在绿色的左边，这就是稳定的”，克解释道
“哦，我懂了，那冒泡排序就是一个稳定的排序了，因为在交换的时候，如果两个石子相同，那么就不交换[if (arr[j] > arr[j+1]){ 交换}],相同元素不会因为算法中哪条语句相互交换位置的”
“恩恩，对的”，克说道
天色渐晚，克和弟子走在了回去的路上，回去的路上克告诉谦子今天的排序算法叫冒泡排序
假如从开始的第一对到结尾的最后一对，相邻的元素之间都没有发生交换的操作，这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。
代码如下：
十大排序算法",
漫画：什么是希尔排序算法？,"希尔排序（ShellSort）是以它的发明者Donald Shell名字命名的，希尔排序是插入排序的改进版，实现简单，对于中等规模数据的性能表现还不错

前情回顾：漫画：什么是插入排序算法？（对插入排序不熟悉的强烈建议先阅读此文）
漫画：什么是插入排序算法？
一天，一尘拿着扑克自己在那玩，刚被师傅看见了





  数据有序程度越高，越高效（移动少）






首先它把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高

注意：下面有颜色的是逻辑上的分组，并没有实际地进行分组操作，在数组中的位置还是原来的样子，只是将他们看成这么几个分组（逻辑上分组）
可以看出，他是按下标相隔距离为4分的组，也就是说把下标相差4的分到一组，比如这个例子中a[0]与a[4]是一组、a[1]与a[5]是一组…，这里的差值（距离）被称为增量

每个分组进行插入排序后，各个分组就变成了有序的了（整体不一定有序）

此时，整个数组变的部分有序了（有序程度可能不是很高）

然后缩小增量为上个增量的一半:2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样比较高

同理对每个分组进行排序（插入排序），使其每个分组各自有序

最后设置增量为上一个增量的一半：1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高

同理，对这仅有的一组数据进行排序，排序完成




  对于已经熟悉插入排序的一尘来说这并不是什么难事，很快，一尘写出了希尔排序的代码




随后一尘写出了插入arr[i]到所在组正确位置的代码（insertI）

  insertI 和直接插入排序里的插入代码几乎完全一样

直接插入排序



  接下来又是分析时间复杂度吧，一尘心里想




希尔排序的复杂度和增量序列是相关的
{1,2,4,8,…}这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是O(n^2)
Hibbard提出了另一个增量序列{1,3,7，…,2^k-1}，这种序列的时间复杂度(最坏情形)为O(n^1.5)
Sedgewick提出了几种增量序列，其最坏情形运行时间为O（n^1.3）,其中最好的一个序列是{1,5,19,41,109,…}

  对不同增量的复杂度感性趣可以参考《数据结构与算法分析》一书或其他相关论文






  关于稳定性可看：冒泡排序

冒泡排序
说完，一尘继续玩起了扑克

十大排序算法",
漫画：什么是归并排序算法？,"归并排序是建立在归并操作的一种高效的排序方法，该方法采用了分治的思想，比较适用于处理较大规模的数据，但比较耗内存，今天我们聊聊归并排序

一天，小一尘和慧能坐在石头上，眺望着远方







  分而治之： 分开来去治理





  归并即合并之意

慧能随手画了一张图解释了一下


  治：治理，这里就是将数组排序




对于合并，其实非常简单，我只要不断地取出两个有序数组中比较小的那一个放在一个辅助数组中（通过比较），直到把两个有序数组中的元素取完





  一尘已经了解了师傅的固定套路了

既然是不断地分，那用递归就非常简单了，什么时候终止递归呢？递归到只有一个元素的时候。一尘随手写下了如下代码


  这里需要说明的是，center = (left + right) / 2 最好改成 center = left + (right – left) / 2，因为 left + right 有可能溢出。

很快，一尘写下了 merge 函数的代码



一尘想到：这个有点烧脑啊，元素个数为 n，运行时间是多少啊？递归,递归，再递归…


  师傅一下看出了一尘的心思



假设处理的数据规模大小为 N
运行时间设为：T(N)
① 当把 N 分为两半时，那么处理大小为 N/2 子数组花费时间为：T(N/2)
② 合并花费时间与数据规模成正比：N
所以处理规模大小为N的数据所需要花费两个大小为 N/2 的子数组加上合并花费的时间
即：T(N) = 2T(N/2) + N
对于 N = 1，T(1) = 1









此时太阳已经下山，一尘和师傅走在回家的路上，在路上，一尘脑子又想了一下归并排序的全过程

十大排序算法",
漫画：什么是快速排序算法？,"这篇文章，以对话的方式，详细着讲解了快速排序以及排序排序的一些优化。





一禅：归并排序是一种基于分治思想的排序，处理的时候可以采取递归的方式来处理子问题。我弄个例子吧，好理解点。例如对于这个数组arr[] = { 4，1，3，2，7，5，8，0}。

我们把它切割成两部分。

把左半部分和右半部分分别排序好。

之后再用一个临时数组，把这两个有序的子数组汇总成一个有序的大数组

排好之后在复制原源arr数组

这时，源数组就排序完毕了


一禅：左半部分和右半部分的排序相当于一个原问题的一个子问题的，也是采取同样的方式，把左半部分分成两部分，然后….
直到分割子数组只有一个元素或0个元素时，这时子数组就是有序的了(因为只有一个元素或0个，肯定是有序的啊)，就不用再分割了，直接返回就可以了(当然，我在讲解这个归并排序的过程中，是假设你大致了解归并排序的前提下的了)


一禅：把一个n个元素的数组分割成只有一个元素的数组，那么我需要切logn次，每次把两个有序的子数组汇总成一个大的有序数组，所需的时间复杂度为O(n)。所以总的时间复杂度为O(nlogn)



小白：那倒不是，快速排序的平均时间复杂度也是O(nlogn)，不过他不需要像归并排序那样，还需要一个临时的数组来辅助排序，这可以节省掉一些空间的消耗，而且他不像归并排序那样，把两部分有序子数组汇总到临时数组之后，还得在复制回源数组，这也可以节省掉很多时间。


小白：快速排序也是和归并排序差不多，基于分治的思想以及采取递归的方式来处理子问题。例如对于一个待排序的源数组arr = { 4，1，3，2，7，6，8}。

我们可以随便选一个元素，假如我们选数组的第一个元素吧，我们把这个元素称之为”主元“吧。

然后将大于或等于主元的元素放在右边，把小于或等于主元的元素放在左边。

通过这种规则的调整之后，左边的元素都小于或等于主元，右边的元素都大于或等于主元，很显然，此时主元所处的位置，是一个有序的位置,即主元已经处于排好序的位置了。
主元把数组分成了两半部分。把一个大的数组通过主元分割成两小部分的这个操作，我们也称之为分割操作(partition)。
接下来，我们通过递归的方式，对左右两部分采取同样的方式，每次选取一个主元 元素，使他处于有序的位置。

那什么时候递归结束呢？当然是递归到子数组只有一个元素或者0个元素了




一禅：就按照你说的，选一个主元，你刚才选的是第一个元素为主元，这次我选最后一个为主元吧，哈哈。假设数组arr的范围为[left, right]，即起始下标为left，末尾下标为right。源数组如下

然后可以用一个下标 i 指向 left，即 i = left ;用一个下标 j 也指向l eft，即j = left

接下来 j 从左向右遍历，遍历的范围为 [left, right-1] ，遍历的过程中，如果遇到比主元小的元素，则把该元素与 i 指向的元素交换，并且 i = i +1

当j指向1时，1比4小，此时把i和j指向的元素交换，之后 i++。

就这样让j一直向右遍历，直到 j = right

遍历完成之后，把 i 指向的元素与主元进行交换，交换之后，i 左边的元素一定小于主元，而 i 右边的元素一定大于或等于主元。这样，就 i 完成了一次分割了。



一禅一言不合就把代码撸好了，第一版代码如下：



小白：对啊，因为你这调整方法，可能会出现对同一个元素，进行多次交换，例如刚才你在演示的那组元素，在j向右遍历交换的过程中：
第一次：8和1交换
第二次：8和3交换
第三次：8和2交换
8被重复交换了很多次


小白：其实，我们可以这样来调整元素。我还是用我的第一个元素充当主元吧。哈哈
源数组如下

然后用令变量i = left + 1，j = right。然后让 i 和 j 从数组的两边向中间扫描。

i 向右遍历的过程中，如果遇到大于或等于主元的元素时，则停止移动，j向左遍历的过程中，如果遇到小于或等于主元的元素则停止移动。

当i和j都停止移动时，如果这时i < j，则交换 i, j 所指向的元素。此时 i < j，交换8和3

然后继续向中间遍历，直到i >= j。

此时i >= j，分割结束。
最后在把主元与 j 指向的元素交换(当然，与i指向的交换也行)。

这个时候，j 左边的元素一定小于或等于主元，而右边则大于或等于主元。
到此，分割调整完毕
代码如下：



小白：因为快速排序的最坏时间复杂度是O(n2)。
例如有可能会出现一种极端的情况，每次分割的时候，主元左边的元素个数都为0，而右边都为n-1个。这个时候，就需要分割n次了。而每次分割整理的时间复杂度为O(n)，所以最坏的时间复杂度为O(n2)。
而最好的情况就是每次分割都能够从数组的中间分割了，这样分割logn次就行了，此时的时间复杂度为O(nlogn)。
而平均时间复杂度，则是假设每次主元等概率着落在数组的任意位置，最后算出来的时间复杂度为O(nlogn)，至于具体的计算过程，我就不展开了。
不过显然，像那种极端的情况是极少发生的。


小白：哈哈，之所以说它快，是因为它不像归并排序那样，需要额外的辅助空间，而且在分割调整的时候，不像归并排序那样，元素还要在辅助数组与源数组之间来回复制。


一禅：不是啊，例如，在排序的过程中，主元在和j交换的时候是有可能破坏稳定性的，例如

把主元与j指向的元素进行交换



终于写完，这个快排写了挺长时间，觉得有收获的话，可以转发支持一波哦(´-ω-`)。
十大排序算法",
漫画：为什么说O(n)复杂度的基数排序没有快速排序快？,"掌握要求：基数排序只需要掌握基本的思想即可，代码写不出来也是没事滴

大家好，我是帅地，对于基数排序算法，考察的不多，我们需要掌握他的原理就可以了，看完这篇文章，我相信就能够大致掌握了。







老大：我简单给你讲下吧，你学过那么多排序，估计一看就懂了。基数排序，是一种基数“桶”的排序，他的排序思路是这样的：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……
排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是采用“桶”来排序的，基本原理就是把具有相同个（十、百等）位数的数放进同一个桶里。我直接给你个例子吧，保证你一看就懂。
例如我们现在要对这组元素来排序：

由于我们是以每个数的某位数来排序的，这位数的范围是0-9，所以我们需要10个桶。

第一遍，先以个位数排序，把具有相同个位数的数放进桶里，结果如下：

之后再按照从0号桶到9号桶的顺序取出来，结果如下

个位数排序完成。
第二遍，以十位数来排，结果如下：

再取出来放回去：
十位数排序完成，最终的结果就是一组有序的元素。如果元素中有百位数的话，大不了就按照百位数再给他重复排一遍。



老二：那我想问下，为啥要从个位数开始排序呢？可以直接从最高位开始排序吗？如果从最高位开始排序的话，如果一个数最高位比另一个数大，那么这个数就一定比另外一个数大了，不用在比较次高位了。这样的话，不是可以排的更快吗？

老大：脑子反应的挺快啊。是的，是可以以最高位来排序的，而且也像你说的，以最高位来排序的话，是可以减少数据之间比较的次数。但我们仍然不建议以最高位来排序，因为他有个致命的缺点。


老大:还是以刚才那个例子吧，我们一边用最高位来排序，一边来寻找这个致命的缺点。数组如下(元素的顺序改变了一些)：

第一遍：最高位十位数排序，结果如下(有些没用到的桶给省略了):

显然，不在桶一个桶里的数，他们的大小顺序已经是已知的了，也就是说，右边桶的数一定比左边桶的数大，所有在接下来的个位数排序里，我们只需要进行“各部分”单独排序就可以了，每一小部分都类似于原问题的一个子问题，做的时候可以采用递归的形式来处理。

最后汇总，即可完成排序：

这种方法确实可以减少比较的次数，不过请大家注意，在每个小部分的排序中，我们也是需要10个桶来将他们进行排序，最后导致的结果就是，每个不同值的元素都会占据一个“桶”，如果你有1000个元素，并且1000个元素都是不同值的话，那么从最高位排序到最低位，需要1000个桶。
这样子的话，空间花费不仅大，而且看起来有点背离基数排序最初的思想了（“背离”这个词，个人感觉而已）。所以，我们一般采用从最低位到最高位的顺序哦。

关于基数排序，还有以下几个问题，你不妨也想一想?
1、基数排序是一种用空间换时间的排序算法，数据量越大，额外的空间就越大?
我的想法：我觉得基数排序并非是一种时间换空间的排序，也就是说，数据量越大，额外的空间并非就越大。因为在把元素放进桶的时候，是完全可以用指针指向这个元素的，也就是说，只有初始的那些桶才算是额外的空间。
2、居然额外空间不是限制基数排序速度的原因，那为啥基数排序没有快速排序快呢？
基数的时间复杂度为O(n)，不过他是忽略了常数项，即实际排序时间为kn(其中k是常数项)，然而在实际排序的过程中，这个常数项k其实是很大的，这会很大程度影响实际的排序时间，而像快速排序虽然是nlogn，但它前面的常数项是相对比较小的，影响也相对比较小。
需要说明的是，基数排序也并非比快速排序慢，这得看具体情况，（不要被标题所影响哈）。而且，数据量越大的话，基数排序会越有优势。
3、有人可能会问，说了这么多，那到底是基数排序快还是快速排序快呢？
对于这样的问题，我只能建议你，自己根据不同的场景，撸几行代码，自己测试一下。
如果你问我，哪个排序在实际中用的更多，那么，我选快速排序。

十大排序算法",
什么是计数排序算法？,"计数排序、基数排序、桶排序，这几种排序算法，可能大家见到的这次不多，有些大学的教材课本中，甚至有些都没有计数排序算法。
所以呢，帅地今天就简单讲一讲计数排序算法吧，而不会像前面一样长篇大论，因为我觉得，每一个学习计数排序的，应该都是有一定的算法基础了，而对于计数排序，我觉得大家掌握最基本的思想就可以了，平时做算法题的时候，还是会偶尔用到。

  当然，计数排序如果要深入讲解，其实也是可以比较复杂的，但是这里，帅地只讲最简洁的，因为我觉得了解了基础的，就差不多了。

举个例子，假如我要给如下这个数组排序，你会如何排序呢？
输入 arr[] = {9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9}。
如果用快速排序，归并排序等这些排序算法的话，那么他们的时间复杂度其实是 O(nlogn)。
那么有没有一种方法，使得它的时间复杂度是 O(n) 呢？
答是有的，那便是计数排序。
计数排序的基本思想是这样的：把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。
例如对于上面那个例子，我们可以创建一个数组大小为 11 的临时数组 temp


  因为数组的最大值是 10，所以临时数组的最大下标为 10 即可。

然后遍历数组，第一个整数是9，那么数组下标为9的元素加1：

第二个整数是3，那么数组下标为3的元素加1：

最终，数列遍历完毕时，数组的状态如下：

之后我们只需要遍历临时数组 temp，输出临时数组元素的下标值即可，元素的值是几，就输出几次，结果如下：
0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10
显然，这个输出的数列已经是有序的了。
Java 代码如下（代码会做详细的注释）
优化一下
上面的代码中，我们是根据 max 的大小来创建对应大小的数组，假如原数组只有 10 个元素，并且最小值为 min = 10000，最大值为 max = 10005，那我们创建 10005 + 1 大小的数组不是很吃亏？最大值与最小值的差值为 5，所以我们创建大小为 6 的临时数组就可以了，这样可以节省空间浪费
也就是说，我们创建的临时数组大小 (max – min + 1)就可以了，然后我们再把 min作为偏移量。优化之后的代码如下所示：
我这里还给大家准备了一个动画，大家看看就好

有人可能会问，如果数组只有十个元素，最小值为 min = 0，最大值 max = 1000000。那我不是得创建一个 大小为 1000000 的数组？
或者说，如果我数组中有浮点数，那不就是无法作为下标来使用了？
别问，问就是，每一种排序算法都有它的局限性，不然还用啥快速排序，目前用的最广的感觉还是快速排序，想计数排序这种，适用特定领域数据下的排序，例如最大值和最小值的差值不是很大的整数数组。
十大排序算法",
十大排序算法极简汇总篇,"十大排序算法可以说是每个程序员都必须得掌握的了，如果你们像从 0 详细学习每一篇，那么你们可以看前面的文章。
但是呢，有些人可能已经学过，想要快速复习一下，看看代码怎么写的，那么可以看这篇十大排序极简汇总。
有些人可能不知道什么是稳定排序、原地排序、时间复杂度、空间复杂度，我这里先简单解释一下：
1、稳定排序：如果 a 原本在 b 的前面，且 a = = b，排序之后 a 仍然在 b 的前面，则为稳定排序。
2、非稳定排序：如果 a 原本在 b 的前面，且 a = = b，排序之后 a 可能不在 b 的前面，则为非稳定排序。
3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。
4、非原地排序：需要利用额外的数组来辅助排序。
5、时间复杂度：一个算法执行所消耗的时间。
6、空间复杂度：运行完一个算法所需的内存大小。
为了方便大家查找，我这里弄一个伪目录，没有跳转功能。
另：
代码说明：代码我自己写的，并且都是经过好几组数据测试通过，应该没啥问题，如有错，还请反馈下，谢谢。
图片说明：图片和动画都是在百度搜索的，如有侵权，还望联系我删除，谢谢
过程简单描述：
首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为选择排序。
如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是选择排序
漫画：什么是选择排序
代码如下：
性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序
我们在玩打牌的时候，你是怎么整理那些牌的呢？一种简单的方法就是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。当我们给无序数组做排序的时候，为了要插入元素，我们需要腾出空间，将其余所有元素在插入之前都向右移动一位，这种算法我们称之为插入排序。
过程简单描述：
1、从数组第2个元素开始抽取元素。
2、把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边。
3、继续选取第3，4，….n个元素,重复步骤 2 ，选择适当的位置插入。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是插入排序
漫画：什么是插入排序
代码如下：
性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、稳定排序  4、原地排序
1、把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置….
我们对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来之后，排在最右的元素就会是最大的数。
除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。
为方便理解我还准备了动图：
如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是冒泡排序
漫画：什么是冒泡排序
代码如下
性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、稳定排序  4、原地排序
优化一下冒泡排序的算法
假如从开始的第一对到结尾的最后一对，相邻的元素之间都没有发生交换的操作，这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。
代码如下：
希尔排序可以说是插入排序的一种变种。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n – 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。
希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。
希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。
为方便理解我还准备了图片：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是希尔排序
漫画：什么是希尔排序
代码如下
需要注意的是，对各个分组进行插入的时候并不是先对一个组排序完了再来对另一个组排序，而是轮流对每个组进行排序。
性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序
将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。
通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ….. 直到全部小的数组合并起来。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是归并排序
漫画：什么是归并排序
代码如下：
性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(n)  3、稳定排序  4、非原地排序
然而面试官要你写个非递归式的归并排序怎么办？别怕，我这还撸了个非递归式的归并排序，代码如下：
我们从数组中选择一个元素，我们把这个元素称之为中轴元素吧，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是有序的。也就是说，我们无需再移动中轴元素的位置。
从中轴元素那里开始把大的数组切割成两个小的数组(两个数组都不包含中轴元素)，接着我们通过递归的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素都处于有序的位置。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是快速排序
漫画：什么是快速排序
代码如下：
性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(logn)  3、非稳定排序  4、原地排序
堆的特点就是堆顶的元素是一个最值，大顶堆的堆顶是最大值，小顶堆则是最小值。
堆排序就是把堆顶的元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换….如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是堆排序？
漫画：什么是堆排序？
代码如下：
性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序
计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。
基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：什么是计数排序？
什么是计数排序？
代码如下：
性质：1、时间复杂度：O(n+k)  2、空间复杂度：O(k)  3、稳定排序  4、非原地排序
注：K表示临时数组的大小，下同
优化一下
上面的代码中，我们是根据 max 的大小来创建对应大小的数组，假如原数组只有10个元素，并且最小值为 min = 10000，最大值为 max = 10005，那我们创建 10005 + 1 大小的数组不是很吃亏，最大值与最小值的差值为 5，所以我们创建大小为6的临时数组就可以了。
也就是说，我们创建的临时数组大小 (max – min + 1)就可以了，然后在把 min作为偏移量。优化之后的代码如下所示：
桶排序就是把最大值和最小值之间的数进行瓜分，例如分成  10 个区间，10个区间对应10个桶，我们把各元素放到对应区间的桶中去，再对每个桶中的数进行排序，可以采用归并排序，也可以采用快速排序之类的。
之后每个桶里面的数据就是有序的了，我们在进行合并汇总。
为方便理解我还准备了图片：

如果还是不懂的话我还给你准备了优质的文章讲解：什么是桶排序？
什么是桶排序？
代码如下：
性质：1、时间复杂度：O(n+k)  2、空间复杂度：O(n+k)  3、稳定排序  4、非原地排序
注：k 表示桶的个数，下同
基数排序的排序思路是这样的：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……
排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。
由于某位数（个位/十位….，不是一整个数）的大小范围为0-9，所以我们需要10个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照0号桶到9号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：为什么说O(n)复杂度的基数排序没有快速排序快？
为什么说O(n)复杂度的基数排序没有快速排序快？
代码如下：
性质：1、时间复杂度：O(kn)  2、空间复杂度：O(n+k)  3、稳定排序  4、非原地排序
用一张图汇总了10大排序算法的性质

如果你是复习/学习十大排序算法，一定要自己不看示例代码手动实现一遍，一定要自己不看示例代码手动实现一遍，一定要自己不看示例代码手动实现一遍。
十大排序算法",
