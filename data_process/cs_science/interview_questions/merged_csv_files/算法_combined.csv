问题,回答,所属分类
漫画：什么是插入排序算法？,"面试官：聊聊插入排序

插入排序是一种比较简单直观的排序算法，适用处理数据量比较少或者部分有序的数据，今天我们来聊聊插入排序





  只见慧能拿出了一副牌，洗了洗牌，然后放在桌子上，从牌顶摸了几张牌




  说着说着慧能又摸了一张牌





  一尘不假思索地回答道



  怎么判断？这一下还把小一尘给问愣住了，但是细想了一下整个过程，一尘答道





  突然之间又学了一个知识点，每次知识都来得猝不及防，一尘心里想到



  慧能拿来了笔和纸准备详细地说说












  早知道就不说这句话了，一尘心里想，但师命难违，还是硬着头皮想了想

一尘：首先我用一个数组存储要排序的数据（无序）

然后我用for循环从前到后遍历整个数组，将无序元素一个一个地插入到正确的位置（排好序的位置），第一个元素我认为它是排好序的，所以我从第二个元素开始遍历

随后，小一尘写下了如下代码


  一尘解释道


一尘：是啊，这个怎么实现呢？咦，我可以用一个临时变量把待插元素（将要插入到有序集合的元素）存起来，然后逐个和有序集合里的元素比较，如果集合里的元素大于待插元素，就将它向后移动一个单元，这样当遇到有序集合中小于等于待插元素的元素时就有地方放待插元素了



小一尘又把插入方法(insertToRightPosition)实现了
i 指向待插元素，j 会遍历有序数组中所有元素，直到找到合适的位置将待插元素(inserted)插入




  下面讨论最坏时间复杂度，即所有元素倒序

这段代码最耗时的地方就花在最内层for循环里面的操作上（比较和移动）了，我只要大概估算出这些操作执行的次数就可以了
对于n个元素，首先我的外层for循环要循环n-1次

然后insertToRightPosition里的内层for循环的循环次数是根据 i 来决定的，i = 1时,循环 1 次，i = 2,循环 2 次，…，i = n-1,循环 n-1次，那总共加起来就是

根据复杂度计算规则，保留高阶项，并去掉系数，那么时间复杂度为O(n^2)






十大排序算法",
漫画：什么是冒泡排序算法？,"面试官： 写一个冒泡排序吧

冒泡排序是一个比较经典和简单的排序算法，今天我们从从算法本身，时间复杂度以及稳定性方面来看看冒泡排序，这些方面也是研究其他排序算法的一般思路
在算法国内，相传有一位大师，他不喜做官，在民间传道受业，弟子三千，人称“克”
有一天，克带着得意弟子谦子去溪边游玩，看到许多大大小小的石头在溪边，克拿起了四个大小不同的石子，摆成一行，如下：

问：“谦子，你如何将这些石子按照从小到大的顺序从左到右依次排列成一行？”
“先找出最大的放在右边，然后再找出次大的，放在最大的左边，按照这个规律就可以依次排好了”，谦子回答道
“那你如何找到最大的呢？”，克问道
“用肉眼看”，谦子弱弱的说了一句
“怎么可以用肉眼看，如果成千上万你也用肉眼看吗？咱们算法国以算法著称，就是让一切问题的解决都可以最终化为一个算法，可以用程序写出来”，克严厉地批评道
“那该如何找最大的呢？”，谦子问道
“你看那水中的鱼，他们时不时地吐出泡泡，那泡泡越往上走就会越大

我们可以借鉴这种思路
从第一个石子开始，让它和右边相邻的石子进行比较，如果左边的石子大于右边的石子，那么就交换两个石子的位置，（也可以左小于右交换，这里采用大于交换），这样每比较一次，大的就跑到右边，直到跑到最右边”，克说道
克看谦子不明白，于是说：“起始时，左下标指向第一个石子，右下标指向第二个石子，然后比较”，说着说着画了一个图

“然后左右下标同时向右移动，再次比较”，克接着说道，手不停的画着

“这样一来，每次比较完，右下标指向的石头就是已经比较过的元素中的最大元素”，克微微笑了一下，看了看谦子，然后又画了一个图

“按照这个做法，这一趟下来所有石子中最大的就跑到最右边了”，谦子悟出了其中的真谛，接着老师的话说了一句，自己在地上也画了一个图

“这是第一趟排序，经过这趟排序之后，最大的就在最右边了，也就是排好序了，那么接下来就从剩下的三个石子中选最大的了，规则就和上面的一样了”，谦子继续说道，并画了一个图

克脸上露出满意的笑容
然后克问，如果有 N 个石子，称从左到右找最大为一趟，那么要排好序需要多少趟？
谦子想了想，说道：“需要N-1次，因为如果因为N-1个数都排好了，那么最后一个数也就不用排了”，顺便画了一个图演示刚才四个石子的情况

“那你能把这个过程用代码实现吗？”，克问道
“这个。。。”，谦子挠了挠头，傻傻地笑了一下，克看了谦子一眼，转而在地下飞速地写了短短的几行代码

谦子心中暗暗惊叹老师的功力
“这个第一层循环是控制趟数，第二行能具体讲讲吗？”，谦子笑了笑问道
“第二层就是控制你第 i+1趟（因为i从0开始）所比较的次数，第 i +1 趟比较了 N – 1 -i 次”，克说道，最后画了两张图


“随着趟数的增加，比较的次数也随之减小，这个规律很容易发现吧”，克说道
谦子点了点头
“那你说说这个算法的时间复杂度吧”，克问道
谦子心里想到：
既然排序完需要3趟，第一趟需要比较3次，第二趟需要比较2次，第三趟需要比较1次，那一共比较了 3 + 2 + 1 次
那推广到数量为 n 的规模的话，那就需要 (n-1) + (n-2) +…+2+1 次，这不就是一个等差数列吗，很显然：

根据复杂度的规则，去掉低阶项（也就是n/2）,并去掉常数系数，那复杂度就是O(n^2)了
“O(n^2)”,谦子想了一会说道
“恩恩，不错”，克说道
“那这个算法稳不稳定呢？”，克又问道
“哦，什么是稳定性？”，谦子问道
“哦，这个还没有给他讲”，克忽然想起来
“所谓稳定性，其实就是说，当你原来待排的元素中间有相同的元素，在没有排序之前它们之间有先后顺序，在排完后它们之间的先后顺序不变，我们就称这个算法是稳定的”，克说道，顺便画了一个图举了一个例子

“看到了吧，原本同样大的石子，蓝色的在绿色的左边，拍完序后蓝色的仍然在绿色的左边，这就是稳定的”，克解释道
“哦，我懂了，那冒泡排序就是一个稳定的排序了，因为在交换的时候，如果两个石子相同，那么就不交换[if (arr[j] > arr[j+1]){ 交换}],相同元素不会因为算法中哪条语句相互交换位置的”
“恩恩，对的”，克说道
天色渐晚，克和弟子走在了回去的路上，回去的路上克告诉谦子今天的排序算法叫冒泡排序
假如从开始的第一对到结尾的最后一对，相邻的元素之间都没有发生交换的操作，这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。
代码如下：
十大排序算法",
漫画：什么是希尔排序算法？,"希尔排序（ShellSort）是以它的发明者Donald Shell名字命名的，希尔排序是插入排序的改进版，实现简单，对于中等规模数据的性能表现还不错

前情回顾：漫画：什么是插入排序算法？（对插入排序不熟悉的强烈建议先阅读此文）
漫画：什么是插入排序算法？
一天，一尘拿着扑克自己在那玩，刚被师傅看见了





  数据有序程度越高，越高效（移动少）






首先它把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高

注意：下面有颜色的是逻辑上的分组，并没有实际地进行分组操作，在数组中的位置还是原来的样子，只是将他们看成这么几个分组（逻辑上分组）
可以看出，他是按下标相隔距离为4分的组，也就是说把下标相差4的分到一组，比如这个例子中a[0]与a[4]是一组、a[1]与a[5]是一组…，这里的差值（距离）被称为增量

每个分组进行插入排序后，各个分组就变成了有序的了（整体不一定有序）

此时，整个数组变的部分有序了（有序程度可能不是很高）

然后缩小增量为上个增量的一半:2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样比较高

同理对每个分组进行排序（插入排序），使其每个分组各自有序

最后设置增量为上一个增量的一半：1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高

同理，对这仅有的一组数据进行排序，排序完成




  对于已经熟悉插入排序的一尘来说这并不是什么难事，很快，一尘写出了希尔排序的代码




随后一尘写出了插入arr[i]到所在组正确位置的代码（insertI）

  insertI 和直接插入排序里的插入代码几乎完全一样

直接插入排序



  接下来又是分析时间复杂度吧，一尘心里想




希尔排序的复杂度和增量序列是相关的
{1,2,4,8,…}这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是O(n^2)
Hibbard提出了另一个增量序列{1,3,7，…,2^k-1}，这种序列的时间复杂度(最坏情形)为O(n^1.5)
Sedgewick提出了几种增量序列，其最坏情形运行时间为O（n^1.3）,其中最好的一个序列是{1,5,19,41,109,…}

  对不同增量的复杂度感性趣可以参考《数据结构与算法分析》一书或其他相关论文






  关于稳定性可看：冒泡排序

冒泡排序
说完，一尘继续玩起了扑克

十大排序算法",
漫画：什么是归并排序算法？,"归并排序是建立在归并操作的一种高效的排序方法，该方法采用了分治的思想，比较适用于处理较大规模的数据，但比较耗内存，今天我们聊聊归并排序

一天，小一尘和慧能坐在石头上，眺望着远方







  分而治之： 分开来去治理





  归并即合并之意

慧能随手画了一张图解释了一下


  治：治理，这里就是将数组排序




对于合并，其实非常简单，我只要不断地取出两个有序数组中比较小的那一个放在一个辅助数组中（通过比较），直到把两个有序数组中的元素取完





  一尘已经了解了师傅的固定套路了

既然是不断地分，那用递归就非常简单了，什么时候终止递归呢？递归到只有一个元素的时候。一尘随手写下了如下代码


  这里需要说明的是，center = (left + right) / 2 最好改成 center = left + (right – left) / 2，因为 left + right 有可能溢出。

很快，一尘写下了 merge 函数的代码



一尘想到：这个有点烧脑啊，元素个数为 n，运行时间是多少啊？递归,递归，再递归…


  师傅一下看出了一尘的心思



假设处理的数据规模大小为 N
运行时间设为：T(N)
① 当把 N 分为两半时，那么处理大小为 N/2 子数组花费时间为：T(N/2)
② 合并花费时间与数据规模成正比：N
所以处理规模大小为N的数据所需要花费两个大小为 N/2 的子数组加上合并花费的时间
即：T(N) = 2T(N/2) + N
对于 N = 1，T(1) = 1









此时太阳已经下山，一尘和师傅走在回家的路上，在路上，一尘脑子又想了一下归并排序的全过程

十大排序算法",
漫画：什么是快速排序算法？,"这篇文章，以对话的方式，详细着讲解了快速排序以及排序排序的一些优化。





一禅：归并排序是一种基于分治思想的排序，处理的时候可以采取递归的方式来处理子问题。我弄个例子吧，好理解点。例如对于这个数组arr[] = { 4，1，3，2，7，5，8，0}。

我们把它切割成两部分。

把左半部分和右半部分分别排序好。

之后再用一个临时数组，把这两个有序的子数组汇总成一个有序的大数组

排好之后在复制原源arr数组

这时，源数组就排序完毕了


一禅：左半部分和右半部分的排序相当于一个原问题的一个子问题的，也是采取同样的方式，把左半部分分成两部分，然后….
直到分割子数组只有一个元素或0个元素时，这时子数组就是有序的了(因为只有一个元素或0个，肯定是有序的啊)，就不用再分割了，直接返回就可以了(当然，我在讲解这个归并排序的过程中，是假设你大致了解归并排序的前提下的了)


一禅：把一个n个元素的数组分割成只有一个元素的数组，那么我需要切logn次，每次把两个有序的子数组汇总成一个大的有序数组，所需的时间复杂度为O(n)。所以总的时间复杂度为O(nlogn)



小白：那倒不是，快速排序的平均时间复杂度也是O(nlogn)，不过他不需要像归并排序那样，还需要一个临时的数组来辅助排序，这可以节省掉一些空间的消耗，而且他不像归并排序那样，把两部分有序子数组汇总到临时数组之后，还得在复制回源数组，这也可以节省掉很多时间。


小白：快速排序也是和归并排序差不多，基于分治的思想以及采取递归的方式来处理子问题。例如对于一个待排序的源数组arr = { 4，1，3，2，7，6，8}。

我们可以随便选一个元素，假如我们选数组的第一个元素吧，我们把这个元素称之为”主元“吧。

然后将大于或等于主元的元素放在右边，把小于或等于主元的元素放在左边。

通过这种规则的调整之后，左边的元素都小于或等于主元，右边的元素都大于或等于主元，很显然，此时主元所处的位置，是一个有序的位置,即主元已经处于排好序的位置了。
主元把数组分成了两半部分。把一个大的数组通过主元分割成两小部分的这个操作，我们也称之为分割操作(partition)。
接下来，我们通过递归的方式，对左右两部分采取同样的方式，每次选取一个主元 元素，使他处于有序的位置。

那什么时候递归结束呢？当然是递归到子数组只有一个元素或者0个元素了




一禅：就按照你说的，选一个主元，你刚才选的是第一个元素为主元，这次我选最后一个为主元吧，哈哈。假设数组arr的范围为[left, right]，即起始下标为left，末尾下标为right。源数组如下

然后可以用一个下标 i 指向 left，即 i = left ;用一个下标 j 也指向l eft，即j = left

接下来 j 从左向右遍历，遍历的范围为 [left, right-1] ，遍历的过程中，如果遇到比主元小的元素，则把该元素与 i 指向的元素交换，并且 i = i +1

当j指向1时，1比4小，此时把i和j指向的元素交换，之后 i++。

就这样让j一直向右遍历，直到 j = right

遍历完成之后，把 i 指向的元素与主元进行交换，交换之后，i 左边的元素一定小于主元，而 i 右边的元素一定大于或等于主元。这样，就 i 完成了一次分割了。



一禅一言不合就把代码撸好了，第一版代码如下：



小白：对啊，因为你这调整方法，可能会出现对同一个元素，进行多次交换，例如刚才你在演示的那组元素，在j向右遍历交换的过程中：
第一次：8和1交换
第二次：8和3交换
第三次：8和2交换
8被重复交换了很多次


小白：其实，我们可以这样来调整元素。我还是用我的第一个元素充当主元吧。哈哈
源数组如下

然后用令变量i = left + 1，j = right。然后让 i 和 j 从数组的两边向中间扫描。

i 向右遍历的过程中，如果遇到大于或等于主元的元素时，则停止移动，j向左遍历的过程中，如果遇到小于或等于主元的元素则停止移动。

当i和j都停止移动时，如果这时i < j，则交换 i, j 所指向的元素。此时 i < j，交换8和3

然后继续向中间遍历，直到i >= j。

此时i >= j，分割结束。
最后在把主元与 j 指向的元素交换(当然，与i指向的交换也行)。

这个时候，j 左边的元素一定小于或等于主元，而右边则大于或等于主元。
到此，分割调整完毕
代码如下：



小白：因为快速排序的最坏时间复杂度是O(n2)。
例如有可能会出现一种极端的情况，每次分割的时候，主元左边的元素个数都为0，而右边都为n-1个。这个时候，就需要分割n次了。而每次分割整理的时间复杂度为O(n)，所以最坏的时间复杂度为O(n2)。
而最好的情况就是每次分割都能够从数组的中间分割了，这样分割logn次就行了，此时的时间复杂度为O(nlogn)。
而平均时间复杂度，则是假设每次主元等概率着落在数组的任意位置，最后算出来的时间复杂度为O(nlogn)，至于具体的计算过程，我就不展开了。
不过显然，像那种极端的情况是极少发生的。


小白：哈哈，之所以说它快，是因为它不像归并排序那样，需要额外的辅助空间，而且在分割调整的时候，不像归并排序那样，元素还要在辅助数组与源数组之间来回复制。


一禅：不是啊，例如，在排序的过程中，主元在和j交换的时候是有可能破坏稳定性的，例如

把主元与j指向的元素进行交换



终于写完，这个快排写了挺长时间，觉得有收获的话，可以转发支持一波哦(´-ω-`)。
十大排序算法",
漫画：为什么说O(n)复杂度的基数排序没有快速排序快？,"掌握要求：基数排序只需要掌握基本的思想即可，代码写不出来也是没事滴

大家好，我是帅地，对于基数排序算法，考察的不多，我们需要掌握他的原理就可以了，看完这篇文章，我相信就能够大致掌握了。







老大：我简单给你讲下吧，你学过那么多排序，估计一看就懂了。基数排序，是一种基数“桶”的排序，他的排序思路是这样的：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……
排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是采用“桶”来排序的，基本原理就是把具有相同个（十、百等）位数的数放进同一个桶里。我直接给你个例子吧，保证你一看就懂。
例如我们现在要对这组元素来排序：

由于我们是以每个数的某位数来排序的，这位数的范围是0-9，所以我们需要10个桶。

第一遍，先以个位数排序，把具有相同个位数的数放进桶里，结果如下：

之后再按照从0号桶到9号桶的顺序取出来，结果如下

个位数排序完成。
第二遍，以十位数来排，结果如下：

再取出来放回去：
十位数排序完成，最终的结果就是一组有序的元素。如果元素中有百位数的话，大不了就按照百位数再给他重复排一遍。



老二：那我想问下，为啥要从个位数开始排序呢？可以直接从最高位开始排序吗？如果从最高位开始排序的话，如果一个数最高位比另一个数大，那么这个数就一定比另外一个数大了，不用在比较次高位了。这样的话，不是可以排的更快吗？

老大：脑子反应的挺快啊。是的，是可以以最高位来排序的，而且也像你说的，以最高位来排序的话，是可以减少数据之间比较的次数。但我们仍然不建议以最高位来排序，因为他有个致命的缺点。


老大:还是以刚才那个例子吧，我们一边用最高位来排序，一边来寻找这个致命的缺点。数组如下(元素的顺序改变了一些)：

第一遍：最高位十位数排序，结果如下(有些没用到的桶给省略了):

显然，不在桶一个桶里的数，他们的大小顺序已经是已知的了，也就是说，右边桶的数一定比左边桶的数大，所有在接下来的个位数排序里，我们只需要进行“各部分”单独排序就可以了，每一小部分都类似于原问题的一个子问题，做的时候可以采用递归的形式来处理。

最后汇总，即可完成排序：

这种方法确实可以减少比较的次数，不过请大家注意，在每个小部分的排序中，我们也是需要10个桶来将他们进行排序，最后导致的结果就是，每个不同值的元素都会占据一个“桶”，如果你有1000个元素，并且1000个元素都是不同值的话，那么从最高位排序到最低位，需要1000个桶。
这样子的话，空间花费不仅大，而且看起来有点背离基数排序最初的思想了（“背离”这个词，个人感觉而已）。所以，我们一般采用从最低位到最高位的顺序哦。

关于基数排序，还有以下几个问题，你不妨也想一想?
1、基数排序是一种用空间换时间的排序算法，数据量越大，额外的空间就越大?
我的想法：我觉得基数排序并非是一种时间换空间的排序，也就是说，数据量越大，额外的空间并非就越大。因为在把元素放进桶的时候，是完全可以用指针指向这个元素的，也就是说，只有初始的那些桶才算是额外的空间。
2、居然额外空间不是限制基数排序速度的原因，那为啥基数排序没有快速排序快呢？
基数的时间复杂度为O(n)，不过他是忽略了常数项，即实际排序时间为kn(其中k是常数项)，然而在实际排序的过程中，这个常数项k其实是很大的，这会很大程度影响实际的排序时间，而像快速排序虽然是nlogn，但它前面的常数项是相对比较小的，影响也相对比较小。
需要说明的是，基数排序也并非比快速排序慢，这得看具体情况，（不要被标题所影响哈）。而且，数据量越大的话，基数排序会越有优势。
3、有人可能会问，说了这么多，那到底是基数排序快还是快速排序快呢？
对于这样的问题，我只能建议你，自己根据不同的场景，撸几行代码，自己测试一下。
如果你问我，哪个排序在实际中用的更多，那么，我选快速排序。

十大排序算法",
什么是计数排序算法？,"计数排序、基数排序、桶排序，这几种排序算法，可能大家见到的这次不多，有些大学的教材课本中，甚至有些都没有计数排序算法。
所以呢，帅地今天就简单讲一讲计数排序算法吧，而不会像前面一样长篇大论，因为我觉得，每一个学习计数排序的，应该都是有一定的算法基础了，而对于计数排序，我觉得大家掌握最基本的思想就可以了，平时做算法题的时候，还是会偶尔用到。

  当然，计数排序如果要深入讲解，其实也是可以比较复杂的，但是这里，帅地只讲最简洁的，因为我觉得了解了基础的，就差不多了。

举个例子，假如我要给如下这个数组排序，你会如何排序呢？
输入 arr[] = {9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9}。
如果用快速排序，归并排序等这些排序算法的话，那么他们的时间复杂度其实是 O(nlogn)。
那么有没有一种方法，使得它的时间复杂度是 O(n) 呢？
答是有的，那便是计数排序。
计数排序的基本思想是这样的：把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。
例如对于上面那个例子，我们可以创建一个数组大小为 11 的临时数组 temp


  因为数组的最大值是 10，所以临时数组的最大下标为 10 即可。

然后遍历数组，第一个整数是9，那么数组下标为9的元素加1：

第二个整数是3，那么数组下标为3的元素加1：

最终，数列遍历完毕时，数组的状态如下：

之后我们只需要遍历临时数组 temp，输出临时数组元素的下标值即可，元素的值是几，就输出几次，结果如下：
0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10
显然，这个输出的数列已经是有序的了。
Java 代码如下（代码会做详细的注释）
优化一下
上面的代码中，我们是根据 max 的大小来创建对应大小的数组，假如原数组只有 10 个元素，并且最小值为 min = 10000，最大值为 max = 10005，那我们创建 10005 + 1 大小的数组不是很吃亏？最大值与最小值的差值为 5，所以我们创建大小为 6 的临时数组就可以了，这样可以节省空间浪费
也就是说，我们创建的临时数组大小 (max – min + 1)就可以了，然后我们再把 min作为偏移量。优化之后的代码如下所示：
我这里还给大家准备了一个动画，大家看看就好

有人可能会问，如果数组只有十个元素，最小值为 min = 0，最大值 max = 1000000。那我不是得创建一个 大小为 1000000 的数组？
或者说，如果我数组中有浮点数，那不就是无法作为下标来使用了？
别问，问就是，每一种排序算法都有它的局限性，不然还用啥快速排序，目前用的最广的感觉还是快速排序，想计数排序这种，适用特定领域数据下的排序，例如最大值和最小值的差值不是很大的整数数组。
十大排序算法",
十大排序算法极简汇总篇,"十大排序算法可以说是每个程序员都必须得掌握的了，如果你们像从 0 详细学习每一篇，那么你们可以看前面的文章。
但是呢，有些人可能已经学过，想要快速复习一下，看看代码怎么写的，那么可以看这篇十大排序极简汇总。
有些人可能不知道什么是稳定排序、原地排序、时间复杂度、空间复杂度，我这里先简单解释一下：
1、稳定排序：如果 a 原本在 b 的前面，且 a = = b，排序之后 a 仍然在 b 的前面，则为稳定排序。
2、非稳定排序：如果 a 原本在 b 的前面，且 a = = b，排序之后 a 可能不在 b 的前面，则为非稳定排序。
3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。
4、非原地排序：需要利用额外的数组来辅助排序。
5、时间复杂度：一个算法执行所消耗的时间。
6、空间复杂度：运行完一个算法所需的内存大小。
为了方便大家查找，我这里弄一个伪目录，没有跳转功能。
另：
代码说明：代码我自己写的，并且都是经过好几组数据测试通过，应该没啥问题，如有错，还请反馈下，谢谢。
图片说明：图片和动画都是在百度搜索的，如有侵权，还望联系我删除，谢谢
过程简单描述：
首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为选择排序。
如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是选择排序
漫画：什么是选择排序
代码如下：
性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序
我们在玩打牌的时候，你是怎么整理那些牌的呢？一种简单的方法就是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。当我们给无序数组做排序的时候，为了要插入元素，我们需要腾出空间，将其余所有元素在插入之前都向右移动一位，这种算法我们称之为插入排序。
过程简单描述：
1、从数组第2个元素开始抽取元素。
2、把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边。
3、继续选取第3，4，….n个元素,重复步骤 2 ，选择适当的位置插入。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是插入排序
漫画：什么是插入排序
代码如下：
性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、稳定排序  4、原地排序
1、把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置….
我们对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来之后，排在最右的元素就会是最大的数。
除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。
为方便理解我还准备了动图：
如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是冒泡排序
漫画：什么是冒泡排序
代码如下
性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、稳定排序  4、原地排序
优化一下冒泡排序的算法
假如从开始的第一对到结尾的最后一对，相邻的元素之间都没有发生交换的操作，这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。
代码如下：
希尔排序可以说是插入排序的一种变种。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n – 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。
希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。
希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。
为方便理解我还准备了图片：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是希尔排序
漫画：什么是希尔排序
代码如下
需要注意的是，对各个分组进行插入的时候并不是先对一个组排序完了再来对另一个组排序，而是轮流对每个组进行排序。
性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序
将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。
通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ….. 直到全部小的数组合并起来。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是归并排序
漫画：什么是归并排序
代码如下：
性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(n)  3、稳定排序  4、非原地排序
然而面试官要你写个非递归式的归并排序怎么办？别怕，我这还撸了个非递归式的归并排序，代码如下：
我们从数组中选择一个元素，我们把这个元素称之为中轴元素吧，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是有序的。也就是说，我们无需再移动中轴元素的位置。
从中轴元素那里开始把大的数组切割成两个小的数组(两个数组都不包含中轴元素)，接着我们通过递归的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素都处于有序的位置。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是快速排序
漫画：什么是快速排序
代码如下：
性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(logn)  3、非稳定排序  4、原地排序
堆的特点就是堆顶的元素是一个最值，大顶堆的堆顶是最大值，小顶堆则是最小值。
堆排序就是把堆顶的元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换….如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：漫画：什么是堆排序？
漫画：什么是堆排序？
代码如下：
性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序
计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。
基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：什么是计数排序？
什么是计数排序？
代码如下：
性质：1、时间复杂度：O(n+k)  2、空间复杂度：O(k)  3、稳定排序  4、非原地排序
注：K表示临时数组的大小，下同
优化一下
上面的代码中，我们是根据 max 的大小来创建对应大小的数组，假如原数组只有10个元素，并且最小值为 min = 10000，最大值为 max = 10005，那我们创建 10005 + 1 大小的数组不是很吃亏，最大值与最小值的差值为 5，所以我们创建大小为6的临时数组就可以了。
也就是说，我们创建的临时数组大小 (max – min + 1)就可以了，然后在把 min作为偏移量。优化之后的代码如下所示：
桶排序就是把最大值和最小值之间的数进行瓜分，例如分成  10 个区间，10个区间对应10个桶，我们把各元素放到对应区间的桶中去，再对每个桶中的数进行排序，可以采用归并排序，也可以采用快速排序之类的。
之后每个桶里面的数据就是有序的了，我们在进行合并汇总。
为方便理解我还准备了图片：

如果还是不懂的话我还给你准备了优质的文章讲解：什么是桶排序？
什么是桶排序？
代码如下：
性质：1、时间复杂度：O(n+k)  2、空间复杂度：O(n+k)  3、稳定排序  4、非原地排序
注：k 表示桶的个数，下同
基数排序的排序思路是这样的：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……
排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。
由于某位数（个位/十位….，不是一整个数）的大小范围为0-9，所以我们需要10个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照0号桶到9号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了
为方便理解我还准备了动图：

如果还是不懂的话我还给你准备了优质的文章讲解：为什么说O(n)复杂度的基数排序没有快速排序快？
为什么说O(n)复杂度的基数排序没有快速排序快？
代码如下：
性质：1、时间复杂度：O(kn)  2、空间复杂度：O(n+k)  3、稳定排序  4、非原地排序
用一张图汇总了10大排序算法的性质

如果你是复习/学习十大排序算法，一定要自己不看示例代码手动实现一遍，一定要自己不看示例代码手动实现一遍，一定要自己不看示例代码手动实现一遍。
十大排序算法",
如何判断一个数是否在40亿个整数中？,"题目：我有40亿个整数，再给一个新的整数，我需要判断新的整数是否在40亿个整数中，你会怎么做？











【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。


小史忙拉着吕老师问，为什么我说分8次加载数据，面试官会说太慢了呢？
吕老师：哈哈，从磁盘加载数据是磁盘io操作，是非常慢的，你每次都要加载这么大的数据，还要8次，我估计你找一个数的时间可以达到分钟甚至小时级了。

小史：那如果是你，你会怎么办呢？
吕老师：其实面试官已经提示得比较明显了，他说给你一批机器，就是暗示你可以用分布式算法。你把数据分散在8台机器上，然后来一个新的数据，8台机器一起找，最后再汇总结果就行了。

小史：这样的话能快多少？
吕老师：这样应该能达到秒级。小史，你可以自己分析分析。
小史：我想想……哦，这样做的话，因为每台机器都可以一次性把数据读入内存，在比较的时候不用来回加载数据了，所以可以节省加载数据的开销！这真是个好办法。
【更好方案】
吕老师：其实这并不是最好方法，我这还有一种毫秒级的方法，想不想知道啊？
小史：当然想啊，快教教我。

小史：哦，对哦，这样我就申请40亿个位就好了，新的数转换成一个位，然后判断一下这个位是0还是1就行了。
吕老师：小史啊，考虑问题要考虑清楚啊，如果是40亿个位，那么这40亿个位哪些是0，哪些是1呢？来了一个新的数，怎么判断是否在40亿个位之中？

小史：我想想，对啊，40亿个位，40亿个数，那么每个位都是1，这。。。
吕老师：其实你可以想想，32位int的范围，总共就是2的32次方，大概42亿多点。所以你可以申请2的32次方个位。
小史：意思是我把整个整数范围都覆盖了，哦，对哦。这样一来，就可以做了，1代表第一个位，2代表第二个位，2的32次方代表最后一个位。40亿个数中，存在的数就在相应的位置1，其他位就是0。

吕老师：没错，那来了一个新的数呢？
小史：新的数就去找相应的位，比如来了一个1234，就找一下第1234位，如果是1就存在，是0就不存在啦。
吕老师：没错，那么这样的话，需要多大内存呢？
小史：我想想啊，2的32次方个位，相当于2的29次方个字节，哇，才500MB，真是节省了不少内存呢。

小史：这么厉害的算法，你是怎么想到的？

吕老师：其实这是一种非常有名的大数据算法，叫位图法，英文名叫bitmap。顾名思义，就是用位来表示状态，从而节省空间。明天正好我有一节课，就讲位图法，你可以来听一听。
【吕老师的课】
第二天，吕老师开始上课，他一开始就抛出了小史遇到的面试题。
吕老师：同学们，这道题是BAT公司的一道面试题，大家有什么思路吗？
话音刚落，蛋哥就站起来回答。蛋哥是吕老师最得意的门生，以思维活跃著称。

蛋哥：我觉得可以这样。首先，32位int的范围是42亿，40亿整数中肯定有一些是连续的，我们可以先对数据进行一个外部排序，然后用一个初始的数和一个长度构成一个数据结构，来表示一段连续的数，举个例子。
如果数据是1 2 3 4 6 7……这种的，那么可以用(1,4)和(6,2)来表示，这样一来，连续的数都变成了2个数表示。
来了一个新数之后，就用二分法进行查找了。
这样一来，最差情况就是2亿多的断点，也就是2亿多的结构体，每个结构体8个字节，大概16亿字节，1.6GB，在内存中可以放下。

吕老师：嗯，非常好，不仅给出了方案，还能主动分析空间和可行性。
小史听完后深感佩服，问题的解决方法绝对不止一种，只要肯动脑筋，即使没有学过bitmap算法，也能有别的方法来解决问题。
【课后】
下课后，小史又找到吕老师。


吕老师：但是你的理解能力还是很强的，很多东西一听就懂，这可不是谁都能做到的。
算法面试
面试现场",
如何实现可以获取最小值的栈？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT。

今天他又去BAT中的一家面试了。
简单的自我介绍后，面试官给了小史一个问题。

题目：我现在需要实现一个栈，这个栈除了可以进行普通的push、pop操作以外，还可以进行getMin的操作，getMin方法被调用后，会返回当前栈的最小值，你会怎么做呢？你可以假设栈里面存的都是int整数。


























【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。





【异常情况处理】

吕老师：面试官已经提出了你的异常处理有点问题，当栈内为空的时候，你返回-1，但是如果用户push过-1，那么你返回-1的时候，是用户push进来的值，还是栈为空，就不得而知了。



小史咬咬牙：那就再定义一个类，里面包括一个int的data和一个boolean的isSuccess，正常情况下isSuccess是true，栈为空的话，isSuccess是false。这样就能区分开了吧？


小史突然一拍大腿：对哦，我可以用一个包装类Integer来定义返回值，如果是空，就代表栈为空就行了。它和int的区别就是它多了一个null，正好用来返回异常情况。

吕老师：嗯，越来越好，但是还是有点问题。你并没有站在使用者的角度考虑问题。使用你这个栈的人，在pop的时候，他并不知道可能返回null，如果他不做判断，后面的代码就可能抛出空指针了。




吕老师发来一个表情。




吕老师：没错，最关键的是，你显式抛出异常，如果使用者不捕获，那么编译就会报错，这样就把错误暴露在编译阶段，并且不需要和任何人商量所谓的特殊返回值了。


【算法优化】


吕老师一眼看穿了小史的心思。





小史想了想：明白了，我可以在push的时候判断一下，如果比最小值还大，就不加入辅助栈。pop的时候，如果不是最小值，辅助栈就不出栈。这样一来，辅助栈就不会有大量重复元素了。

小史：push的时候进行判断，如果数值比当前最小值大，就不动mins栈了，这样mins栈中不会保存大量冗余的最小值。pop的时候同样进行判断，只有pop出的数就是当前最小值的时候，才让mins出栈。



小史：如果push一个和最小值相等的元素，还是要入mins栈。不然当这个最小值pop出去的时候。data中还会有一个最小值元素，而mins中却已经没有最小值元素了。





小史：mins栈中改存最小值在data数组中的索引。这样一来，当push了与最小值相同元素的时候，就不需要动mins栈了。而pop的时候，pop出的元素的索引如果不是mins栈顶元素，mins也不出栈。同时，获取最小值的时候，需要拿到mins栈顶元素作为索引，再去data数组中找到相应的数作为最小值。


理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：


【小史的疑惑】
吃饭的时候，小史提出了心中埋藏已久的疑惑。


吕老师：数据结构和算法的设计是一个程序员的内功，工作时虽然用不到这么细，但是你在学习其他知识的底层原理的时候，到处都是数据结构和算法。



  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，这可以激励加速更新哦，也欢迎来留言催更，关注公众号「程序员内功修炼」，回复「读者」即可加入高质量读者群

算法面试
面试现场",
为什么要分稳定排序和非稳定排序？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他去了一家互联网小巨头公司面试了。
没想到面试并不像想象中的顺利。
【遇见吕老师】



【面试现场】







小史：原始数据，a2和a4的位置都是3。对于稳定排序来说，排序后的序列，a2一定还是在a4前面。但是对于非稳定排序来说，就不一定了，可能排完序之后，a4反而在a2的前面了。



题目：既然最后都是有序序列，为什么还要分稳定和非稳定的排序呢？

半分钟过去了。




【请教大神】



吕老师：笔试主要问是什么，而面试主要问为什么。


【吕老师的课】
吕老师一上课就把问题抛了出来。

话音刚落，蛋哥就站了起来。

蛋哥：咱们每次考试完成后，都会按照分数进行排序。分高的自然就是第一名。分数相同的同学怎么办呢？那就是按照上次的分数来分高低。上次分高的排在前面。

蛋哥：这个时候就应该用稳定排序，在上次排好序的序列上，再针对这次的分数进行排序。稳定排序的结果能保证这次相同分数的人，上次分高的在前面。

蛋哥：再比如我们班的同学，已经按照学号排好序了。现在要按照身高排序。如果是稳定排序排好之后，身高相同的同学，还是按照学号顺序的。

吕老师：没错，其实就是有两个排序关键字的时候，稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数。
小史听完后，觉得很惭愧，其实这些场景自己也遇到过，早该想到的。
【课后】
课后小史又找到吕老师。


吕老师：你看的东西很多，是你学到了很多知识。但是这些知识之间的关联，需要你进行深入思考才能得到的。找到知识之间的联系，找到知识和实际场景之间的联系，多想想为什么，才能做到融会贯通。
算法面试
面试现场",
如何找到字符串中的最长回文子串？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他又去一家互联网小巨头公司面试了。
【面试现场】







小史：只要先对比第一个字符和倒数第一个字符，再对比第二个字符和倒数第二个字符，以此类推。如果都相等，那就是回文串了。

题目：给你一个字符串，找出里面最长的回文子串。
例如
输入abcdcef，那么输出应该是cdc
输入adaelele，输出应该是elele





半分钟过去了。



小史：可以遍历整个字符串，把每个字符和字符间的空隙当作回文的中心，然后向两边扩展来找到最长回文串。
小史这次抢着分析时间和空间复杂度。



一分钟过去了。




【请教大神】
小史回到学校，把面试情况和吕老师说了一下。


吕老师：比如cabadabae用中心扩展的算法，我已经知道了第三位为中心的aba和第5位为中心的abadaba是回文，那么在判断第7位为中心的回文串的时候，有什么已知信息吗？


小史：已知第5位为中心的abadaba是回文，由回文的特性，就能够知道2-4位和6-8位对称，而又知道第3位为中心的aba是回文，所以2-4位是回文。这样的话，6-8位肯定是回文。





小史拿着笔在纸上画了半天，突然大叫一声。

小史：由于之前的计算已经知道了第5位为中心的abadaba是回文，而第4位为中心的a的回文长度是1，所以第6位为中心的回文长度只能是1，不用再去扩展判断了。





小史：以第7位为中心的回文串的计算，由之前分析已经知道最小长度是3了，但是还是需要进行扩展，因为第9位是什么根据之前的信息无法得知，需要扩展进行探索。


小史：而以第6位为中心的回文串的计算，并不需要进行探索了，因为根据之前第5位为回文中心串的信息和第4位为回文中心串的信息已经可以推断第6位为回文中心串的长度只能为1。










小史：当然可以。
1、首先，我们要记录下目前已知的回文串能够覆盖到的最右边的地方，就像案例中的第8位
2、同时，覆盖到最右边的回文串所对应的回文中心也要记录，就像案例中的第5位
3、以每一位为中心的回文串的长度也要记录，后面进行推断的时候能用到，就像案例中用到的以第3位为中心的回文和第4位为中心的回文
4、对于新的中心，我们判断它是否在右边界内，若在，就计算它相对右边界回文中心的对称位置，从而得到一些信息，同时，如果该中心需要进行扩展，则继续扩展就行。
【编码实现】


小史：回文的中心有可能是两个字符中间，这种情况没有考虑到啊。





小史：
1、先对字符串进行预处理，两个字符之间加上特殊符号#
2、然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整）
3、每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度
4、判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界
5、最后得到最长回文之后，去掉其中的特殊符号即可


理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
PlalindromeString.java
Main.java
运行结果：

【时间空间分析】










算法面试
面试现场",
如何在500w个单词中统计特定前缀的单词有多少个?,"如何在500w个单词中统计特定前缀的单词有多少个？

今天小史去了一家在线英语培训公司面试了。
简单的自我介绍后，面试官给了小史一个问题。

题目：我有500w个单词，你帮忙设计一个数据结构来进行存储，存好之后，我有两个需求。
1、来了一个新的单词，需要判断是否在这500w个单词中
2、来了一个单词前缀，给出500w个单词中有多少个单词是该前缀
小史这次没有不假思索就给出回答，他学会了深沉。


小史回忆起吕老师之前教他的 bitmap 算法。

小史心想：bitmap可以判断一个数是否在40亿个int32数中，其核心是每一个数映射成一个位，同时申请的bit位数覆盖了整个int32的值域。
小史在纸上算了半天，终于开口了。



小史：好的，我用bitmap来做第一问。我把每一个字符串映射成一个位。比如，a是第1位，b是第2位，z是第26位，aa是第27位，ab是第28位，以此类推。英文一共26个字母，我算了一下，6个字符长度的单词总共有26的6次方个，需要占26的6次方个位，大概300M









小史：建立数据结构的时候，排序需要花掉nlg(n)，排序时字符串比较花掉m，时间一共mnlg(n)。查找的话用二分，就是mlg(n)了。空间是mn。


一分钟过去了。




【请教大神】
回到学校，小史把面试情况和吕老师说了一下。

s

吕老师：你想想，a到z这26个字母中，可能只有a和i两个是单词，其他都不是，所以你的bitmap大量空间都被浪费了。这种情况你搞个hashset没准还更省一点。



【树形结构解难题】







小史：哦，这确实是节省了空间，如果要找单词interest，那么就找根节点了，如果是找单词interesting，那么就从根节点往下走，再把沿路的字母们都拼起来就行了。







（注：这里说的in不是单词，指的是in不是500w单词中的单词）
吕老师还没说完，小史就打断了他。








找单词interest：

找前缀为inter的所有单词：

遍历以前缀节点为根结点的一棵树，就能统计出前缀为inter的所有单词有多少个。
【字典树】












小史：节点中增加一个变量用于计数，在添加节点的时候，就把相应的计数+1



理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DictionaryTree.java
Main.java
运行结果
【字典树的应用】


小史：我想想啊，大量字符串的统计和查找应该就可以用字典树吧？字符串前缀的匹配也可以用，像咱们搜索常见的autoComplete控件是不是就可以用？




算法面试
面试现场",
如何在10亿数中找出前1000大的数？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

之前小史在BAT三家的面试中已经挂了两家，今天小史去了BAT中的最后一家面试了。
简单的自我介绍后，面试官给了小史一个问题。
【面试现场】

题目：如何在10亿数中找出前1000大的数？







小史：我可以用分治法，这有点类似快排中partition的操作。随机选一个数t，然后对整个数组进行partition，会得到两部分，前一部分的数都大于t，后一部分的数都小于t。


小史：如果说前一部分总数大于1000个，那就继续在前一部分进行partition寻找。如果前一部分的数小于1000个，那就在后一部分再进行partition，寻找剩下的数。





小史：首先，partition的过程，时间是o(n)。我们在进行第一次partition的时候需要花费n，第二次partition的时候，数据量减半了，所以只要花费n/2，同理第三次的时候只要花费n/4，以此类推。而n+n/2+n/4+…显然是小于2n的，所以这个方法的渐进时间只有o(n)

（注：这里的时间复杂度计算只是简化计算版，真正严谨的数学证明可以参考算法导论相关分析。）



半分钟过去了。







小史一时慌了神。

他回忆起了之前吕老师给他讲解bitmap时的一些细节。突然有了一个想法。




小史在纸上画了画。













理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
TopN.java
Main.java
运行结果：
（注：由于1000个数字符过多，超了微信文章限制，结果进行了省略，大家可以本地运行查看结果）
面试官看了一下。

小史熟练地介绍起了自己的项目，由于准备充分，小史聊起来游刃有余。面试官问的几个问题也进行了详细的解释。


小史走后，面试官在系统中写下了面试评语：

【遇见吕老师】
小史回到学校哼着歌走在校园的路上，正好碰到吕老师。


小史把面试情况和吕老师说了一下。


小史：感悟还挺深的。虽然平时做过topN的问题，知道分治法时间更少。但是碰到具体问题的时候还是要具体分析，这种大数据量的情况下反而用堆会更快。


算法面试
面试现场",
如何编程获得最多的年终红包奖？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天小史又去了一家互联网小巨头公司面试了。
【面试现场】












小史眉头一皱，发现事情并不简单。

题目：在数字矩阵中，从左上角到右下角，每次只能向右或向下，如何规划路径，能获得最大数字总和？
小史开始仔细分析问题，一时间竟想不到很好的方法。

小史心中反复默念题目，进行思考。

小史仔细回忆起了吕老师教他的华容道搜索算法。












【请教大神】
回到学校，小史把面试情况和吕老师说了一下。






吕老师：红色和蓝色两条路都能到达中间的100这个点，但是很明显，红色的路拿到的奖金更多。所以蓝色的路，后面不管再怎么走，都不可能拿到最大的奖金数了。


吕老师：假设蓝色路径再往后走出一条绿色路径是最大奖金，那么我把蓝色路径替换成红色路径，红色加绿色得到的奖金就比蓝色加绿色得到的多呀。


【记忆化搜索】







小史：哦，我明白了，这样我每搜到一个点，都可以和这个数比较，如果比它大，就更新这个数，继续搜，如果比它小，就不搜了，直接剪枝。





理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DeepFirstSearch.java
Main.java
运行结果
【记忆广搜】



吕老师：记忆深搜确实可以剪枝，但是假如有人刻意安排数字，把较小的数都安排在你先搜的路径上，那么你的计算量还是不会减少太多。


小史：还有这么坏的人呢？不过你这样一说我到想起来，深搜确实缺少一种“全局观”，可能第一条路搜完了，再来看第二条路，发现更好，结果第一条路全白搜了。





理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
BreadthFirstSearch.java
Main.java
运行结果
【动态规划】

吕老师：小史，代码写得不错，咱们再来看看广搜的过程，其实就是在搜索的过程中从左上到右下计算出了best(i,j)，所以为啥我们不能直接算出best(i,j)呢？






理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DynamicProgramming.java
Main.java
运行结果
【动态规划解析】






吕老师：状态的定义要满足几个点，第一，问题的答案是某种状态，或者可由状态进行推导。第二，当前状态可以由之前的状态推导而来。

【状态压缩】






小史：哦，我知道了，这道题，如果按照斜线方向来计算，只需要保留一条斜线的状态，就能计算出下一条斜线。所以之前的状态就不需要保留了。



理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DpCompressed.java
Main.java
运行结果




算法面试
面试现场",
如何编程解决朋友圈个数问题？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天小史去了一家社交小巨头公司面试了。
【面试现场】









面试官：举个例子，比如现在有5个宠物，分别是小猫1，小猫2，小猫3，小狗1，小狗2。再告诉你小猫1和小狗1是好朋友，小猫2和小狗1是好朋友，小猫3和小狗2是好朋友。这样它们之间就形成了2个朋友圈。










小史：先对宠物们编号，然后一对好友关系就用一个bitmap来存。判断两个bitmap之间是否有交集，只需要进行与操作。而融合的话只需要进行并操作。





小史在纸上画了半天进行思考。一分钟过去了。

小史：我好像知道了，可以在遍历好友关系的同时，把他们进行合并，我用双向链表来做。初始时，每个宠物都是一个单独的节点，而一对好友关系过来的时候，先判断两个节点是否在同一个链表中，如果不在，就把两个节点所在的链表头尾相连，形成一个新链表。



一分钟过去了。




【请教大神】
回到学校，小史把面试情况和吕老师说了一下。




















小史：这个我早就考虑到了，1和3是好朋友，并不是连接1和3，而是去找1的根和3的根，发现他们都是2，所以他们本来就在一个朋友圈，不需要相连。



【并查集】








小史：哦，对，堆也是一种树，但是它是二叉树，而且是完全二叉树，所以才能用数组存，并且用坐标的方式计算父亲孩子节点。


吕老师：今天的树同样可以用数组存，初始时刻数组中都是-1，当有两个节点需要合并时，只需要将其中一个数的根的值设为另一个数的根的下标就行。



小史在纸上划拉半天，终于有点明白了




理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了。
UnionFindSet.java
Main.java
运行结果
【基于树高度的合并优化】




吕老师：1和2是好朋友，2和3是好朋友，3和4是好朋友，4和5是好朋友







理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了。
UnionFindSetMergeOptimize.java
Main.java
运行结果
【路径压缩优化】








理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了。
UnionFindSetPathOptimize.java
Main.java
运行结果：
看着自己写的代码，小史还是忍不住赞叹。


算法面试
面试现场",
如何设计可自学习的五子棋AI？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他去了一家国内人工智能巨头公司面试了。
简单的自我介绍后，面试官开始发问了。

【面试现场】




题目：如何设计可自学习的五子棋AI？












【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。





【AlphaGO】









吕老师：一开始的AlphaGO是什么都不知道的，它是随机落子。但是它并不是random一个点，而是根据现场的情况和自身的算法，来落子，只是算法中的参数是随机的，所以落下的子也是随机的。







吕老师：这就要靠人去设计了，当然我们现在有一些比较成熟的神经网络模型，选好之后，所谓的训练啊，学习啊，其实都是在调节里面的参数。

【五子棋AI设计】

吕老师：首先我们来看你的算法，你会发现它的规则都是定死的，如果出现一种没有考虑到的情况，那么算法就不能进行堵截。



吕老师：哈哈，如果这样做的话，这种情况是无穷无尽的。而且五子棋的玩法比较简单，你还能设计出这样的规则，像围棋这种复杂的棋类，你可能没办法去设计这些规则了。




















小编注：关于这种算法的具体实现，由于篇幅较大就不在文章中具体展开了。想了解具体实现的朋友可以观看我在慕课网录制的免费视频教程：JS实现人机大战之五子棋（AI篇），地址：https://www.imooc.com/learn/644。
https://www.imooc.com/learn/644
【AI】






吕老师：小史，你看4个子的权重，你给10000，或者给50000，甚至给1个亿，对于其他值来说都是绝对高的值，所以最后效果应该是一样的。






吕老师：我们刚刚设计的这个五子棋算法，其实还是很简单，所以搜索空间并不大，如果是围棋这种复杂棋类，搜索空间将巨大无比，那就要采用非常先进的AI算法了，里面可能有成千上万个参数，训练起来计算量也是非常大，会有很多降维算法在里面，这些等你真正遇到，我再给你讲吧。


算法面试
面试现场",
为什么MySQL数据库要用B+树存储索引？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

话说两个多月前，小史通过了A厂的一面，两个多月后的今天，小史终于等到了A厂的二面。
简单的自我介绍后，面试官看了看小史的简历，开始发问了。

【面试现场】


小史：没问题，这个项目前端用的react+webpack，后端用的nginx+SpringBoot+Redis+MySql，前后端分离的，最后用docker进行容器化部署。主要模块有师生系统、课程系统、成绩系统、选课系统等。





这个项目的架构和说辞，小史早已背得溜溜的。

小史：底层mysql是存储，redis是缓存，dao层操作mysql，cache层操作redis，service层处理业务逻辑，rest api层为前端提供rest接口。前端这边用react进行模块化，webpack打包部署。网关nginx进行负载均衡。mysql、redis、nginx和springboot应用都放在docker里部署。














题目：为什么MySQL数据库要用B+树存储索引？
小史听到这个题目，陷入了回忆。
【前段时间的饭局】
话说吕老师给小史讲完人工智能的一些知识后，他们一起回家吃小史姐姐做的饭去了。


【饭后】


吕老师：面试的时候一定是往深了问，不精通的话容易吃亏。不过面试时一般都是根据项目来问，项目中用到的技术，一定要多看看原理，特别是能和数据结构和算法挂钩的那部分。



小史：树的话，无非就是前中后序遍历、二叉树、二叉搜索树、平衡二叉树，更高级一点的有红黑树、B树、B+树，还有之前你教我的字典树。
【红黑树】

一听到红黑树，小史头都大了，开始抱怨了起来。

小史：红黑树看过很多遍了，但是每次都记不住，它的规则实在是太多了，光定义就有四五条规则，还有插入删除的时候，需要调整树，复杂得很

吕老师：小史，问你红黑树，并不是让你背诵它的定义，或者让你手写一个红黑树，而是想问问你它为什么这样设计，它的使用场景有哪些。















【B树】

















吕老师：小史，你要知道，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。

两个月前，小史面试没考虑内存情况差点挂了，传送门
传送门






【B+树】







吕老师：这也是和业务场景相关的，你想想，数据库中select数据，不一定只选一条，很多时候会选多条，比如按照id排序后选10条。

小史：我明白了，如果是多条的话，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。


【回到现场】


小史：这和业务场景有关。如果只选一个数据，那确实是hash更快。但是数据库中经常会选择多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。

小史：而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。

HR和小史简单地聊了聊基本情况，这次面试就结束了。
小史走后，面试官在系统中写下了面试评语：

几天后，小史收到了A厂的offer。


亲爱的场粉们，面试现场的第一季到这里就全部结束了，感谢大家的支持，我们一起期待小史后面的故事。
算法面试
面试现场",
游戏中的敏感词过滤是如何实现的？,"小秋今天去面试了，面试官问了一个与敏感词过滤算法相关的问题，然而小秋对敏感词过滤算法一点也没听说过。于是，有了下下事情的发生…..
面试官：玩过王者荣耀吧？了解过敏感词过滤吗？，例如在游戏里，如果我们发送“你在干嘛？麻痹演员啊你？”，由于“麻痹”是一个敏感词，所以当你把聊天发出来之后，我们会用“**”来代表“麻痹”这次词，所以发送出来的聊天会变成这样：“你在干嘛？**演员啊你？”。
小秋：听说过啊，在各大社区也经常看到，例如评论一个问题等，一些粗话经常被过滤掉了。
面试官：嗯，如果我给你一段文字，以及给你一些需要过滤的敏感词，你会怎么来实现这个敏感词过滤的算法呢？例如我给你一段字符串“abcdefghi”,以及三个敏感词”de”, “bca”, “bcf”。
小秋：（敏感词过来算法？？不就是字符串匹配吗？）我可以通过字符串匹配算法，例如在字符串”abcdefghi”在查找是否存在字串“de”，如果找到了就把”de“用”**”代替。通过三次匹配之后，接变成这样了：“abc ** fghi”。
面试官：可以说说你采用哪种字符串匹配算法吗？
小秋：最简单的方法就是采用两个for循环保留求解了，不过每次匹配的都时间复杂度为O(n*m)，我可以采用 KMP 字符串匹配算法，这样时间复杂度是 O(m+n)。

  n 表示字符串的长度，m 表示每个敏感词的长度。

面试官：这是一个方法，对于敏感词过滤，你还有其他方法吗？
小秋：（其他方法？说实话，我也觉得不是采用这种 KMP 算法来匹配的了，可是，之前也没去了解过敏感词，这下要凉）对敏感词过来之前也没了解过，暂时没想到其他方法。
面试官：了解过 trie 树吗？
小秋：（嘿嘿，数据结构这方法，我得争气点）了解过，我还用代码实现过。
面试官：可以说说它的特点吗？
小秋：trie 树也称为字典树、单词查找树，最大的特点就是共享字符串的公共前缀来达到节省空间的目的了。例如，字符串 “abc”和”abd”构成的 trie 树如下：

trie 树的根节点不存任何数据，每整个个分支代表一个完整的字符串。像 abc 和 abd 有公共前缀 ab，所以我们可以共享节点 ab。如果再插入 abf，则变成这样：

如果我再插入 bc，则是这样（bc 和其他三个字符串没有公共前缀）

面试官：那如果再插入 “ab” 这个字符串呢？
小秋：差点说了，每个分支的内部可能也含有完整的字符串，所以我们可以对于那些是某个字符串结尾的节点做一个标记，例如 abc, abd,abf 都包含了字符串 ab,所以我们可以在节点 b 这里做一个标记。如下（我用红色作为标记）：

面试官：可以说说 trie 树有哪些应用吗？
小秋：trie 最大的特点就是利用了字符串的公共前缀，像我们有时候在百度、谷歌输入某个关键字的时候，它会给我们列举出很多相关的信息

这种就是通过 trie 树来实现的。
小秋：（嗯？ trie 又称为单词查找树，好像可以用 trie 来实现刚才的敏感词匹配？面试官无缘无故提 trie 树难道别有用意？）
面试官：刚才的敏感词过滤，其实也可以采用 trie 来实现，你知道怎么实现吗？
小秋：（果然，面试官真是个好人啊，直接提示了，要是还不知道怎么实现，那不真凉？）我想想……..我知道了，我可以这样来实现：
先把你给我的三个敏感词：”de”, “bca”, “bcf” 建立一颗 trie 树，如下：

接着我们可以采用三个指针来遍历，我直接用上面你给你例子来演示吧。
1、首先指针 p1 指向 root，指针 p2 和 p3 指向字符串第一个字符

2、然后从字符串的 a 开始，检测有没有以 a 作为前缀的敏感词，直接判断 p1 的孩子节点中是否有 a 这个节点就可以了，显然这里没有。接着把指针 p2 和 p3 向右移动一格。

3、然后从字符串 b 开始查找，看看是否有以 b 作为前缀的字符串，p1 的孩子节点中有 b，这时，我们把 p1 指向节点 b，p2 向右移动一格，不过，p3不动。

4、判断 p1 的孩子节点中是否存在 p2 指向的字符c，显然有。我们把 p1 指向节点 c，p2 向右移动一格，p3不动。

5、判断 p1 的孩子节点中是否存在 p2 指向的字符d，这里没有。这意味着，不存在以字符b作为前缀的敏感词。这时我们把p2和p3都移向字符c，p1 还是还原到最开始指向 root。

6、和前面的步骤一样，判断有没以 c 作为前缀的字符串，显然这里没有，所以把 p2 和 p3 移到字符 d。

7、然后从字符串 d 开始查找，看看是否有以 d 作为前缀的字符串，p1 的孩子节点中有 d，这时，我们把 p1 指向节点 d，p2 向右移动一格，不过，p3和刚才一样不动。（看到这里，我猜你已经懂了）

8、判断 p1 的孩子节点中是否存在 p2 指向的字符e，显然有。我们把 p1 指向节点 e，并且，这里e是最后一个节点了，查找结束，所以存在敏感词de，即 p3 和 p2 这个区间指向的就是敏感词了，把 p2 和 p3 指向的区间那些字符替换成 *。并且把 p2 和 p3 移向字符 f。如下：

9、接着还是重复同样的步骤，知道 p3 指向最后一个字符。
面试官：可以说说时间复杂度吗？
小秋：如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。

  这里我说明一下，在实际的应用中，构建 trie 树的时间复杂度我觉得可以忽略，因为 trie 树我们可以在一开始就构建了，以后可以无数次重复利用的了。而刚才的 kmp 算法时间复杂度是 t *(m+n)，不过kmp需要维护 next 数组比较费空间，而且在实际情况中,敏感词的数量 t 是比较大，而 n 反而比较小的吧。

10、如果让你来 构建 trie 树，你会用什么数据结构来实现？
小秋：我一般使用 Java，我会采用 HashMap 来实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。
面试官：嗯，回去等通知吧。
今天主要将了 trie 树以及 trie 树的一些应用，还要就是如何通过 trie 树来实现敏感词的过滤，至于代码的实现，我这里就不给出了，在实现的时候，为了防止这种”麻 痹”或者“麻￥痹”等，我们也要对特殊字符进行过滤等，有兴趣的可以去实现一波。
算法面试
面试现场",
如何只用2GB内存从20/40/80亿个整数中找到出现次数最多的数,"这几天小秋去面试了，不过最近小秋学习了不少和位算法相关文章，对于算法题还是有点信心的，，，，于是，发现了如下对话。
面试官：如果我给你 2GB 的内存，并且给你 20 亿个 int 型整数，让你来找出次数出现最多的数，你会怎么做？
小秋：（嗯？怎么感觉和之前的那道判断一个数是否出现在这 40 亿个整数中有点一样？可是，如果还是采用 bitmap 算法的话，好像无法统计一个数出现的次数，只能判断一个数是否存在），我可以采用哈希表来统计，把这个数作为 key，把这个数出现的次数作为 value，之后我再遍历哈希表哪个数出现最多的次数最多就可以了。
面试官：你可以算下你这个方法需要花费多少内存吗？
小秋：key 和 value 都是 int 型整数，一个 int 型占用 4B 的内存，所以哈希表的一条记录需要占用 8B，最坏的情况下，这 20 亿个数都是不同的数，大概会占用 16GB 的内存。
面试官:你的分析是对的，然而我给你的只有 2GB 内存。
小秋：（感觉这道题有点相似，不过不知为啥，没啥思路，这下凉凉），目前没有更好的方法。
面试官：按照你那个方法的话，最多只能记录大概 2 亿多条不同的记录，2 亿多条不同的记录，大概是 1.6GB 的内存。
小秋：（嗯？面试官说这话是在提示我？）我有点思路了，我可以把这 20 亿个数存放在不同的文件，然后再来筛选。
面试题：可以具体说说吗？
小秋：刚才你说，我的那个方法，最多只能记录大概 2 亿多条的不同记录，那么我可以把这 20 亿个数映射到不同的文件中去，例如，数值在 0 至 2亿之间的存放在文件1中，数值在2亿至4亿之间的存放在文件2中….，由于 int 型整数大概有 42 亿个不同的数，所以我可以把他们映射到 21 个文件中去，如图

显然，相同的数一定会在同一个文件中，我们这个时候就可以用我的那个方法，统计每个文件中出现次数最多的数，然后再从这些数中再次选出最多的数，就可以了。
面试官：嗯，这个方法确实不错，不过，如果我给的这 20 亿个数数值比较集中的话，例如都处于 1~20000000 之间，那么你都会把他们全部映射到同一个文件中，你有优化思路吗？
小秋：那我可以先把每个数先做哈希函数映射，根据哈希函数得到的哈希值，再把他们存放到对应的文件中，如果哈希函数设计到好的话，那么这些数就会分布的比较平均。（关于哈希函数的设计，我就不说了，我这只是提供一种思路）
面试官：那如果我把 20 亿个数加到 40 亿个数呢？
小秋：（这还不简单，映射到42个文件呗）那我可以加大文件的数量啊。
面试官：那如果我给的这 40 亿个数中数值都是一样的，那么你的哈希表中，某个 key 的 value 存放的数值就会是 40 亿，然而 int 的最大数值是 21 亿左右，那么就会出现溢出，你该怎么办？
小秋：（那我把 int 改为 long 不就得了，虽然会占用更多的内存，那我可以把文件分多几份呗，不过，这应该不是面试官想要的答案），我可以把 value 初始值赋值为 负21亿，这样，如果 value 的数值是 21 亿的话，就代表某个 key 出现了 42 亿次了。

这里说明下，文件还是 21 个就够了，因为 21 个文件就可以把每个文件的数值种类控制在 2亿种了，也就是说，哈希表存放的记录还是不会超过 2 亿中。

面试官：反应挺快哈，那我如果把 40 亿增加到 80 亿呢？
小秋：（我靠，这变本加厉啊）………我知道了，我可以一边遍历一遍判断啊，如果我在统计的过程中，发现某个 key 出现的次数超过了 40 亿次，那么，就不可能再有另外一个 key 出现的次数比它多了，那我直接把这个 key 返回就搞定了。
面试官：行，此次面试到此结束，回去等通知吧。
今天这篇文章主要讲了大数据处理相关的一些问题，后面可能还会给大家找一些类似，但处理方式不同的题勒.
算法面试
面试现场",
二叉树刷题简介,"和链表刷题类似，这里会提供十几二十道不同类型的二叉树题型，我觉得你把这些题型搞定，无论是面试还是啥，基本不用怕二叉树相关题型了。
不过如果你不会递归的话，做二叉树的题可能不大好做，因为二叉树的题，90% 可以用递归搞定，建议配合我讲解递归的文章一起做：告别递归，谈谈我的一些经验。
告别递归，谈谈我的一些经验
不过说实话，在面试中，二叉树其实考的不多吧，如果实在来不及刷题，就先把几种遍历方式掌握了吧。
必须要说明的是，这部分的题，我的解答并不会很详细哈，基本就是说一下大致的思路，然后就给出题解了，目前是用 Java 来写，后续会填补上 python 和 C++，当然，如果你愿意给帅地提供这些代码，帅地会不胜感激。
帅地的愿景就是，把该文章的教程，打造成全网质量最高的编程学习网站，所以会尽最大努力去保证每篇文章的质量，也欢迎你提出意见，和我一起维护这个网站
二叉树",
十大排序算法简介,"大家好，我是帅地。
十大排序算法其实平时用到的不多，就那几个常用的，所以我们更多的是要学习这些排序算法的设计思想。需要核心掌握的主要有：快速排序，递归排序，冒泡排序，希尔排序，这四个排序在面试的时候考的会多一些，特别是快速排序。
学习排序算法，需要至少知道啥是时间复杂度，不懂的可以看这边：漫画：什么是时间复杂度
漫画：什么是时间复杂度
这里要感谢「趣谈编程」公众号，因为大部分文章来自于他的授权，然后我把这些文章，重新整理成了漫画版本。
每篇文章基本都把你当成一个小白来讲解，所以每篇文章的对话都好多，为了把这十篇弄成漫画，帅地好几晚都把脖子搞痛了，，，

因为这种对话型漫画，可以让小白更加易懂，但是呢，也有部分人是快速复习一下，所以我也搞了一篇极简的十大排序汇总版。
目前十大排序会用 Java 写，后续可能会把 Python，C，Go 这些语言补上，你们如果愿意，也可以评论区给出其他代码了，目前还在更新中，这里先占个坑位。
1. 漫画：什么是冒泡排序算法？
1. 漫画：什么是冒泡排序算法？
2. 漫画：什么是选择排序算法？
2. 漫画：什么是选择排序算法？
3. 漫画：什么是插入排序算法？
3. 漫画：什么是插入排序算法？
4. 漫画：什么是希尔排序算法？
4. 漫画：什么是希尔排序算法？
5. 漫画：什么是归并排序算法？
5. 漫画：什么是归并排序算法？
6. 漫画：什么是快速排序算法？
6. 漫画：什么是快速排序算法？
7. 漫画：什么是堆排序算法？
7. 漫画：什么是堆排序算法？
8. 漫画：为什么说O(n)复杂度的基数排序没有快速排序快？
8. 漫画：为什么说O(n)复杂度的基数排序没有快速排序快？
9. 什么是计数排序算法？
9. 什么是计数排序算法？
10. 十大排序算法极简汇总篇
10. 十大排序算法极简汇总篇
帅地的愿景就是，把该文章的教程，打造成全网质量最高的编程学习网站，所以会尽最大努力去保证每篇文章的质量，也欢迎你提出意见，和我一起维护这个网站
十大排序算法",
数据结构与算法学习路线,"如何学习算法的相关文章，大家估计也见过不少，每个人的学习方法都不尽相同，这很正常，并且，对于不同的选手，例如打 ACM 的玩家和不打比赛的玩家来说，训练的方式也会有所差异，所以别人所说的学习方式，更多的是作为你的一种参考。
在我的四年大学里，花在学习数据结构/算法的时间可以说是最多的了，不过我并不后悔，因为算法基础的沉淀，给我后面的成长带来了很多帮助，所以今天这篇文章，帅地会根据自己的理解，谈一谈如何学习算法，如果你是这方面的小白的话，还是可以参考一下。
不过，在写之前，我想先回答几个问题，或许对于那些刚入门的同学，有些许帮助。
1、有必要学算法吗？
很多过来人可能都会跟你说，算法没必要学，你又不是算法岗，工作其实就天天 crud，用啥都是封装好的，学了也用不到，慢慢也就忘了。
这篇文章不是来跟你辩论有没有必要学算法的，我就做个简单的回答，我的答案是，有必要学一学，一个现实且势利的原因，估计就是 —– 大厂都喜欢考察算法了，不信你去问问刚刚参加过 2020 校招的同学，我自己也参加过 2019 的秋招，算法考察，基本无处不在，如果想要获得面试机会，那么就得笔试，而笔试，大部分公司都是编程题，即算法题，而且，面试中也会经常问到算法，数据结构。显然，从找公司的角度看，不学算法你会失去很多面试的机会。然而，更重要的还是，程序 = 数据结构 + 算法，算法基本功打好，可以让我们走的更远。
2、学算法好慢/好难，是我不够聪明不适合学算法吗？
答不是的，如果只是学习下常见算法，以后应付下面试/笔试 + 分析下工作遇到的一些问题，那么我觉得，还论不到天赋来做审判，这绝对不是鸡汤，当然，如果你想打 ACM，拿各种奖的，那我就不大清楚了。
简单的说，学算法好慢/好难主要还是你代码写的太少了，做的题太少了，虽然有些人学起来会慢一些，特别是入门那会，但一旦过了这道坎，学起来就会快很多，所以，不要还没学之前，或者学了一时半会觉得自己没有 get 到点，就否定自己。
我是学习了《数据结构与算法分析》这本书之后，再去学习各种算法思想 + 刷题的，所以我觉得，入门算法的第一步，是在你学会了一门语言之后（帅地当时学的是 C 语言），静下心来啃一本数据结构与算法的书籍，例如我说的《数据结构与算法分析:xx语言描述版》，也可以是《大话数据结构》等等。
怎么学这本书呢？
我觉得，对于刚刚入门的选手来说，没啥技巧，也不要迷恋于各种快捷的方法，咱们老实点，当个普通人，就跟着书学，按照顺序学就可以了，然后把里面例子的代码，都至少打一遍，当然，还需要跑通，结果要符合预期，如果不符合，就调试到符合预期。
注意，上面那句话我打了颜色，说明这句话非常重要，千万不要觉得自己理解了，就不写代码了，例如觉得自己理解了链表的增删改，然后就不写代码了，在编程这一块，感觉自己理解，和成功实现且符合预期，特么就是两回事。
之后每一章都会有习题，不需要全部做，自己挑几道做就好了，就算是一眼就秒杀知道怎么做的，其实也可以实现一遍，如果不懂，可以找答案，但是一定要自己在电脑上把代码敲打出来，然后跑通。当你把书上 90% 的代码例子跑通，那么，这本书有一半的知识，就是你的了。
这里我说下，你们找的书籍，最好是有完整代码实现的，因为有些书籍，为了具有通用性或者严谨性，是采用伪代码来实现的，我不建议初学者用这类书籍，因为容易一脸蒙蔽，代码也不好跑通验证，所以如果你觉得自己是普通人，那么就找一本有完整代码的书籍来看吧，然后乖乖把代码的代码敲打跑通起来。
不要眼高手低，当你积累到一定的代码数量，你就会慢慢来感觉了。
当你学完了链表、队列、栈、二叉树、哈希表等最基本的数据结构，其实你就算入门了，这个时候其实你已经具备了去 leetcode 刷题的能力了。不过在学习过程中，特别是到了图那部分，会涉及到很多算法，例如最短路径，深度搜索和广度搜索…当然，还有二叉树的各种遍历等。
如果你对递归一点也不懂，那么你会被虐的，脑袋也容易被爆栈，因为，递归真的无处不在，这也引出了我觉得入门算法非常重要的一个算法思想 — 递归算法。
如果你连最基本的数据结构，例如链表，队列，栈，二叉树都没有接触过，那么我是不建议你去 leetcode 刷题的，所以我上面先说了先入门一下数据结构与算法，当你学习了这些基础的数据结构之后，其实已经具备了刷题的能力了。
不过，我还是希望你能在学习一些算法思想，一般就这几种
1、递归
2、枚举
3、贪心
4、回溯
5、动态规划
但是，其中最重要的，我觉得就是递归，其他的几种算法，也都会有递归的影子，并且我刚才说图相关算法、二叉树的遍历等，也都包含递归的使用。
所以，在你刷题之前，或者在学习二叉树、图相关算法遇到递归的时候，我希望你能静下心来，去学一学递归，我也会告诉你，对于初学者，递归很难，我是被无数次折腾，无数次看答案似懂非懂之后，才突然醒悟了。
你不需要把它学的很精通，但是你要懂一些基本的递归题，知道递归是怎么一回事，例如最简单的斐波那契数列得会用递归做吧？阶乘也会吧（虽然不是最优解）。
所以，死磕入门数据结构，可以学习下一些算法思想，而递归，你必须得入门，至于动态规划、回溯，我觉得慢点学也没有，可以后面刷题遇到时在学，而枚举、贪心，相对比较简单。
关于递归的，可以看我之前的一遍入门级的文章：为什么你学不会递归？告别递归，谈谈我的一些经验
为什么你学不会递归？告别递归，谈谈我的一些经验
评价还是很好，之后找些简单的题做，例如在 LintCode 那些 easy 的题（leetcode 和 lintcode 类似，类似于一个中文版，一个英文版）
终于，到了刷题这一部分了，如果要说学算法的捷径，那么刷题便是最好的捷径，如果你刷的题很少，达不到一定的量，那么再多的捷径，估计也没啥用，只有在满足一定题量的情况下，才适合来谈论所谓的技巧。
1、先说一说笔试
不过在刷题之前我想先说一说笔试，如果笔试不考算法，面试也不考算法，那么我可能在学习算法的这条路上，会少了很多的积极性，你可能会觉得我很功利，但是我觉得，带着功利性的目的去学习算法，也是完全没问题的。
在校招的笔试中，其实这些笔试题还是挺难的，你在 leectode 可以做出 hard 级别的题，但在笔试中，可能连 medium 级别的都做不出，因为笔试的题，都比较灵活，基本都会通过实际的例子来引出一道题，你可能不知道要使用哪种方法来做比较好，有些还是多种方法的结合。
对于笔试的题型，我之前也总结过，无非是以下几种
（1）、基本数据结构的考察：这类题我觉得是比较简单的，主要考场基本数据结构的操作，例如二叉树的层序遍历，链表的逆序等，当然，它不会直接告诉你，让你来逆序或者遍历。
（2）、某种算法思想的掌握：这类题你掌握了某种算法思想，就会比较容易，如果不懂，那就凉凉了。例如动态规划、回溯、枚举、深度/广度、贪心、二分等。其中，我觉得动态规划考的挺多，还要就是 回溯+深度/广度。
（3）、边界条件的考察：这类型的题，估计你一看就有思路，知道该怎么做，但是，它的边界条件特别多，需要分很多种情况来讨论，特别容易出错，有时候会让人陷进去，越做越复杂，这类题主要考场你的思维严谨程度。
（4）、找规律、数学公式：这类型的题，主要是根据数据之间的一些关系，来找一些规律，进而推出他们的通用公式，就像我们高中时，找数列的同项一样。
2、按分类刷题
上面我列了笔试的题型，并且跟你说了笔试是真的挺难的，那么对于我个算法小白来说，该如何做好呢？
我的建议是，分类刷题，阶段性总结。例如最开始可以在 LintCode 按照链表/二叉树/递归等这些标签来刷，因为这样可以让你深入掌握每一种方法。
当然，笔试的题之所以难，是因为我们往往不知道用哪一种方法做好，或者说具体属于哪一种题型，那么还有必要分类刷题吗？
答是有必要的，只有当你熟悉每一种题型，你才能灵活使用他们，进而解决各类复杂的题，这就如同你在练功夫的时候，前期你需要把每个招式都打扎实了，之后才能灵活把各个招式连接起来，融合贯通。刷题也是一样，前期先分类，把每个题型掌握起来，后期咱们再随机练习，慢慢着就能灵活应用了。
不过，每次刷了一部分题型之后，我觉得还有必要做一些总结，或者说总结一些刷题模版，例如对于二分法查找，其实好几种题型总结起来，就是开闭区间的组合，你可以把他们总结起来，例如什么时候用开区间，什么时候用闭区间。
有人可能会说，模版是死的，真的有必要总结吗？
我觉得有必要总结，但没必要死记，总结，只是加深你的理解，当然，如果你在做题的时候，刚好记住了自己的模版，可以直接套上去，那肯定更好。但是，就算忘了也没事，通过自己的总结，你其实是知道怎么做的了，只是还需要你多花一点时间，快速模拟讨论下各种情况，一样能够做出来的。
也就是说，最开始刷题的时候，可以分类刷题，并且阶段性总结，如果你是初学者，可以先从简单的题做起，例如我刚才说的，简单的递归题，之后一些二叉树、链表的题，因为你可能刚刚学习数据结构不久，刚好可以加深你的理解。
当我们在做一道题的时候，可能会遇到两种情况，一种是这道题，特么秒杀，一眼就懂思路；一种是，一脸蒙蔽，太难了吧。
一眼就懂思路，有必要做吗？
我的答案是，有必要做。千万不要眼高手低，看着简单，做起来不一定简单，AC 之后，你还要去讨论区看看大佬们是怎么做的，因为有些人的代码，真的写的很简洁，看着就很舒服，咱们可以多学一学的，当然，也有可能那个人就是你自己。
代码写多了，有时候，你就会发现自己真的变强了，写起代码来，bug 也越来越少了，分分钟 AC 一道题。
尽量最优解
其实对于很多题，如果不看时间复杂度和空间复杂度，单单只是 AC，那还是很容易的，但是一提交，你的代码可能只打败了百分之几的人，显然我们是不能满足于这种代码的。
当你做一道题时，一开始可以先暴力做，但后面，还得想想该如何优化，想不出也没事，可以讨论区找空间/时间复杂度更低的代码，或者直接搜索引擎搜索，一般都能搜到别人的代码。
之后跟着别人的代码，自己再实现一波，尽可能把最优解的代码实现起来。千万不要为了 AC 而 AC，不是 AC 的越多就越强的，当你入门之后，更多的是要总结方法，寻找高效率的代码。
说到算法的学习方式，对我来说，真的没有什么捷径之类的，就是像我上面说的，先找本书死磕入门数据结构，就跟着书的例子，把例子跑起来就好了，跑起来也不是一件简单的事情。之后就去接触下一些算法思想，后面就可以分类刷题了，刷题就是最好的捷径了。
当然，不要 AC 之后就完事了，应该尽可能寻找最优解，当你积累了一定的题量，那么你真的会发现自己变强了，突然感觉递归也就那么一回事。
我学习算法时，基本看书 + 网上刷题，也很少看视频，因为我觉得看视频比较花时间，不过我之前在班里还是看到部分人喜欢看视频的，至于看书好还是看视频好，这个看个人喜好吧，也没有说哪种就一定更好。
最后，帅地还是希望大家能够静下心来，好好学习下数据结构与算法，我觉得最沉得下心的阶段就是大一大二了，所以这个时间点，是学习算法的最佳时间，千万不要想着我先学别的，以后再来学，以后学可能会理解的更加深刻。
不要想太多了，你以后怕是更加懒的学，你以后会很难静下心来学的。所以，千万不要想以后，现在，就是最佳的学习时间。
学习经验",
各科目学习路线简介,"如果你要看各个技术栈的学习路线，可以在这个「学习路线」的专题看：https://www.iamshuaidi.com/?p=277， 这个专题的粒度比「学习路线」更细，会具体讲解各个科目的学习以及核心掌握的知识点。
https://www.iamshuaidi.com/?p=277
例如会讲算法学习，MySQL 需要掌握的核心考点，计算机网络，Java 等等。
讲解的过程中，可能也会有部分核心的被帅地忽略，欢迎各位提出来。
1. 我是如何学习算法的？
1. 我是如何学习算法的？
2. 我是如何学习计算机基础知识的？
2. 我是如何学习计算机基础知识的？
3. 我的 MySQL 学习之路
3. 我的 MySQL 学习之路
4. Spring 学习路线
4. Spring 学习路线
帅地的愿景就是，把该文章的教程，打造成全网质量最高的编程学习网站，所以会尽最大努力去保证每篇文章的质量，也欢迎你提出意见
学习经验",
五大算法思想简介,"本系列会讲解常见算法思想，分别是递归，动态规划，贪心，枚举，回溯等，并且会配套练习题。
帅地会根据自己做题的心得，向大家展现出我平时是如何做这些问题的，并且这些教程的讲解方式，全网唯一。
每一种算法思想讲解完之后，帅地会配套一些练习题供大家做，基于时间原因，这些练习题，我可能不会给出对应的解答过程。
假如你是按照我的套路来做这些题的，也欢迎把自己的解题过程写成文章给我，这样可能加深你的理解，我也会给你一些稿费之类的，最重要的还是，可以供其他小伙伴参考。
告别递归算法，谈谈我的一些经验
告别递归算法，谈谈我的一些经验
递归训练一：Leetcode 104.二叉树的最大深度
递归训练一：Leetcode 104.二叉树的最大深度
递归训练二：Leetcode 62.不同路径
递归训练二：Leetcode 62.不同路径
递归训练三：剑指 Offer 16. 数值的整数次方
递归训练三：剑指 Offer 16. 数值的整数次方
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
告别动态规划，谈谈我的一些经验
告别动态规划，谈谈我的一些经验
动态规划优化，谈谈我的一些经验
动态规划优化，谈谈我的一些经验
动归训练一：Leetcode 198.大家劫舍
动归训练一：Leetcode 198.大家劫舍
动归训练二：Leetcode 54. 最大子序和
动归训练二：Leetcode 54. 最大子序和
 动规训练三：Leetcode 322. 零钱兑换
 动规训练三：Leetcode 322. 零钱兑换
动规训练四：Leetcode 10. 正则表达式
动规训练四：Leetcode 10. 正则表达式
帅地的愿景就是，把该文章的教程，打造成全网质量最高的编程学习网站，所以会尽最大努力去保证每篇文章的质量，也欢迎你提出意见
五大算法思想",
链表专题简介,"在这个专题，我大概会给出 20 道左右的链表题型吧，如果你把我写的这 20 道题都理解 + 代码敲出来了，那么应付面试，是搓搓有余的。
如果是在面试，链表的考察应该是非常频繁的，并且考来考去都是那几道题，例如链表反转，链表中间节点，链表倒数第二个节点，链表成环。
但是呢，作为一名想要学习算法的小伙伴，我认为我们不能止步于此，而是要多做几道，这样会让你更加深刻去理解链表，并且在未来，遇到任何题，都能够顺手拈来。
必须要说明的是，这部分的题，我的解答并不会很详细哈，基本就是说一下大致的思路，然后就给出题解了，目前是用 Java 来写，后续会填补上 python 和 C++，当然，如果你愿意给帅地提供这些代码，帅地会不胜感激。
帅地的愿景就是，把该文章的教程，打造成全网质量最高的编程学习网站，所以会尽最大努力去保证每篇文章的质量，也欢迎你提出意见，和我一起维护这个网站
链表",
链表训练3：如何优雅着反转单链表,"反转单链表。例如链表为：
1->2->3->4
反转后为
4->3->2->1
如果链表的长度为 N, 时间复杂度达到 O(N), 额外空间复杂度达到 O(1)
方法1
这道题还是挺简单的，当我们在反转一个节点的时候，把一个节点的后驱改为指向它前驱就可以了。这里需要注意的点就是，当你把当前节点的后驱指向前驱的时候，这个时候链表会被截断，也就是说后面的节点和当前节点分开了，所以我们需要一个变量来保存当前节点的后驱，以访丢失。
具体代码如下：
代码如下
方法二
这道题也可以用递归来做，假设 方法 reverse() 的功能是将单链表进行逆转。采用递归的方法时，我们可以不断着对子链表进行递归。例如对于如下的链表：

我们对子链表 2->3->4 进行递归，即
Node newList = reverse(head.next)。递归之后的结果如下：

逆转之后子链表 2->3->变为了 4->3->2。
注意，我刚才假设 reverse() 的功能就是对链表进行逆转。不过此时节点 1 仍然是指向节点 2 的。这个时候，我们再把节点1 和 2逆转一下，然后 1 的下一个节点指向 null 就可以了。如图：

递归的结束条件就是：当子链表只有一个节点，或者为 null 时，递归结束。代码如下：
题目：反转部分链表节点
题目：给定一个单向链表的头结点head,以及两个整数from和to ,在单项链表上把第from个节点和第to个节点这一部分进行反转
列如：
1->2->3->4->5->null,from=2,to=4
结果：1->4->3->2->5->null
列如：
1->2->3->null from=1,to=3
结果为3->2->1->null
1、如果链表长度为N，时间复杂度要求为O（N),额外空间复杂度要求为O（1）
2、如果不满足1<=from<=to<=N,则不调整
可以自己动手做一下或者想一下，我这里直接给出答案了
另外，链表反转这道题一定要掌握递归版本的，因为递归版本是最不容易出错的，这道题的考察频率也是挺高的
如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….
https://www.iamshuaidi.com
链表",
链表训练5：三种方法带你优雅判断回文链表,"给定一个链表的头节点 head, 请判断该链表是否为回文结构。
例如：
1->2->1，返回 true.
1->2->2->1, 返回 true。
1->2->3，返回 false。
如果链表的长度为 N, 时间复杂度达到 O(N)。
方法1
我们可以利用栈来做辅助，把链表的节点全部入栈，在一个一个出栈与链表进行对比，例如对于链表 1->2->3->2->2，入栈后如图:

然后再逐一出栈与链表元素对比。
这种解法比较简单，时间复杂度为 O(n), 空间复杂度为 O(n)。
代码如下
方法二
真的需要全部入栈吗？其实我们也可以让链表的后半部分入栈就可以了，然后把栈中的元素与链表的前半部分对比，例如 1->2->3->2->2 后半部分入栈后如图：

然后逐个出栈，与链表的前半部分(1->2)对比。这样做的话空间复杂度会减少一半。
代码如下：
方法三：空间复杂度为 O(1)。
上道题我们有作过链表的反转的，没看过的可以看一下勒：【链表问题】如何优雅着反转单链表]，我们可以把链表的后半部分进行反转，然后再用后半部分与前半部分进行比较就可以了。这种做法额外空间复杂度只需要 O(1), 时间复杂度为 O(n)。
【链表问题】如何优雅着反转单链表
代码如下:
这道题被问的概率也是挺高的，就算代码写不出，也得至少知道思路
思考：如果给你的是一个环形链表，并且指定了头节点，那么该如何判断是否为回文链表呢？

  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….

链表",
链表训练6：将单向链表按某值划分成左边小，中间相等，右边大的形式,"给定一个单向链表的头结点head,节点的值类型是整型，再给定一个整数privot。实现一个调整链表的函数，将链表调整为左部分都是值小于privot的节点，中间部分都是值等于privot的节点，右部分都是大于privot的节点。且对某部分内部节点的顺序不做要求 
例如:链表9-0-4-5-1，pivot=3。 
调整后是1-0-4-9-5，
也可以是0-1-9-5-4
如果链表的长度为 N, 时间复杂度达到 O(N)。
这道题在思路上还是比较简单的，但是在实现上还是有一些细节需要主要的。
本题对某部分的内部节点不做要求，一种很简单的方法就是用一个数组来存链表的节点，然后像类似于快速排序的分割函数那样，按照某个值把他们进行划分。
不过这样做的话，空间复杂度为 O(N)。我们也可以采取使用3个指针，把原链表依次划分成三个部分的链表，然后再把他们合并起来，这种做法不但空间复杂度为 O(1), 而且内部节点的顺序也是和原链表一样的。虽然思路简单，但在代码实现上也是有很多细节需要注意的，有时间的话希望大家动手打下码。
代码如下
思考：如果给你的是一个环形链表，让你来划分，又该如何实现呢？
如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….
https://www.iamshuaidi.com
链表",
链表训练7：复制含有随机指针节点的链表,"如果链表的长度为 N, 时间复杂度达到 O(N)。
尉：★★☆☆
方法一：使用额外的存储空间
这道题的难点在于我们需要定位好随机指针，一个比较简单的解法就是把原节点与复制的节点关联起来，可以使用哈希表把他们关联起来。
首先把副节点全部创建出来，然后把原节点与对应的副节点用哈希表关联起来。关联的时候原节点作为key，副节点作为value。例如对于链表 1->2->3->null。创建副节点 1′, 2′, 3’。然后用哈希表关联起来：
之后在把所有副节点连接成一个链表。在连接的时候，我们 可以通过哈希表很容易这找到对应的随机节点。
代码如下
这种方法的时间复杂度为 O(n), 空间复杂度也为 O(n)。
方法2
其实我们也可以不需要哈希表来辅助，也就是说 ，我们是可以做到空间复杂度为 O(1)的，我们可以把复制的副节点插入到原链表中去，这样也能把原节点与副节点进行关联，进而
定位到随机节点。例如，对于链表 1->2->3->null。首先生成副节点 1′, 2′, 3。然后把副节点插入到原节点的相邻位置，即把原链表变成 1->1′->2->2′->3->3′->null。
这样我们也可以在连接副节点的时候，找到相应的随机节点。例如 1 的随机节点是 3，则 1′ 的随机节点是 3’。显然，1节点的随机节点的下一个节点就是 1’的随机节点。具体代码如下：
采用这种方法的时候，由于随机节点有可能是空指针，随意写代码的时候要注意。
思考：如果是有两个随机指针呢？又该如何处理呢？三个呢？

  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….

链表",
链表训练8：将单链表的每K个节点之间逆序,"给定一个单链表的头节点head, 实现一个调整单链表的函数，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。
例如：
链表:1->2->3->4->5->6->7->8->null, K = 3。
调整后：3->2->1->6->5->4->7->8->null。其中 7，8不调整，因为不够一组。
如果链表的长度为 N, 时间复杂度达到 O(N)。
尉：★★☆☆
对于这道题，如果你不知道怎么逆序一个单链表，那么可以看一下我之前写的【链表问题】如何优雅着反转单链表
【链表问题】如何优雅着反转单链表
这道题我们可以用递归来实现，假设方法reverseKNode()的功能是将单链表的每K个节点之间逆序。reverse()方法的功能是将一个单链表逆序。
那么对于下面的这个单链表，其中 K = 3。

我们把前K个节点与后面的节点分割出来：

temp指向的剩余的链表，可以说是原问题的一个子问题。我们可以调用reverseKNode()方法将temp指向的链表每K个节点之间进行逆序。再调用reverse()方法把head指向的那3个节点进行逆序，结果如下：

接着，我们只需要把这两部分给连接起来就可以了。最后的结果如下：

如果不大理解，看下代码可能就比较好理解了。
代码如下
当然，这道题一个很简单的做法就是利用栈来辅助，每K个节点入栈就把这K个节点出栈连接成一个链表，之后剩余再在进栈.....
不过这种做法的额外空间复杂度是O(K)。
思考：如果这是一个环形单链表呢？该如何实现呢？

  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….

链表",
链表训练9：将搜索二叉树转换成双向链表,"对于二叉树的节点来说，有本身的值域，有指向左孩子和右孩子的两个指针；对双向链表的节点来说，有本身的值域，有指向上一个节点和下一个节点的指针。在结构上，两种结构有相似性，现有一棵搜索二叉树，请将其转为成一个有序的双向链表。
　
节点定义：
例如：

这棵二查搜索树转换后的双向链表从头到尾依次是 1～9。对于每一个节点来说，原来的 right 指针等价于转换后的 next 指针，原来的 left 指针等价于转换后的 last 指针，最后返回转换后的双向链表的头节点。
如果链表的长度为 N, 时间复杂度达到 O(N)。
尉：★★☆☆
方法一：采用队列辅助
如果用一个队列来辅助的话，还是挺容易。采用中序遍历的方法，把二叉树的节点全部放进队列，之后在逐一弹出来连接成双向链表。
代码如下
这种方法的时间复杂度为 O(n), 空间复杂度也为 O(n)。
方法2：通过递归的方式
在之前打卡的9道题中，几乎超过一般都用到了递归，如果这些题目使用的递归大家都理解了，并且能够自己独立写出代码了，那么我相信大家对递归的思想、使用已经有一定的熟练性。
我们假设函数conver的功能就是把二叉树变成双向链表，例如对于这种一棵二叉树：

经过conver转换后变成这样：

注意，转换之后，把最右边节点的right指针指向了最左边的节点的。
对于下面这样一颗二叉树：

采用conver函数分别对左右子树做处理，结果如下：

之后，再把他们连接起来

了解了基本原理之后，直接看代码吧。
时间复杂度为O(n),空间复杂度为O(h)，其中h是二叉树的高度。
原理虽然不难，但写起代码，还是有挺多细节需要注意的，所以一直强调，有时间的话，一定要自己手打一遍代码，有时你以为自己懂了，可能在写代码的时候，发现自己并没有懂，一写就出现很多bug。

  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….

链表",
链表训练4：环形单链表约瑟夫问题,"输入：一个环形单向链表的头节点 head 和报数 m.
返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删除掉。
方法1：时间复杂度为 O( n * m)
这道题如果不考虑时间复杂度的话还是挺简单的，就遍历环形链表，每遍历 m 个节点就删除一个节点，知道链表只剩下一个节点就可以了。
代码如下
这个方法的时间复杂度为 O(n * m)。下面用时间复杂度为方法解决。
方法二：时间复杂度为 O(n)
我们可以给环形链表的节点编号，如果链表的节点数为 n, 则从头节点开始，依次给节点编号，即头节点为 1， 下一个节点为2， 最后一个节点为 n.
我们用 f(n) 表示当环形链表的长度为n时，生存下来的人的编号为 f(n)，显然当 n = 1 时，f(n) = 1。假如我们能够找出 f(n) 和 f(n-1) 之间的关系的话，我们我们就可以用递归的方式来解决了。我们假设 人员数为 n, 报数到 m 的人就自杀。则刚开始的编号为
…
m – 2
m – 1
m
m + 1
m + 2
…
进行了一次删除之后，删除了编号为m的节点。删除之后，就只剩下 n – 1 个节点了，删除前和删除之后的编号转换关系为：
删除前 ——– 删除后
… ———- …
m – 2 ——- n – 2
m – 1 —— n – 1
m ———- 无(因为编号被删除了)
m + 1 —— 1(因为下次就从这里报数了)
m + 2 —— 2
… ——– …
新的环中只有 n – 1 个节点。且编号为 m + 1, m + 2, m + 3 的节点成了新环中编号为 1， 2， 3 的节点。
假设 old 为删除之前的节点编号， new 为删除了一个节点之后的编号，则 old 与 new 之间的关系为 old = (new + m – 1) % n + 1。
注：有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m – 1) % n + 1.
这样，我们就得出 f(n) 与 f(n – 1)之间的关系了，而 f(1) = 1.所以我们可以采用递归的方式来做。
代码如下：
另外，约瑟夫这道题一定要掌握递归版本的，因为递归版本是最不容易出错的，这道题的考察频率也是挺高的
关于约瑟夫问题，我还写过用一行代码直接搞定约瑟夫问题的，可以用来装逼：记一次阿里笔试：一行代码解决约瑟夫环问题的
记一次阿里笔试：一行代码解决约瑟夫环问题的
对于上道题，假设是从第 K 个节点开始报数删除呢？ 又该如何解决呢？
如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….
https://www.iamshuaidi.com
链表",
