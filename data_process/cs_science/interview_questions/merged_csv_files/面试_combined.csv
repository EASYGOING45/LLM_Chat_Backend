问题,回答,所属分类
Go基础面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 与其他语言相比，使用 Go 有什么好处
1. 与其他语言相比，使用 Go 有什么好处
2. Golang 使用什么数据类型
2. Golang 使用什么数据类型
3. Go 程序中的包是什么
3. Go 程序中的包是什么
4. Go 支持什么形式的类型转换
4. Go 支持什么形式的类型转换
5. 什么是 Goroutine
5. 什么是 Goroutine
6. 如何在运行时检查变量类型
6. 如何在运行时检查变量类型
7. Go 两个接口之间可以存在什么关系
7. Go 两个接口之间可以存在什么关系
8. Go 当中同步锁有什么特点 作用是什么
8. Go 当中同步锁有什么特点 作用是什么
9. Go 语言当中 Channel（通道）有什么特点，需要注意什么
9. Go 语言当中 Channel（通道）有什么特点，需要注意什么
10. Go 语言当中 Channel 缓冲有什么特点
10. Go 语言当中 Channel 缓冲有什么特点
11. Go 语言中 cap 函数可以作用于那些内容
11. Go 语言中 cap 函数可以作用于那些内容
12. go convey 是什么？一般用来做什么
12. go convey 是什么？一般用来做什么
13. Go 语言当中 new 和 make 有什么区别吗
13. Go 语言当中 new 和 make 有什么区别吗
14. Go 语言中 make 的作用是什么
14. Go 语言中 make 的作用是什么
15. Printf(),Sprintf(),FprintF() 都是格式化输出，有什么不同
15. Printf(),Sprintf(),FprintF() 都是格式化输出，有什么不同
16. Go 语言当中数组和切片的区别是什么
16. Go 语言当中数组和切片的区别是什么
17. Go 语言当中值传递和地址传递（引用传递）如何运用 有什么区别 举例说明
17. Go 语言当中值传递和地址传递（引用传递）如何运用 有什么区别 举例说明
18. Go 语言当中数组和切片在传递的时候的区别是什么
18. Go 语言当中数组和切片在传递的时候的区别是什么
19. Go 语言是如何实现切片扩容的
19. Go 语言是如何实现切片扩容的
20. 看下面代码的 defer 的执行顺序是什么？ defer 的作用和特 点是什么
20. 看下面代码的 defer 的执行顺序是什么？ defer 的作用和特 点是什么
21. Golang Slice 的底层实现
21. Golang Slice 的底层实现
22. Golang Slice 的扩容机制，有什么注意点
22. Golang Slice 的扩容机制，有什么注意点
23. 扩容前后的 Slice 是否相同
23. 扩容前后的 Slice 是否相同
24. Golang 的参数传递、引用类型
24. Golang 的参数传递、引用类型
25. Golang Map 底层实现
25. Golang Map 底层实现
26. Golang Map 如何扩容
26. Golang Map 如何扩容
27. Golang Map 查找
27. Golang Map 查找
28. 介绍一下 Channel
28. 介绍一下 Channel
29. Go 语言的 Channel 特性
29. Go 语言的 Channel 特性
30. Channel 的 ring buffer 实现
30. Channel 的 ring buffer 实现
Go面试题

ㅤ永久会员",
与其他语言相比，使用 Go 有什么好处,"⚫ 与其他作为学术实验开始的语言不同，Go代码的设计是务实的。每个功能和语法决策都旨在让程序员的生活更轻松。
⚫ Golang 针对并发进行了优化，并且在规模上运行良好。
⚫ 由于单一的标准代码格式，Golang 通常被认为比其他语言更具可读性。
⚫ 自动垃圾收集明显比 Java 或 Python 更有效，因为它与程序同时执行。
Go面试题

ㅤ永久会员",
Golang 使用什么数据类型,"Golang 使用以下类型：
⚫ Method
⚫ Boolean
⚫ Numeric
⚫ String
⚫ Array
⚫ Slice
⚫ Struct
⚫ Pointer
⚫ Function
⚫ Interface
⚫ Map
⚫ Channel
Go面试题

ㅤ永久会员",
Go 程序中的包是什么,"包 (pkg) 是 Go 工作区中包含 Go 源文件或其他包的目录。源文件中的每个函数、变量和类型都存储在链接包中。每个 Go 源文件都属于一个包，该包在文件顶部使用以下命令声明：
您可以使用以下方法导入和导出包以重用导出的函数或类型：
Golang 的标准包是 fmt，其中包含格式化和打印功能，如 Println().
Go面试题

ㅤ永久会员",
Go 支持什么形式的类型转换,"将整数转换为浮点数。 Go 支持显式类型转换以满足其严格的类型要求。
Go面试题

ㅤ永久会员",
什么是 Goroutine,"你如何停止它？ 一个 Goroutine 是一个函数或方法执行同时旁边其他任何够程采用了特殊的Goroutine 线程。Goroutine 线程比标准线程更轻量级，大多数 Golang 程序 同时使用数千个 g、Goroutine。
要创建 Goroutine，请 go 在函数声明之前添加关键字。
您可以通过向 Goroutine 发送一个信号通道来停止它。Goroutines 只能在被告知检查时响应信号，因此您需要在逻辑位置（例如 for 循环顶部）包含检 查。
Go面试题

ㅤ永久会员",
如何在运行时检查变量类型,"类型开关是在运行时检查变量类型的最佳方式。类型开关按类型而不是值来评估变量。每个 Switch 至少包含一个 case，用作条件语句，和一个defaultcase，如果没有一个 case 为真，则执行。
Go面试题

ㅤ永久会员",
Go 两个接口之间可以存在什么关系,"如果两个接口有相同的方法列表，那么他们就是等价的，可以相互赋值。如果接口 A 的方法列表是接口 B 的方法列表的自己，那么接口 B 可以赋值给接口A。接口查询是否成功，要在运行期才能够确定。
Go面试题

ㅤ永久会员",
Go 当中同步锁有什么特点 作用是什么,"当一个 Goroutine（协程）获得了 Mutex 后，其他 Gorouline（协程）就只能乖乖的等待，除非该 gorouline 释放了该 MutexRWMutex 在读锁占用的情况下，会阻止写，但不阻止读 RWMutex 在写锁占用情况下，会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占 同步锁的作用是保证资源在使用时的独有性，不会因为并发而导致数据错乱， 保证系统的稳定性。
Go面试题

ㅤ永久会员",
Go 语言当中 Channel（通道）有什么特点，需要注意什么,"如果给一个 nil 的 channel 发送数据，会造成永远阻塞如果从一个 nil 的 channel 中接收数据，也会造成永久爱阻塞给一个已经关闭的 channel 发送数据， 会引起 pannic 从一个已经关闭的 channel 接收数据， 如果缓冲区中为 空，则返回一个零值
Go面试题

ㅤ永久会员",
Go 语言当中 Channel 缓冲有什么特点,"无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的。
Go面试题

ㅤ永久会员",
Go 语言中 cap 函数可以作用于那些内容,"cap 函数在讲引用的问题中已经提到，可以作用于的类型有：
⚫ array(数组)
⚫ slice(切片)
⚫ channel(通道)
Go面试题

ㅤ永久会员",
go convey 是什么？一般用来做什么,"⚫ go convey 是一个支持 golang 的单元测试框架
⚫ go convey 能够自动监控文件修改并启动测试，并可以将测试结果实时输出 到 Web 界面
⚫ go convey 提供了丰富的断言简化测试用例的编写
Go面试题

ㅤ永久会员",
Go 语言当中 new 和 make 有什么区别吗,"new 的作用是初始化一个纸箱类型的指针 new 函数是内建函数，函数定义：
⚫ 使用 new 函数来分配空间
⚫ 传递给 new 函数的是一个类型，而不是一个值
⚫ 返回值是指向这个新非配的地址的指针
Go面试题

ㅤ永久会员",
Go 语言中 make 的作用是什么,"make 的作用是为 slice, map or chan 的初始化 然后返回引用 make 函数是内建函数，函数定义：
make(T, args)函数的目的和 new(T)不同 仅仅用于创建 slice, map,  channel 而且返回类西行是实例
Go面试题

ㅤ永久会员",
"Printf(),Sprintf(),FprintF() 都是格式化输出，有什么不同","虽然这三个函数，都是格式化输出，但是输出的目标不一样。Printf 是标准输出，一般是屏幕，也可以重定向。 Sprintf()是把格式化字符串输出到指定的字符串中。 Fprintf()是吧格式化字符串输出到文件中。
Go面试题

ㅤ永久会员",
Go 语言当中数组和切片的区别是什么,"数组：
数组固定长度数组长度是数组类型的一部分，所以[3]int 和[4]int 是两种不同的数组类型数组需要指定大小，不指定也会根据处初始化对的自动推算出大小，不可改变数组是通过值传递的
切片：
切片可以改变长度切片是轻量级的数据结构，三个属性，指针，长度，容量不需要指定大小切片是地址传递（引用传递）可以通过数组来初始化，也可以通过内置函数 make()来初始化，初始化的时候 len=cap，然后进行扩容。
Go面试题

ㅤ永久会员",
Go 语言当中值传递和地址传递（引用传递）如何运用 有什么区别 举例说明,"Go面试题

ㅤ永久会员",
Go 语言当中数组和切片在传递的时候的区别是什么,"Go面试题

ㅤ永久会员",
Go 语言是如何实现切片扩容的,"Go面试题

ㅤ永久会员",
看下面代码的 defer 的执行顺序是什么？ defer 的作用和特 点是什么,"defer 的作用是：
你只需要在调用普通函数或方法前加上关键字 defer，就完成了 defer 所需要的语法。当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行。直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反。
defer 的常用场景：
⚫ defer 语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。
⚫ 通过 defer 机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。
⚫ 释放资源的 defer 应该直接跟在请求资源的语句后。
Go面试题

ㅤ永久会员",
Golang Slice 的底层实现,"切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化。 切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一 个只读对象，其工作机制类似数组指针的一种封装。
切片对象非常小，是因为它是只有 3 个字段的数据结构：
⚫ 指向底层数组的指针
⚫ 切片的长度
⚫ 切片的容量
Go面试题

ㅤ永久会员",
Golang Slice 的扩容机制，有什么注意点,"Go 中切片扩容的策略是这样的：
⚫ 首先判断，如果新申请容量大于 2 倍的旧容量，最终容量就是新申请的容 量
⚫ 否则判断，如果旧切片的长度小于 1024，则最终容量就是旧容量的两倍
⚫ 否则判断，如果旧切片长度大于等于 1024，则最终容量从旧容量开始循环增加原来的 1/4, 直到最终容量大于等于新申请的容量
⚫ 如果最终容量计算值溢出，则最终容量就是新申请容量
Go面试题

ㅤ永久会员",
扩容前后的 Slice 是否相同,"情况一：
原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组，对一个切片的操作可能影响多个指针指向相同地址 的 Slice。
情况二：
原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响 原数组。 要复制一个 Slice，最好使用 Copy 函数。
Go面试题

ㅤ永久会员",
Golang 的参数传递、引用类型,"Go 语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct 等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等 这些），这样就可以修改原内容数据。
Golang 的引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除了申请内存外，还需要初始化相关属性。内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函数，由其分 配内存和初始化成员结构，返回对象而非指针。
Go面试题

ㅤ永久会员",
Golang Map 底层实现,"Golang 中 map 的底层实现是一个散列表，因此实现 map 的过程实际上就是实现散表的过程。在这个散列表中，主要出现的结构体有两个，一个叫 hmap(a  header for a go map)，一个叫 bmap(a bucket for a Go map，通常叫其 bucket)。
Go面试题

ㅤ永久会员",
Golang Map 如何扩容,"装载因子：count/2^B
触发条件：
解决方法：
Go面试题

ㅤ永久会员",
Golang Map 查找,"Go 语言中 map 采用的是哈希查找表，由一个 key 通过哈希函数得到哈希值，64位系统中就生成一个 64bit 的哈希值，由这个哈希值将 key 对应到不同的桶（bucket）中，当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲突。key 经过 hash 后共 64 位，根据 hmap 中 B 的值，计算它到底要落在哪个桶时，桶的数量为 2^B，如 B=5，那么用 64 位最后 5 位表示第几号桶，在用 hash 值的高 8 位确定在 bucket 中的存储位置，当前 bmap 中的 bucket 未找到，则查询对应的 overflow bucket，对应位置有数据则对比完整的哈希值，确定是否是要查找的数据。
如果两个不同的 key 落在的同一个桶上，hash 冲突使用链表法接近，遍历 bucket 中的 key 如果当前处于 map 进行了扩容，处于数据搬移状态，则优先从 oldbuckets 查找。
Go面试题

ㅤ永久会员",
介绍一下 Channel,"Go 语言中，不要通过共享内存来通信，而要通过通信来实现内存共享。Go 的CSP(Communicating Sequential Process)并发模型，中文可以叫做通信顺序进程，是通过 goroutine 和 channel 来实现的。
所以 channel 收发遵循先进先出 FIFO，分为有缓存和无缓存，channel 中大致有 buffer(当缓冲区大小部位 0 时，是个 ring buffer)、sendx 和 recvx 收发的位置(ring buffer 记录实现)、sendq、recvq 当前 channel 因为缓冲区不足 而阻塞的队列、使用双向链表存储、还有一个 mutex 锁控制并发、其他原属等。
Go面试题

ㅤ永久会员",
Go 语言的 Channel 特性,"从一个 nil channel 接收数据，造成永远阻塞
给一个已经关闭的 channel 发送数据，引起 panic
Go面试题

ㅤ永久会员",
Channel 的 ring buffer 实现,"channel 中使用了 ring buffer(环形缓冲区) 来缓存写入的数据。ring  buffer 有很多好处，而且非常适合用来实现 FIFO 式的固定长度队列。 在 channel 中，ring buffer 的实现如下：

hchan 中有两个与 buffer 相关的变量:recvx 和 sendx。其中 sendx 表示 buffer 中可写的 index，recvx 表示 buffer 中可读的 index。 从 recvx 到 sendx 之间的元素，表示已正常存放入 buffer 中的数据。 我们可以直接使用 buf[recvx]来读取到队列的第一个元素，使用 buf[sendx] =  x 来将元素放到队尾。
Go面试题

ㅤ永久会员",
Go并发面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. Mutex 几种状态
1. Mutex 几种状态
2. Mutex 正常模式和饥饿模式
2. Mutex 正常模式和饥饿模式
3. Mutex 允许自旋的条件
3. Mutex 允许自旋的条件
4. RWMutex 实现
4. RWMutex 实现
5. RWMutex 注意事项
5. RWMutex 注意事项
6. Cond 是什么
6. Cond 是什么
7. Broadcast 和 Signal 区别
7. Broadcast 和 Signal 区别
8. Cond 中 Wait 使用
8. Cond 中 Wait 使用
9. WaitGroup 用法
9. WaitGroup 用法
10. WaitGroup 实现原理
10. WaitGroup 实现原理
11. 什么是 sync.Once
11. 什么是 sync.Once
12. 什么操作叫做原子操作
12. 什么操作叫做原子操作
13. 原子操作和锁的区别
13. 原子操作和锁的区别
14. 什么是 CAS
14. 什么是 CAS
Go面试题

ㅤ永久会员",
Mutex 几种状态,"⚫ mutexLocked — 表示互斥锁的锁定状态；
⚫ mutexWoken — 表示从正常模式被从唤醒；
⚫ mutexStarving — 当前的互斥锁进入饥饿状态；
⚫ waitersCount — 当前互斥锁上等待的 Goroutine 个数；
Go面试题

ㅤ永久会员",
Mutex 正常模式和饥饿模式,"正常模式(非公平锁)
正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁的拥有。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败。在这种情况下，这个被 唤醒的 goroutine 会加入到等待队列的前面。 如果一个等待的 goroutine 超过1ms 没有获取锁，那么它将会把锁转变为饥饿模式。
饥饿模式(公平锁)
为了解决了等待 G 队列的长尾问题
饥饿模式下，直接由 unlock 把锁交给等待队列中排在第一位的 G(队头)，同时，饥饿模式下，新进来的 G 不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部,这样很好的解决了老的 g 一直抢不到锁的场景。
饥饿模式的触发条件，当一个 G 等待锁时间超过 1 毫秒时，或者当前队列只剩下一个 g 的时候，Mutex 切换到饥饿模式。
总结
对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取 锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的 一个平衡模式。
Go面试题

ㅤ永久会员",
Mutex 允许自旋的条件,"Go面试题

ㅤ永久会员",
RWMutex 实现,"通过记录 readerCount 读锁的数量来进行控制，当有一个写锁的时候，会将读锁数量设置为负数 1<<30。目的是让新进入的读锁等待写锁之后释放通知读锁。同样的写锁也会等等待之前的读锁都释放完毕，才会开始进行后续的操作。 而等写锁释放完之后，会将值重新加上 1<<30, 并通知刚才新进入的读锁 (rw.readerSem)，两者互相限制。
Go面试题

ㅤ永久会员",
RWMutex 注意事项,"⚫ RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁
⚫ 读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁
⚫ 写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占
⚫ 适用于读多写少的场景
⚫ RWMutex 类型变量的零值是一个未锁定状态的互斥锁。
⚫ RWMutex 在首次被使用之后就不能再被拷贝。
⚫ RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发 panic。
⚫ RWMutex 的一个写锁 Lock 去锁定临界区的共享资源，如果临界区的共享 资源已被（读锁或写锁）锁定，这个写锁操作的 goroutine 将被阻塞直到解锁。
⚫ RWMutex 的读锁不要用于递归调用，比较容易产生死锁。
⚫ RWMutex 的锁定状态与特定的 goroutine 没有关联。一个 goroutine 可以 RLock（Lock），另一个 goroutine 可以 RUnlock（Unlock）。
⚫ 写锁被解锁后，所有因操作锁定读锁而被阻塞的 goroutine 会被唤醒，并都可以成功锁定读锁。
⚫ 读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而被阻塞的 goroutine，其中等待时间最长的一个 goroutine 会被唤醒。
Go面试题

ㅤ永久会员",
Cond 是什么,"Cond 实现了一种条件变量，可以使用在多个 Reader 等待共享资源 ready 的场景（如果只有一读一写，一个锁或者 channel 就搞定了）
每个 Cond 都会关联一个 Lock（*sync.Mutex or *sync.RWMutex），当修改条件或者调用 Wait 方法时，必须加锁，保护 condition。
Go面试题

ㅤ永久会员",
Broadcast 和 Signal 区别,"Broadcast 会唤醒所有等待 c 的 goroutine。 调用 Broadcast 的时候，可以加锁，也可以不加锁。
Signal 只唤醒 1 个等待 c 的 goroutine。 调用 Signal 的时候，可以加锁，也可以不加锁。
Go面试题

ㅤ永久会员",
Cond 中 Wait 使用,"Wait()会自动释放 c.L，并挂起调用者的 goroutine。之后恢复执行，Wait()会在返回时对 c.L 加锁。
除非被 Signal 或者 Broadcast 唤醒，否则 Wait()不会返回。
由于 Wait()第一次恢复时，C.L 并没有加锁，所以当 Wait 返回时，调用者通常并不能假设条件为真。
取而代之的是, 调用者应该在循环中调用 Wait。（简单来说，只要想使用condition，就必须加锁。）
Go面试题

ㅤ永久会员",
WaitGroup 用法,"一个 WaitGroup 对象可以等待一组协程结束。
使用方法是：
worker 协程执行结束以后，都要调用 wg.Done()；
main 协程调用 wg.Wait() 且被 block，直到所有 worker 协程全部执行结束后返回。
Go面试题

ㅤ永久会员",
WaitGroup 实现原理,"⚫ WaitGroup 主要维护了 2 个计数器，一个是请求计数器 v，一个是等待计数器 w，二者组成一个 64bit 的值，请求计数器占高 32bit，等待计数器占低 32bit。
⚫ 每次 Add 执行，请求计数器 v 加 1，Done 方法执行，请求计数器减 1，v为0 时通过信号量唤醒 Wait()。
Go面试题

ㅤ永久会员",
什么是 sync.Once,"⚫ Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。
⚫ Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。
⚫ sync.Once 只暴露了一个方法 Do，你可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回值 的函数。
Go面试题

ㅤ永久会员",
什么操作叫做原子操作,"一个或者多个操作在 CPU 执行过程中不被中断的特性，称为原子性 (atomicity)。
这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。而在现实世界中，CPU不可能不中断的执行一系列操作，但如果我们在执行多个操作时，能让他们的中间状态对外不可见，那我们就可以宣城他们拥有了“不可分割”的原子性。
在 Go 中，一条普通的赋值语句其实不是一个原子操作。列如，在 32 位机器上写 int64 类型的变量就会有中间状态，因为他会被拆成两次写操作(MOV)——写低 32 位和写高 32 位。
Go面试题

ㅤ永久会员",
原子操作和锁的区别,"原子操作由底层硬件支持，而锁则由操作系统的调度器实现。锁应当用来保护一段逻辑，对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算机多核的优势，如果要更新的是一个复合对象，则应当使用 atomic.Value 封装好的实现。
Go面试题

ㅤ永久会员",
什么是 CAS,"CAS 的全称为 Compare And Swap，直译就是比较交换。是一条 CPU 的原子指令，其作用是让 CPU 先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令，在 intel 的 CPU 中，使用的 cmpxchg 指令，就是说 CAS 是靠硬件实现的，从而在硬件层面提升效率。
简述过程是这样：
假设包含 3 个参数内存位置(V)、预期原值(A)和新值(B)。V 表示要更新变量的值，E 表示预期值，N 表示新值。仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程在做更新，则当前线程什么都不做，最后 CAS 返回当前 V 的真实值。CAS 操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对于当前线程的干扰。
Go面试题

ㅤ永久会员",
Go Runtime面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. Goroutine 定义
1. Goroutine 定义
2. GMP 指的是什么
2. GMP 指的是什么
3. 1.0 之前 GM 调度模型
3. 1.0 之前 GM 调度模型
4. GMP 调度流程
4. GMP 调度流程
5. GMP 中 work stealing 机制
5. GMP 中 work stealing 机制
6. GMP 中 hand off 机制
6. GMP 中 hand off 机制
7. 协作式的抢占式调度
7. 协作式的抢占式调度
8. 基于信号的抢占式调度
8. 基于信号的抢占式调度
9. GMP 调度过程中存在哪些阻塞
9. GMP 调度过程中存在哪些阻塞
10. sysmon 有什么作用
10. sysmon 有什么作用
11. 三色标记原理
11. 三色标记原理
12. 插入写屏障
12. 插入写屏障
13. 删除写屏障
13. 删除写屏障
14. 写屏障
14. 写屏障
15. 混合写屏障
15. 混合写屏障
16. GC 触发时机
16. GC 触发时机
17. Go 语言中 GC 的流程是什么
17. Go 语言中 GC 的流程是什么
18. GC 如何调优
18. GC 如何调优
Go面试题

ㅤ永久会员",
Goroutine 定义,"Goroutine 是一个与其他 goroutines 并行运行在同一地址空间的 Go 函数或方法。一个运行的程序由一个或更多个 goroutine 组成。它与线程、协程、进程等不同。它是一个 goroutine” —— Rob Pike Goroutines 在同一个用户地址空间里并行独立执行 functions，channels 则用于 goroutines 间的通信和同步访问控制。
Go面试题

ㅤ永久会员",
GMP 指的是什么,"G（Goroutine）：我们所说的协程，为用户级的轻量级线程，每个 Goroutine 对象中的 sched 保存着其上下文信息.
M（Machine）：对内核级线程的封装，数量对应真实的 CPU 数（真正干活的对象）.
P（Processor）：即为 G 和 M 的调度对象，用来调度 G 和 M 之间的关联关系，其数量可通过 GOMAXPROCS()来设置，默认为核心数。
Go面试题

ㅤ永久会员",
1.0 之前 GM 调度模型,"调度器把 G 都分配到 M 上，不同的 G 在不同的 M 并发运行时，都需要向系统申请资源，比如堆栈内存等，因为资源是全局的，就会因为资源竞争照成很多性能损耗。为了解决这一的问题 go 从 1.1 版本引入，在运行时系统的时候加入 p 对象，让 P 去管理这个 G 对象，M 想要运行 G，必须绑定 P，才能运行 P 所管理 的 G。
单一全局互斥锁(Sched.Lock)和集中状态存储
Goroutine 传递问题（M 经常在 M 之间传递”可运行”的 goroutine）
每个 M 做内存缓存，导致内存占用过高，数据局部性较差
Go面试题

ㅤ永久会员",
GMP 调度流程,"⚫ 每个 P 有个局部队列，局部队列保存待执行的 goroutine(流程 2)，当 M 绑 定的 P 的的局部队列已经满了之后就会把 goroutine 放到全局队列(流程 2- 1)
⚫ 每个 P 和一个 M 绑定，M 是真正的执行 P 中 goroutine 的实体(流程 3)，M 从绑定的 P 中的局部队列获取 G 来执行
⚫ 当 M 绑定的 P 的局部队列为空时，M 会从全局队列获取到本地队列来执行G(流程 3.1)，当从全局队列中没有获取到可执行的 G 时候，M 会从其他 P 的局部队列中偷取 G 来执行(流程 3.2)，这种从其他 P 偷的方式称为 work  stealing
⚫ 当 G 因系统调用(syscall)阻塞时会阻塞 M，此时 P 会和 M 解绑即 hand  off，并寻找新的 idle 的 M，若没有 idle 的 M 就会新建一个 M(流程 5.1)。
⚫ 当 G 因 channel 或者 network I/O 阻塞时，不会阻塞 M，M 会寻找其他 runnable 的 G；当阻塞的 G 恢复后会重新进入 runnable 进入 P 队列等待执 行(流程 5.3)
Go面试题

ㅤ永久会员",
GMP 中 work stealing 机制,"存到 P 本地队列或者是全局队列。P 此时去唤醒一个 M。P 继续执行它的执行序。M 寻找是否有空闲的 P，如果有则将该 G 对象移动到它本身。接下来 M 执行一个调度循环(调用 G 对象->执行->清理线程→继续找新的 Goroutine 执行)。
Go面试题

ㅤ永久会员",
GMP 中 hand off 机制,"当本线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M’执行。当发生上线文切换时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。Go 调度器 M 的栈保存在 G 对象上，只需要将 M 所需要的寄存器(SP、PC 等)保存到 G 对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以做上下文切换了，在中断之前把现场保存起来。如果此时 G 任务还没有执行完，M 可以将任务重新丢到 P 的任务队列，等待下 一次被调度执行。当再次被调度执行时，M 通过访问 G 的 vdsoSP、vdsoPC 寄存器进行现场恢复(从上次中断位置继续执行)。
Go面试题

ㅤ永久会员",
协作式的抢占式调度,"在 1.14 版本之前，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度，存在问题
⚫ 某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿
⚫ 垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作。
Go面试题

ㅤ永久会员",
基于信号的抢占式调度,"在任何情况下，Go 运行时并行执行（注意，不是并发）的 goroutines 数量是小于等于 P 的数量的。为了提高系统的性能，P 的数量肯定不是越小越好，所以官方默认值就是 CPU 的核心数，设置的过小的话，如果一个持有 P 的 M， 由于 P 当前执行的 G 调用了 syscall 而导致 M 被阻塞，那么此时关键点：GO 的调度器是迟钝的，它很可能什么都没做，直到 M 阻塞了相当长时间以后，才会发现有一个 P/M 被 syscall 阻塞了。然后，才会用空闲的 M 来强这个 P。通过 sysmon 监控实现的抢占式调度，最快在 20us，最慢在 10-20ms 才 会发现有一个 M 持有 P 并阻塞了。操作系统在 1ms 内可以完成很多次线程调度（一般情况 1ms 可以完成几十次线程调度），Go 发起 IO/syscall 的时候执行该 G 的 M 会阻塞然后被 OS 调度走，P 什么也不干，sysmon 最慢要 10-20ms才能发现这个阻塞，说不定那时候阻塞已经结束了，宝贵的 P 资源就这么被阻塞的 M 浪费了。
Go面试题

ㅤ永久会员",
GMP 调度过程中存在哪些阻塞,"⚫ I/O，select
⚫ block on syscall
⚫ channel
⚫ 等待锁
⚫ runtime.Gosched()
Go面试题

ㅤ永久会员",
sysmon 有什么作用,"sysmon 也叫监控线程，变动的周期性检查，好处
⚫ 释放闲置超过 5 分钟的 span 物理内存；
⚫ 如果超过 2 分钟没有垃圾回收，强制执行；
⚫ 将长时间未处理的 netpoll 添加到全局队列；
⚫ 向长时间运行的 G 任务发出抢占调度(超过 10ms 的 g，会进行 retake)；
⚫ 收回因 syscall 长时间阻塞的 P；
Go面试题

ㅤ永久会员",
三色标记原理,"我们首先看一张图，大概就会对 三色标记法有一个大致的了解：

原理：
首先把所有的对象都放到白色的集合中
⚫ 从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中
⚫ 遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中
⚫ 循环步骤 3，知道灰色集合中没有对象
⚫ 步骤 4 结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收
Go面试题

ㅤ永久会员",
插入写屏障,"golang 的回收没有混合屏障之前，一直是插入写屏障，由于栈赋值没有 hook  的原因，所以栈中没有启用写屏障，所以有 STW。golang 的解决方法是：只是需要在结束时启动 STW 来重新扫描栈。这个自然就会导致整个进程的赋值器卡顿，所以后面 golang 是引用混合写屏障解决这个问题。混合写屏障之后，就没有 STW。
Go面试题

ㅤ永久会员",
删除写屏障,"goalng 没有这一步，golang 的内存写屏障是由插入写屏障到混合写屏障过渡的。简单介绍一下，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。
Go面试题

ㅤ永久会员",
写屏障,"Go 在进行三色标记的时候并没有 STW，也就是说，此时的对象还是可以进行修 改。 那么我们考虑一下，下面的情况。

我们在进行三色标记中扫描灰色集合中，扫描到了对象 A，并标记了对象 A 的所有引用，这时候，开始扫描对象 D 的引用，而此时，另一个 goroutine 修改 了 D->E 的引用，变成了如下图所示

这样会不会导致 E 对象就扫描不到了，而被误认为为白色对象，也就是垃圾 写屏障就是为了解决这样的问题，引入写屏障后，在上述步骤后，E 会被认为是存活的，即使后面 E 被 A 对象抛弃，E 会被在下一轮的 GC 中进行回收，这一 轮GC 中是不会对对象 E 进行回收的。
Go面试题

ㅤ永久会员",
混合写屏障,"⚫ 混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可；
⚫ 混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC 期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；
⚫ 混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是 GC 过程全程无 STW；
⚫ 混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作的哈（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）。
Go面试题

ㅤ永久会员",
GC 触发时机,"主动触发：调用 runtime.GC
被动触发： 使用系统监控，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。
使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC  是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例.  由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍,  当 Go 新创建的对象所占用的内存大小，除以上次 GC 结束后保留下来的对象占用内存大小。
Go面试题

ㅤ永久会员",
Go 语言中 GC 的流程是什么,"当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段：
阶段说明赋值器状态 GCMark 标记准备阶段，为并发标记做准备工作，启动写屏障 STWGCMark 扫描标记阶段，与赋值器并发执行，写屏障开启并发
GCMarkTermination 标记终止阶段，保证一个周期内标记任务完成，停止写屏障 STWGCoff 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭并发
GCoff 内存归还阶段，将过多的内存归还给操作系统，写屏障关闭并发
Go面试题

ㅤ永久会员",
GC 如何调优,"通过 go tool pprof 和 go tool trace 等工具
⚫ 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。
⚫ 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。
⚫ 需要时，增大 GOGC 的值，降低 GC 的运行频率。
Go面试题

ㅤ永久会员",
HTML 基础面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. src和href的区别
1. src和href的区别
2. 对HTML语义化的理解
2. 对HTML语义化的理解
3. DOCTYPE(文档类型) 的作用
3. DOCTYPE(文档类型) 的作用
4. script标签中defer和async的区别
4. script标签中defer和async的区别
5. 常用的meta标签有哪些
5. 常用的meta标签有哪些
6. img的srcset属性的作用
6. img的srcset属性的作用
7. 行内元素有哪些 块级元素有哪些 空(void)元素有哪些
7. 行内元素有哪些 块级元素有哪些 空(void)元素有哪些
8. 说一下 web worker
8. 说一下 web worker
9. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载
9. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载
10. iframe 有那些优点和缺点
10. iframe 有那些优点和缺点
11. Canvas和SVG的区别
11. Canvas和SVG的区别
12. 文档声明（Doctype）和!Doctype html有何作用 严格模式与混杂模式如何区分它们有何意义
12. 文档声明（Doctype）和!Doctype html有何作用 严格模式与混杂模式如何区分它们有何意义
13. 浏览器乱码的原因是什么 如何解决
13. 浏览器乱码的原因是什么 如何解决
14. 渐进增强和优雅降级之间的区别
14. 渐进增强和优雅降级之间的区别
15. 说一下 HTML5 drag API
15. 说一下 HTML5 drag API
16. HTML5有哪些新特性，移除了哪些元素 如何处理HTML5新标签的浏览器兼容问题 如何区分HTML和HTML5
16. HTML5有哪些新特性，移除了哪些元素 如何处理HTML5新标签的浏览器兼容问题 如何区分HTML和HTML5
17. 清楚浮动有哪些方式 比较好的方式是哪一种
17. 清楚浮动有哪些方式 比较好的方式是哪一种
18. 实现布局中间自适应宽度，左右两栏固定宽度
18. 实现布局中间自适应宽度，左右两栏固定宽度
19. 写出几种IE6 BUG的解决方法
19. 写出几种IE6 BUG的解决方法
20. meta viewport 是做什么用的，怎么写
20. meta viewport 是做什么用的，怎么写
21. script标签为什么要放在body标签的底部
21. script标签为什么要放在body标签的底部
22. HTML5元素分类
22. HTML5元素分类
23. SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途
23. SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途
24. 标准模式和混杂模式的区别
24. 标准模式和混杂模式的区别
25. 标准模式和严格模式的区别
25. 标准模式和严格模式的区别
26. Quirks模式是什么 它和Standards模式有什么区别
26. Quirks模式是什么 它和Standards模式有什么区别
27. 你能描述一下渐进增强和优雅降级之间的不同吗
27. 你能描述一下渐进增强和优雅降级之间的不同吗
28. 简述一下src与href的区别
28. 简述一下src与href的区别
29. 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验
29. 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验
30. 谈谈以前端角度出发做好SEO需要考虑什么
30. 谈谈以前端角度出发做好SEO需要考虑什么
31. 清除浮动的几种方法
31. 清除浮动的几种方法
32. 写HTML代码时应注意什么
32. 写HTML代码时应注意什么
33. HTML5的form如何关闭自动完成功能？
33. HTML5的form如何关闭自动完成功能？
34. 如何实现浏览器内多个标签页之间的通信
34. 如何实现浏览器内多个标签页之间的通信
35. XML和JSON的区别
35. XML和JSON的区别
36. 如何进行网站性能优化
36. 如何进行网站性能优化
37. HTML和XHTML的区别是什么
37. HTML和XHTML的区别是什么
38. 如果网页内容需要支持多语言，你会怎么做
38. 如果网页内容需要支持多语言，你会怎么做
39. 如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些
39. 如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些
40. 如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗
40. 如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗
41. 请解释下什么是语义化的HTML
41. 请解释下什么是语义化的HTML
42. 对于 WEB 标准以及 W3C 的理解与认识问题
42. 对于 WEB 标准以及 W3C 的理解与认识问题
43. 前端页面有哪三层构成，分别是什么 作用是什么
43. 前端页面有哪三层构成，分别是什么 作用是什么
44. 页面可见性（Page Visibility）API 可以有哪些用途
44. 页面可见性（Page Visibility）API 可以有哪些用途
45. Quirks(怪癖）模式是什么 它和 Standards（标准）模式有什么区别
45. Quirks(怪癖）模式是什么 它和 Standards（标准）模式有什么区别
46. div+css 的布局较 table 布局有什么优点
46. div+css 的布局较 table 布局有什么优点
47. html 常见兼容性问题
47. html 常见兼容性问题
48. 如何在页面上实现一个圆形的可点击区域
48. 如何在页面上实现一个圆形的可点击区域
49. HTML 全局属性(global attribute)有哪些
49. HTML 全局属性(global attribute)有哪些
50. meta viewport 原理是什么
50. meta viewport 原理是什么
51. Viewport 属性值
51. Viewport 属性值
52. 页面导入样式时，使用link和@import有什么区别
52. 页面导入样式时，使用link和@import有什么区别
53. label的作用是什么 是怎么用的
53. label的作用是什么 是怎么用的
54. js放在html的不同位置有什么区别吗
54. js放在html的不同位置有什么区别吗
55. 移动html5开发流行的框架有哪些
55. 移动html5开发流行的框架有哪些
56. HTML5 中如何嵌入视频
56. HTML5 中如何嵌入视频
57. Typeof的作用
57. Typeof的作用
HTML面试题

ㅤ普通",
src和href的区别,"src和href都是用来引用外部的资源，它们的区别如下：
src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。
href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并行下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。
HTML面试题

ㅤ普通",
对HTML语义化的理解,"语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。
语义化的优点如下：
对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；
对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。
HTML面试题

ㅤ普通",
DOCTYPE(文档类型) 的作用,"DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML文档的第一行。浏览器渲染页面的两种模式（可通过document.compatMode获
取，比如，语雀官网的文档类型是CSS1Compat）：
CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。
BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。
HTML面试题

ㅤ普通",
script标签中defer和async的区别,"如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。
下图可以直观的看出三者之间的区别:

其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。
defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，其区别如下：
脚本是否并行执行：async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执
行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。
HTML面试题

ㅤ普通",
常用的meta标签有哪些,"meta 标签由 name 和 content 属性定义，用来描述网页文档的属性，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些name作为大家使用的共识，开发者还可以自定义name。
常用的meta标签： （1）charset，用来描述HTML文档的编码类型：
（2） keywords，页面关键词：
（3）description，页面描述：
（4）refresh，页面重定向和刷新：
（5）viewport，适配移动端，可以控制视口的大小和比例：
其中，content 参数有以下几种：
（6）搜索引擎索引方式：
其中，content 参数有以下几种：
HTML面试题

ㅤ普通",
img的srcset属性的作用,"响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：
使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。
按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：
其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。
sies语法如下：
sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。
HTML面试题

ㅤ普通",
行内元素有哪些 块级元素有哪些 空(void)元素有哪些,"块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：
常见的有：<br>、<hr>、<img>、、、“；
鲜见的有：<area>、、`<col>`、、、、、、、`<track>`、。
HTML面试题

ㅤ普通",
说一下 web worker,"在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。
如何创建 web worker：
HTML面试题

ㅤ普通",
浏览器是如何对 HTML5 的离线储存资源进行管理和加载,"在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。
离线的情况下，浏览器会直接使用离线存储的资源。
HTML面试题

ㅤ普通",
iframe 有那些优点和缺点,"iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。
优点：
缺点：
HTML面试题

ㅤ普通",
Canvas和SVG的区别,"（1）SVG： SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
其特点如下：
（2）Canvas： Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。
其特点如下：
注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。
HTML面试题

ㅤ普通",
文档声明（Doctype）和`!Doctype html`有何作用 严格模式与混杂模式如何区分它们有何意义,"文档声明的作用： 文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。
“ 的作用就是让浏览器进入标准模式，使用最新的 HTML5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。
严格模式与混杂模式的区分：
混杂模式： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；
区分：网页中的DTD，直接影响到使用的是严格模式还是浏览模式，可以说DTD的使用与这两种方式的区别息息相关。
包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）；
DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现（DTD不存在或者格式不正确——混杂模式）；
HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(HTML5 没有严格和混杂之分)。
总之，严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。
HTML面试题

ㅤ普通",
浏览器乱码的原因是什么 如何解决,"产生乱码的原因：
html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码；
浏览器不能自动检测网页编码，造成网页乱码。
解决办法：
使用软件编辑HTML网页内容；
如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码；
如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编
码的菜单进行转换。
HTML面试题

ㅤ普通",
渐进增强和优雅降级之间的区别,"（1）渐进增强（progressive enhancement）：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。 （2）优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。
两者区别：
降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。
“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。
“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。
HTML面试题

ㅤ普通",
说一下 HTML5 drag API,"dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。
darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。
dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。
dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。
dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。
drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。
dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。
HTML面试题

ㅤ普通",
HTML5有哪些新特性，移除了哪些元素 如何处理HTML5新标签的浏览器兼容问题 如何区分HTML和HTML5,"HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加。
绘画canvas
用于媒介回放的video和audio元素
本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失；
sessionStorage的数据在浏览器关闭后自动删除
语意化更好的内容元素，比如article,footer,header,nav,section
表单控件：calendar,date,time,email,url,search
新的技术webworker,websocktGeolocation
移除的元素
纯表现的元素：basefont,big,center,font,s,strike,tt,u;
对可用性产生负面影响的元素：frame,frameset,noframes;
支持HTML5新标签：
IE8/IE7/IE6支持通过document,createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。
HTML面试题

ㅤ普通",
清楚浮动有哪些方式 比较好的方式是哪一种,"比较好的是第3种，好多网站都这样用
HTML面试题

ㅤ普通",
实现布局中间自适应宽度，左右两栏固定宽度,"HTML面试题

ㅤ普通",
写出几种IE6 BUG的解决方法,"1、双边距BUG float引起的 使用display
2、3像素问题使用float引用的使用display:inline -3px;
3、超链接hover后点击失效，使用正确的书写顺序 link visited hover active
4、le z-index问题给父级添加position:relative
5、png 透明使用js代码改
6、min-height最小高度 ！important解决
7、select 在ie6下遮盖 使用iframe嵌套
8、为什么没有办法定义1px左右的宽度器（IE6默认的行高造成的，使用over:hidden,zoom:0.08,line-height:1px）
HTML面试题

ㅤ普通",
meta viewport 是做什么用的，怎么写,"Step 1：使用目的
是为了在移动端不让用户缩放页面使用的
Step 2：怎么写
Step 3：解释每个单词的含义
with=device-width   将布局视窗（layout viewport）的宽度设置为设备屏幕分辨率的宽度
initial-scale=1 页面初始缩放比例为屏幕分辨率的宽度
maximum-scale=1 指定用户能够放大的最大比例
minimum-scale=1 指定用户能够缩小的最大比例
HTML面试题

ㅤ普通",
script标签为什么要放在body标签的底部,"因为浏览器在渲染html的时候，从上到下依次执行，遇到js文件就会停止当前页面的渲染，转而去下载js文件，如果将script标签放在头部，如果文件又很大的情况下，首屏时间就会延长，影响用户体验。
解决方法：
defer\async的区别 首先都是让js文件能够异步下载，不阻塞页面的渲染 区别就是defer必须等待整个文档渲染完成后才执行 而async在下载完成后，会暂停html的解析，转去执行js
一图胜千言：

也就是说 下载的处理二者是相同的，主要是执行的时间不同，async执行的时候还是要阻塞html的解析，defer就是安排到最后才执行。 另外如果两个属性同时设置，以async为准。
HTML面试题

ㅤ普通",
HTML5元素分类,"1.结构性元素
header：页面主题上的头部，注意区别于head元素；
footer：页面的底部（页脚）；
nav：是专门用于菜单导航、链接导航的元素，是navigator的缩写；
article：用于表示一篇文章的主题部分，一般为文字集中显示的区域；
2.级块性元素
figure：是对多个元素进行组合并展示的元素，通常与figcaption联合使用；
code：表示一段代码块；
dialog：用于表达人与人之间的对话，该元素还包括dt和dd这两个组合元素，他们常常同时使用。dt用于表示说话者，而dd用来表示说话者的内容。
3.行内语义性元素
time：表示时间值；
progress：用来表示进度条，可通过对其max、min、step等属性进行控制，完成对进度的表示和监视；
video：视频元素，用于支持和实现视频（含视频流）文件的直接播放，支持缓冲预载和多种视频媒体格式；
audio：音频元素，用于支持和实现音频（音频流）文件的直接播放，支持缓冲预载和多种音频媒体格式；
4.交互性元素
details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与legend交互才会显示出来；
datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新；
menu：主要用于交互菜单；
command：用来处理命令按钮。
HTML面试题

ㅤ普通",
SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途,"Canvas是使用JavaScript程序绘图(动态生成)，SVG是使用XML文档描述来绘图。 从这点来看：SVG更适合用来做动态交互，而且SVG绘图很容易编辑，只需要增加或移除相应的元素就可以了。 同时SVG是基于矢量的，所有它能够很好的处理图形大小的改变。
Canvas是基于位图的图像，它不能够改变大小，只能缩放显示；所以说Canvas更适合用来实现类似于Flash能做的事情(当然现在Canvas与Flash相比还有一些不够完善的地方)。 关于最后一点二者谁更有前途：从上面我们可以知道二者是有不同用途的，作为一个开发者，你应该做的是理解应用程序的具体需求并选择正确的技术来实现它。
HTML面试题

ㅤ普通",
标准模式和混杂模式的区别,"盒模型的处理差异：标准CSS盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而IE6之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的；
行内元素的垂直对齐：很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然CSS的规范要求它们被对齐至盒内文本的基线。标准模式下，基于Gecko的浏览器将会对齐至基线，而在quirks模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。
HTML面试题

ㅤ普通",
标准模式和严格模式的区别,"严格模式主要有以下限制：
变量必须声明后再使用
函数的参数不能有同名属性，否则报错
不能使用with语句
不能对只读属性赋值，否则报错
不能使用前缀0表示八进制数，否则报错
不能删除不可删除的属性，否则报错
不能删除变量delete prop，会报错，只能删除属性delete global[prop]
eval不会在它的外层作用域引入变量
eval和arguments不能被重新赋值
arguments不会自动反映函数参数的变化
不能使用arguments.callee
不能使用arguments.caller
禁止this指向全局对象
不能使用fn.caller和fn.arguments获取函数调用的堆栈
HTML面试题

ㅤ普通",
Quirks模式是什么 它和Standards模式有什么区别,"从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。
在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差，IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？
在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。
区别：总体会有布局、样式解析和脚本执行三个方面的区别。
盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。

设置行内元素的高宽：在Standards模式下，给等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。
设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用margin:0 auto设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。
HTML面试题

ㅤ普通",
你能描述一下渐进增强和优雅降级之间的不同吗,"渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。　
“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨”的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。“渐进增强”观点则认为应关注于内容本身。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持”策略的原因所在。　　
HTML面试题

ㅤ普通",
简述一下src与href的区别,"src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。
src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。
href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加
那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。
HTML面试题

ㅤ普通",
一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验,"图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。
如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。
HTML面试题

ㅤ普通",
谈谈以前端角度出发做好SEO需要考虑什么,"了解搜索引擎如何抓取网页和如何索引网页:你需要知道一些搜引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot 或叫 web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。
Meta标签优化:主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如Author（作者），Category（目录），Language（编码语种）等。
如何选取关键词并在网页中放置关键词:搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。
了解主要的搜索引擎:虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如AOL网页搜索用的是Google的搜索技术，MSN用的是Bing的技术。
主要的互联网目录:Open Directory自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。
按点击付费的搜索引擎:搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有Overture和百度，当然也包括Google的广告项目Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。
搜索引擎登录:网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如Yahoo要299美元），但是好消息是（至少到目前为止）最大的搜索引擎Google目前还是免费，而且它主宰着60％以上的搜索市场。
链接交换和链接广泛度（Link Popularity）:网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。
HTML面试题

ㅤ普通",
清除浮动的几种方法,"(1)给父元素添加高度height，防止父元素无法获取高度的问题（防止父元素高度变为0），只建议高度固定的布局
(2)结尾处加空div标签给 clear:both
(3)父级div定义 伪类 :after 和 zoom
(4) 父级div定义 overflow:hidden或auto
(5)（只做了解,不推荐使用）父级div 也一起浮动
(6)（只做了解,不推荐使用）父级div定义 display:table
HTML面试题

ㅤ普通",
写HTML代码时应注意什么,"尽可能少的使用无语义的标签div和span；
在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；
不要使用纯样式标签，如：b、font、u等，改用css设置。
需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；
使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
表单域要用fieldset标签包起来，并用legend标签说明表单的用途；
每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for来让说明文本和相对应的input关联起来。
HTML面试题

ㅤ普通",
HTML5的form如何关闭自动完成功能？,"HTML的输入框可以拥有自动完成的功能，当你往输入框输入内容的时候，浏览器会从你以前的同名输入框的历史记录中查找出类似的内容并列在输入框下面，这样就不用全部输入进去了，直接选择列表中的项目就可以了。但有时候我们希望关闭输入框的自动完成功能，例如当用户输入内容的时候，我们希望使用AJAX技术从数据库搜索并列举而不是在用户的历史记录中搜索。
关闭输入框的自动完成功能有3种方法：
1、在IE的Internet选项菜单里的内容–自动完成里面设置
2、设置form的autocomplete为”on”或者”off”来开启或者关闭自动完成功能
3、设置输入框的autocomplete为”on”或者”off”来开启或者关闭该输入框的自动完成功能
HTML面试题

ㅤ普通",
如何实现浏览器内多个标签页之间的通信,"一、调用localStorage
在一个标签页里面使用localStorage.setItem(key,value)添加（修改、删除）内容；在另一个标签页里面监听storage事件。通过localstorge.getItem(key)存储的值，实现不同标签页之间的通信。
二、调用cookie+setInterval()
将要传递的信息存储在cookie中，每隔一定时间读取getCookie获取信息，即可随时获取要传递的信息。
HTML面试题

ㅤ普通",
XML和JSON的区别,"(1).数据体积方面。
JSON相对于XML来讲，数据的体积小，传递的速度更快些。
(2).数据交互方面。
JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
(3).数据描述方面。
JSON对数据的描述性比XML较差。
(4).传输速度方面。
JSON的速度要远远快于XML。
HTML面试题

ㅤ普通",
如何进行网站性能优化,"1、减少HTTP请求：合并文件、CSS精灵、inline Image
2、将样式表放到页面顶部
3、不使用CSS表达式
4、使用“不使用@import
5、将脚本放到页面底部
6、将javascript和css从外部引入
7、压缩javascript和css
HTML面试题

ㅤ普通",
HTML和XHTML的区别是什么,"主要的不同：
HTML面试题

ㅤ普通",
如果网页内容需要支持多语言，你会怎么做,"考虑:
具体做法：
静态：就是为每种语言分别准备一套页面文件，要么通过文件后缀名来区分不同语言，要么通过子目录来区分不同语言。
动态：站点内所有页面文件都是动态页面文件（PHP，ASP等）而不是静态页面文件，在需要输出语言文字的地方统一采用语言变量来表示，这些语言变量可以根据用户选择不同的语言赋予不同的值，从而能够实现在不同的语言环境下输出不同的文字
HTML面试题

ㅤ普通",
如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些,"开放网络平台（Open Web Platform）是一些开放的（免版权）技术的集合，这些技术激活了互联网。使用开放网络平台时，每个人都有权实现 Web 上的一个组件，而不用向任何人索取许可和证书。
构建模块，指的应该是开放网络平台这个技术集合中的技术：
HTML
DOM
CSS
SVG
MathML
Web APIs…
EcmaScript / JavaScript
HTTP
URI
Media Accessibility Checklist
HTML面试题

ㅤ普通",
如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗,"首先这是个MIME类型，意思就是告诉浏览器，要用xhtml的格式来解析我发给你的页面；xhtml 语法要求严格，必须有head、body 每个dom 必须要闭合。空标签也必须闭合。例如, , 等。另外要在属性值上使用双引号。一旦遇到错误，立刻停止解析，并显示错误信息。
如果页面使用’application/xhtml+xml’,一些老的浏览器会不兼容。
IE6，7，8不支持，IE6，7，8支持text/html。
HTML面试题

ㅤ普通",
请解释下什么是语义化的HTML,"语义化的好处：
屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页.
PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）.
搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重.
你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记.
便于团队开发和维护
语义化的HTML就是：标题用h1-h6，文字段落用p，列表用ul li
HTML面试题

ㅤ普通",
对于 WEB 标准以及 W3C 的理解与认识问题,"web 标准简单来说可以分为结构、表现和行为。其中结构主要是有 HTML 标签组成。或许通俗点说，在页面 body 里面我们写入的标签都是为了页面的结构。表现即指 css 样式表，通过 css 可以是页面的结构标签更具美感。行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要是有 js 组成。
web 标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。
W3C 对 web 标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点
1.对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对 SEO 很有帮助）
1）标签字母要小写
2）标签要闭合
3）标签不允许随意嵌套
2.对于 css 和 js 来说
1）尽量使用外链 css 样式表和 js 脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。
2）样式尽量少用行间样式表，使结构与表现分离，标签的 id 和 class 等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版
3）不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。
HTML面试题

ㅤ普通",
前端页面有哪三层构成，分别是什么 作用是什么,"分成：结构层、表示层、行为层。
表示层（presentation layer）
由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。
负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM 主宰的领域。
HTML面试题

ㅤ普通",
页面可见性（Page Visibility）API 可以有哪些用途,"页面可见性： 就是对于用户来说，页面是显示还是隐藏, 所谓显示的页面，就是我们正在看的页面；隐藏的页面，就是我们没有看的页面。 因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的，还有一种就是…，(把浏览器最小化，所有的页面就都不可见了)。
API 很简单，document.hidden 就返回一个布尔值，如果是 true, 表示页面可见，false 则表示，页面隐藏。 不同页面之间来回切换，触发 visibilitychange 事件。 还有一个 document.visibilityState, 表示页面所处的状态，取值：visible, hidden 等四个。
我们打开这个页面，然后再打开另一个页面，来回点击这两个页面，当我们看到这个页面时，标题显示 visiable ,当我们看另一个页面时，标题显示 hidden;动画，视频，音频都可以在页面显示时打开，在页面隐藏时关闭
HTML面试题

ㅤ普通",
Quirks(怪癖）模式是什么 它和 Standards（标准）模式有什么区别,"1.以 ie6 为例，如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。
2.区别：总体会有布局、样式解析和脚本执行三个方面的区别。设置一个元素的宽度和高度给<span>等行内元素设置 width 和 height用 margin:0 auto 设置水平居中从 IE6 开始，引入了 Standards 模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。
在 IE6 之前 CSS 还不够成熟，所以 IE5 等之前的浏览器对 CSS 的支持很差， IE6 将对 CSS 提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果 IE6 支持 CSS 则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？
在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6 也是类似这样做的，它将 DTD（文档类型定义）当成了这个“参数”，因为以前的页面大家都不会去写 DTD，所以 IE6 就假定 如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。
区别：
总体会有布局、样式解析和脚本执行三个方面的区别。盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks 模式下，IE 的宽度和高度还包含了 padding 和 border。
设置行内元素的高宽：在 Standards 模式下，给<span>等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。
设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的
用 margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效。
（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）
HTML面试题

ㅤ普通",
div+css 的布局较 table 布局有什么优点,"分离 方便改版 快清晰简洁 seo
1.改版的时候更方便 只要改 css 文件。
2.页面加载速度更快、结构化清晰、页面显示简洁。
3.表现与结构相分离。
4.易于优化（seo）搜索引擎更友好，排名更容易靠前。
HTML面试题

ㅤ普通",
html 常见兼容性问题,"1.双边距 BUG float 引起的，解决办法: 使用 display解决
2.像素问题 使用 float 引起的，解决办法: 使用 dislpay:inline -3px
3.超链接 hover 点击后失效，解决办法: 使用正确的书写顺序 link visited hover active
4.Ie z-index 问题，解决办法: 给父级添加 position:relative
5.Png 透明 ，解决办法: 使用 js 代码
6.Min-height 最小高度 ，解决办法: ！Important 解决
7.select 在 ie6 下遮盖，解决办法: 使用 iframe 嵌套
8.为什么没有办法定义 1px 左右的宽度容器，解决办法: （IE6 默认的行高造成的，使用 over:hidden,zoom:0.08 line-height:1px）
9.IE5-8 不支持 opacity，解决办法：
10.IE6 不支持 PNG 透明背景，解决办法: IE6 下使用 gif 图片
HTML面试题

ㅤ普通",
如何在页面上实现一个圆形的可点击区域,"一.border-radius (css3)
对于圆形，最直接的方法想到的就是 css3 的圆角属性，这个属性可以将 html 元素的形状设置为圆形，这之后你想对该圆形区域设置什么事件就设置什么事件(当然包括点击)。（这里就不做具体的 test 了）
二.通过事件坐标来实现（js）
也就是通过 js 来进行一个区域判断，进而简介地的形成可点区域，以下给出主要的 js 测试代码：
三.通过 map 加 area
HTML面试题

ㅤ普通",
HTML 全局属性(global attribute)有哪些,"accesskey:设置快捷键，提供快速访问元素如[aaa在 windows 下的 firefox 中按 alt + shift + a 可激活元素
class:为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素
contenteditable: 指定元素内容是否可编辑
contextmenu: 自定义鼠标右键弹出菜单内容
data-*: 为元素增加自定义属性
dir: 设置元素文本方向
draggable: 设置元素是否可拖拽
dropzone: 设置元素拖放类型： copy, move, link
hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果
id: 元素 id，文档内唯一
lang: 元素内容的的语言
spellcheck: 是否启动拼写和语法检查
style: 行内 css 样式
tabindex: 设置元素可以获得焦点，通过 tab 可以导航
title: 元素相关的建议信息
translate: 元素和子孙节点内容是否需要本地化
HTML面试题

ㅤ普通",
meta viewport 原理是什么,"meta viewport 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户进行手动缩放
viewport的原理：移动端浏览器通常都会在一个比移动端屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是 viewport; 目的是正常展示没有做移动端适配的网页，让他们完整的展示给用户；
Viewport ：字面意思为视图窗口，在移动 web 开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动 web 站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。
在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。
举个例子：如果我们的屏幕是 320 像素 * 480 像素的大小（iPhone4），假设在浏览器中，320 像素的屏幕宽度能够展示 980 像素宽度的内容。那么 320 像素的宽度就是可见视口的宽度，而能够显示的 980 像素的宽度就是视窗视口的宽度。
为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本 320 像素的屏幕宽度能够容下 980 像素甚至更宽的内容（将网页等比例缩小）。
HTML面试题

ㅤ普通",
Viewport 属性值,"width 设置 layout viewport 的宽度，为一个正整数，或字符串”width-device”
initial-scale 设置页面的初始缩放值，为一个数字，可以带小数
minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数
maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数
height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用
user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。
HTML面试题

ㅤ普通",
页面导入样式时，使用link和@import有什么区别,"相同的地方，都是外部引用CSS方式，区别：
link是xhtml标签，除了加载css外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS
link引用CSS时候，页面载入时同时加载；@import需要在页面完全加载以后加载，而且@import被引用的CSS会等到引用它的CSS文件被加载完才加载
link是xhtml标签，无兼容问题；@import是在css2.1提出来的，低版本的浏览器不支持
link支持使用javascript控制去改变样式，而@import不支持
link方式的样式的权重高于@import的权重
import在html使用时候需要“标签
HTML面试题

ㅤ普通",
label的作用是什么 是怎么用的,"label标签用来定义表单控件间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。label 中有两个属性是非常有用的, FOR和ACCESSKEY。
FOR属性功能：表示label标签要绑定的HTML元素，你点击这个标签的时候，所绑定的元素将获取焦点。例如，
ACCESSKEY属性功能：表示访问label标签所绑定的元素的热键，当您按下热键，所绑定的元素将获取焦点。例如，
HTML面试题

ㅤ普通",
js放在html的不同位置有什么区别吗,"如果使用window.函数，将js代码放在其中，则放在哪里都是一样的，因为都是在body加载完再执行的，如果不使用window.函数,放在head中的话，代码不会被执行，这是因为html执行顺序，确切的说是js的执行顺序，HTML从上运行到 的时候进入test.js文件。前面的不会运行，也就是被function包起来的不会被运行，这个时候就执行最后一句。去页面中取元素。但是这个时候，HTML页面并没有加载完。所以找不到元素，就会报错。
HTML面试题

ㅤ普通",
移动html5开发流行的框架有哪些,"1、jQueryMobile，jQueryMobile是jQuery在手机上和平板设备上的版本。jQueryMobile不仅会给主流移动平台带来jQuery核心库，而且会发布一个完整统一的jQuery移动UI框架。支持全球主流的移动平台。jQueryMobile开发团队说：能开发这个项目，非常兴奋。移动web太需要一个跨浏览器的框架，让开发人员开发出真正的移动web网站。
2、jQTouch，jQTouch是一个jQuery的插件，主要用于手机上的Webkit浏览器上实现一些包括动画、列表导航、默认应用样式等各种常见UI效果的Java库。支持包括iPhone、Android等手机。
HTML面试题

ㅤ普通",
HTML5 中如何嵌入视频,"和音频类似，HTML5 支持 MP4、WebM 和 Ogg 式的视频，下面是简单示例：
HTML面试题

ㅤ普通",
Typeof的作用,"一、对于数字类型的操作数而言， typeof 返回的值是 number。
比如说：typeof(1)，返回的值就是number。上面是举的常规数字，对于非常规的数字类型而言，其结果返回
的也是number。比如typeof(NaN)，NaN在JavaScript中代表是特殊非数字值，虽然它本身是一个数字类型。在JavaScript中，特殊的数字类型还有几种：Infinity 表示无穷大特殊值
二、对于字符串类型， typeof 返回的值是 string。比如typeof(“123”)返回的值是string。
三、对于布尔类型， typeof 返回的值是 boolean 。比如typeof(true)返回的值是boolean。
四、对于对象、数组、null 返回的值是 object 。比如typeof(window)，typeof(document)，typeof(null)返回的值都是object。
五、 对于函数类型，返回的值是 function。比如：typeof(eval)，typeof(Date)返回的值都是function。
六、如 果运算数是没有定义的（比如说不存在的变量、函数或者undefined），将返回undefined。比如：typeof(sss)、typeof(undefined)都返回undefined
HTML面试题

ㅤ普通",
display:none与visibility:hidden的区别,"这两个属性都是让元素隐藏，不可见。两者区别如下：
（1）在渲染树中
（2）是否是继承属性
（3）修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；
（4）如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。
HTML面试题

ㅤ普通",
JavaScript基础面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
是帅地。
1. JavaScript有哪些数据类型，它们的区别
1. JavaScript有哪些数据类型，它们的区别
2. 数据类型检测的方式有哪些
2. 数据类型检测的方式有哪些
3. 判断数组的方式有哪些
3. 判断数组的方式有哪些
4. null和undefined区别
4. null和undefined区别
5. typeof null 的结果是什么，为什么
5. typeof null 的结果是什么，为什么
6. intanceof 操作符的实现原理及实现
6. intanceof 操作符的实现原理及实现
7. 为什么0.1+0.2 !  0.3，如何让其相等
7. 为什么0.1+0.2 !  0.3，如何让其相等
8. 如何获取安全的 undefined 值
8. 如何获取安全的 undefined 值
9. typeof NaN 的结果是什么
9. typeof NaN 的结果是什么
10. isNaN 和 Number.isNaN 函数的区别
10. isNaN 和 Number.isNaN 函数的区别
11.  操作符的强制类型转换规则
11.  操作符的强制类型转换规则
12. 其他值到字符串的转换规则
12. 其他值到字符串的转换规则
13. 其他值到数字值的转换规则
13. 其他值到数字值的转换规则
14. 其他值到布尔类型的值的转换规则
14. 其他值到布尔类型的值的转换规则
15. || 和 && 操作符的返回值
15. || 和 && 操作符的返回值
16. Object.is() 与比较操作符 ===、==的区别
16. Object.is() 与比较操作符 ===、==的区别
17. 什么是 JavaScript 中的包装类型
17. 什么是 JavaScript 中的包装类型
18. JavaScript 中如何进行隐式类型转换
18. JavaScript 中如何进行隐式类型转换
19. + 操作符什么时候用于字符串的拼接
19. + 操作符什么时候用于字符串的拼接
20. 为什么会有BigInt的提案
20. 为什么会有BigInt的提案
21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别
21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别
22. let、const、var的区别
22. let、const、var的区别
23. const对象的属性可以修改吗
23. const对象的属性可以修改吗
24. 如果new一个箭头函数的会怎么样
24. 如果new一个箭头函数的会怎么样
25. 箭头函数与普通函数的区别
25. 箭头函数与普通函数的区别
26. 箭头函数的this指向哪里
26. 箭头函数的this指向哪里
27. 扩展运算符的作用及使用场景
27. 扩展运算符的作用及使用场景
28. Proxy 可以实现什么功能
28. Proxy 可以实现什么功能
29. 对对象与数组的解构的理解
29. 对对象与数组的解构的理解
30. 对 rest 参数的理解
30. 对 rest 参数的理解
31. ES6中模板语法与字符串处理
31. ES6中模板语法与字符串处理
32. new操作符的实现原理
32. new操作符的实现原理
33. map和Object的区别
33. map和Object的区别
34. map和weakMap的区别
34. map和weakMap的区别
35. JavaScript有哪些内置对象
35. JavaScript有哪些内置对象
36. 常用的正则表达式有哪些
36. 常用的正则表达式有哪些
37. 对JSON的理解
37. 对JSON的理解
38. JavaScript脚本延迟加载的方式有哪些
38. JavaScript脚本延迟加载的方式有哪些
39. JavaScript 类数组对象的定义
39. JavaScript 类数组对象的定义
40. 数组有哪些原生方法
40. 数组有哪些原生方法
41. Unicode、UTF-8、UTF-16、UTF-32的区别
41. Unicode、UTF-8、UTF-16、UTF-32的区别
42. 常见的位运算符有哪些 其计算规则是什么
42. 常见的位运算符有哪些 其计算规则是什么
43. 为什么函数的 arguments 参数是类数组而不是数组 如何遍历类数组
43. 为什么函数的 arguments 参数是类数组而不是数组 如何遍历类数组
44. 什么是 DOM 和 BOM
44. 什么是 DOM 和 BOM
45. 对类数组对象的理解，如何转化为数组
45. 对类数组对象的理解，如何转化为数组
46. escape、encodeURI、encodeURIComponent 的区别
46. escape、encodeURI、encodeURIComponent 的区别
47. 对AJAX的理解，实现一个AJAX请求
47. 对AJAX的理解，实现一个AJAX请求
48. JavaScript为什么要进行变量提升，它导致了什么问题
48. JavaScript为什么要进行变量提升，它导致了什么问题
49. 什么是尾调用，使用尾调用有什么好处
49. 什么是尾调用，使用尾调用有什么好处
50. ES6模块与CommonJS模块有什么异同
50. ES6模块与CommonJS模块有什么异同
51. 常见的DOM操作有哪些
51. 常见的DOM操作有哪些
52. use strict是什么意思 使用它区别是什么
52. use strict是什么意思 使用它区别是什么
53. 如何判断一个对象是否属于某个类
53. 如何判断一个对象是否属于某个类
54. 强类型语言和弱类型语言的区别
54. 强类型语言和弱类型语言的区别
55. 解释性语言和编译型语言的区别
55. 解释性语言和编译型语言的区别
56. for…in和for…of的区别
56. for…in和for…of的区别
57. 如何使用for…of遍历对象
57. 如何使用for…of遍历对象
58. ajax、axios、fetch的区别
58. ajax、axios、fetch的区别
59. 数组的遍历方法有哪些
59. 数组的遍历方法有哪些
60. forEach和map方法有什么区别
60. forEach和map方法有什么区别
61. 对原型、原型链的理解
61. 对原型、原型链的理解
62. 原型修改、重写
62. 原型修改、重写
63. 原型链指向
63. 原型链指向
64. 如何获得对象非原型链上的属性
64. 如何获得对象非原型链上的属性
65. 对闭包的理解
65. 对闭包的理解
66. 对作用域、作用域链的理解
66. 对作用域、作用域链的理解
67. 对this对象的理解
67. 对this对象的理解
68. call() 和 apply() 的区别
68. call() 和 apply() 的区别
69. 实现call、apply 及 bind 函数
69. 实现call、apply 及 bind 函数
70. 异步编程的实现方式
70. 异步编程的实现方式
71. Promise解决了什么问题
71. Promise解决了什么问题
72. Promise.all和Promise.race的区别的使用场景
72. Promise.all和Promise.race的区别的使用场景
73. 对象创建的方式有哪些
73. 对象创建的方式有哪些
74. 对象继承的方式有哪些
74. 对象继承的方式有哪些
75. 列出JS基本和非基本数据类型之间的一些区别
75. 列出JS基本和非基本数据类型之间的一些区别
76. module.exports 和 exports 之间有什么区别
76. module.exports 和 exports 之间有什么区别
77. js 执行机制、事件循环
77. js 执行机制、事件循环
78. promise.all
78. promise.all
79. 介绍一下rAF(requestAnimationFrame)
79. 介绍一下rAF(requestAnimationFrame)
80. javascript 的垃圾回收机制讲一下
80. javascript 的垃圾回收机制讲一下
81. 两种方式实现字符串反转函数
81. 两种方式实现字符串反转函数
82. 事件委托代理
82. 事件委托代理
83. 什么是跨域 跨域请求资源的方法有哪些
83. 什么是跨域 跨域请求资源的方法有哪些
84. 开发过程中遇到的内存泄露情况，如何解决的
84. 开发过程中遇到的内存泄露情况，如何解决的
JavaScrip面试题

ㅤ普通",
JavaScript有哪些数据类型，它们的区别,"JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。
其中 Symbol 和 BigInt 是ES6 中新增的数据类型：
这些数据可以分为原始数据类型和引用数据类型：
两种类型的区别在于存储位置的不同：
堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：
在操作系统中，内存被分为栈区和堆区：
JavaScrip面试题

ㅤ普通",
数据类型检测的方式有哪些,"（1）typeof
其中数组、对象、null都会被判断为object，其他判断都正确。
（2）instanceof
instanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。
可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。
（3） constructor
constructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：
（4）Object.prototype.toString.call()
Object.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型：
同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？
这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。
JavaScrip面试题

ㅤ普通",
判断数组的方式有哪些,"JavaScrip面试题

ㅤ普通",
null和undefined区别,"首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。
undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。
undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。
当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
JavaScrip面试题

ㅤ普通",
typeof null 的结果是什么，为什么,"typeof null 的结果是Object。
在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：
如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。
有两种特殊数据类型：
那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。
JavaScrip面试题

ㅤ普通",
intanceof 操作符的实现原理及实现,"instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
JavaScrip面试题

ㅤ普通",
为什么0.1+0.2 ! == 0.3，如何让其相等,"在开发过程中遇到类似这样的问题：
这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：
toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？
计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？
一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。
根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。
下面看一下双精度数是如何保存的：

对于0.1，它的二进制为：
转为科学计数法（科学计数法的结果就是浮点数）：
可以看出0.1的符号位为0，指数位为-4，小数位为：
那么问题又来了，指数位是负数，该如何保存呢？
IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定双精度数的偏移量为1023。
对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：1111111011.
所以，0.1表示为：
说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？
对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 =0.3
JavaScrip面试题

ㅤ普通",
如何获取安全的 undefined 值,"因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。
JavaScrip面试题

ㅤ普通",
typeof NaN 的结果是什么,"NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。
NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x= = =x 不成立）的值。而 NaN !== NaN 为 true。
JavaScrip面试题

ㅤ普通",
isNaN 和 Number.isNaN 函数的区别,"JavaScrip面试题

ㅤ普通",
== 操作符的强制类型转换规则,"对于 = = 来说，如果对比双方的类型不一样，就会进行类型转换。假如对比 x 和 y 是否相同，就会进行如下判断流程：
其流程图如下：

JavaScrip面试题

ㅤ普通",
其他值到字符串的转换规则,"JavaScrip面试题

ㅤ普通",
其他值到数字值的转换规则,"为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。
如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。
JavaScrip面试题

ㅤ普通",
其他值到布尔类型的值的转换规则,"以下这些是假值： • undefined • null • false • +0、-0 和 NaN • “”
假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。
JavaScrip面试题

ㅤ普通",
|| 和 && 操作符的返回值,"|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。
|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果
JavaScrip面试题

ㅤ普通",
Object.is() 与比较操作符 `===`、`==`的区别,"JavaScrip面试题

ㅤ普通",
什么是 JavaScript 中的包装类型,"在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：
在访问'abc'.length时，JavaScript 将'abc'在后台转换成String('abc')，然后再访问其length属性。
JavaScript也可以使用Object函数显式地将基本类型转换为包装类型：
也可以使用valueOf方法将包装类型倒转成基本类型：
看看如下代码会打印出什么：
答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行。
JavaScrip面试题

ㅤ普通",
`+` 操作符什么时候用于字符串的拼接,"根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。
简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。
那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。
JavaScrip面试题

ㅤ普通",
为什么会有BigInt的提案,"JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。
JavaScrip面试题

ㅤ普通",
object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别,"扩展运算符：
Object.assign():
可以看到，两者都是浅拷贝。
JavaScrip面试题

ㅤ普通",
let、const、var的区别,"（1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：
（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。
（3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。
（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。
（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。
（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。
JavaScrip面试题

ㅤ普通",
const对象的属性可以修改吗,"const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。
但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。
JavaScrip面试题

ㅤ普通",
如果new一个箭头函数的会怎么样,"箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。
new操作符的实现步骤如下：
所以，上面的第二、三步，箭头函数都是没有办法执行的。
JavaScrip面试题

ㅤ普通",
箭头函数与普通函数的区别,"（1）箭头函数比普通函数更加简洁
（2）箭头函数没有自己的this
箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。
（3）箭头函数继承来的this指向永远不会改变
对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。
（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向
（5）箭头函数不能作为构造函数使用
构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。
（6）箭头函数没有自己的arguments
箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。
（7）箭头函数没有prototype
（8）箭头函数不能用作Generator函数，不能使用yeild关键字
JavaScrip面试题

ㅤ普通",
箭头函数的this指向哪里,"箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于自己的this，它所谓的this是捕获其所在上下文的 this 值，作为自己的 this 值，并且由于没有属于自己的this，所以是不会被new调用的，这个所谓的this也不会被改变。
可以用Babel理解⼀下箭头函数:
转化后：
JavaScrip面试题

ㅤ普通",
扩展运算符的作用及使用场景,"（1）对象扩展运算符
对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。
上述方法实际上等价于:
Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。
同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。
利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。
需要注意：扩展运算符对对象实例的拷贝属于浅拷贝。
（2）数组扩展运算符
数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。
下面是数组的扩展运算符的应用：
要记住：扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。
如果想在数组内合并数组，可以这样：
需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
比较常见的应用是可以将某些数据结构转为数组：
用于替换es5中的Array.prototype.slice.call(arguments)写法。
JavaScrip面试题

ㅤ普通",
Proxy 可以实现什么功能,"在 Vue3.0 中通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。
Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。
target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。
下面来通过 Proxy 来实现一个数据响应式：
在上述代码中，通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。
当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。
JavaScrip面试题

ㅤ普通",
对对象与数组的解构的理解,"解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。 1）数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的：
要的数据的：
最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：

数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：
通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：

2）对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：
假如想要解构它的两个自有属性，可以这样：
这样就得到了 name 和 age 两个和 stu 平级的变量：

注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：
有时会遇到一些嵌套程度非常深的对象：
像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：
显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：
但是还有一种更标准的做法，可以用一行代码来解决这个问题：
可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。
JavaScrip面试题

ㅤ普通",
对 rest 参数的理解,"扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：
这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：
这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。
JavaScrip面试题

ㅤ普通",
ES6中模板语法与字符串处理,"ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：
仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：
字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：
基于第一点，可以在模板字符串里无障碍地直接写 html 代码：
基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：
除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：
（1）存在性判定：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf > -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。
（2）自动重复：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：
JavaScrip面试题

ㅤ普通",
new操作符的实现原理,"new操作符的执行过程：
（1）首先创建了一个新的空对象
（2）设置原型，将对象的原型设置为函数的 prototype 对象。
（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。
具体实现：
JavaScrip面试题

ㅤ普通",
map和Object的区别,"JavaScrip面试题

ㅤ普通",
map和weakMap的区别,"（1）Map map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。
实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：
Map数据结构有以下操作方法：
Map结构原生提供是三个遍历器生成函数和一个遍历方法
（2）WeakMap WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的。
该对象也有以下几种方法：
其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。
WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。
而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。
总结：
JavaScrip面试题

ㅤ普通",
JavaScript有哪些内置对象,"全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。
标准内置对象的分类：
（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量
（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等
（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等
（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date
（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp
（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array
（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet
（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等
（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等
（10）控制抽象对象 例如 Promise、Generator 等
（11）反射。例如 Reflect、Proxy
（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等
（13）WebAssembly
（14）其他。例如 arguments
总结： js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。
JavaScrip面试题

ㅤ普通",
常用的正则表达式有哪些,"JavaScrip面试题

ㅤ普通",
对JSON的理解,"JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。
在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。
因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。
在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，
JavaScrip面试题

ㅤ普通",
JavaScript脚本延迟加载的方式有哪些,"延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。
一般有以下几种方式：
JavaScrip面试题

ㅤ普通",
JavaScript 类数组对象的定义,"一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。
常见的类数组转换为数组的方法有这样几种：
（1）通过 call 调用数组的 slice 方法来实现转换
（2）通过 call 调用数组的 splice 方法来实现转换
（3）通过 apply 调用数组的 concat 方法来实现转换
（4）通过 Array.from 方法来实现转换
JavaScrip面试题

ㅤ普通",
数组有哪些原生方法,"JavaScrip面试题

ㅤ普通",
Unicode、UTF-8、UTF-16、UTF-32的区别,"（1）Unicode
在说Unicode之前需要先了解一下ASCII码：ASCII 码（American Standard Code for Information Interchange）称为美国标准信息交换码。
ASCII码可以表示的编码有限，要想表示其他语言的编码，还是要使用Unicode来表示，可以说Unicode是ASCII 的超集。
Unicode全称 Unicode Translation Format，又叫做统一码、万国码、单一码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。
Unicode的实现方式（也就是编码方式）有很多种，常见的是UTF-8、UTF-16、UTF-32和USC-2。
（2）UTF-8
UTF-8是使用最广泛的Unicode编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容ASCII码的128个字符。
注意： UTF-8 是一种编码方式，Unicode是一个字符集合。
UTF-8的编码规则：
来看一下具体的Unicode编号范围与对应的UTF-8二进制格式 ：
那该如何通过具体的Unicode编码，进行具体的UTF-8编码呢？步骤如下：
来看一个实际的例子： “马” 字的Unicode编码是：0x9A6C，整数编号是39532 （1）首选确定了该字符在第三个范围内，它的格式是 1110xxxx 10xxxxxx 10xxxxxx （2）39532对应的二进制数为1001 1010 0110 1100 （3）将二进制数填入X中，结果是：11101001 10101001 10101100
（3）UTF-16
1. 平面的概念
在了解UTF-16之前，先看一下平面的概念： Unicode编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放65536（216）个字符，这称为一个平面，目前总共有17 个平面。
最前面的一个平面称为基本平面，它的码点从0 — 216-1，写成16进制就是U+0000 — U+FFFF，那剩下的16个平面就是辅助平面，码点范围是 U+10000—U+10FFFF。
2. UTF-16 概念：
UTF-16也是Unicode编码集的一种编码形式，把Unicode字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。Unicode字符的码位需要1个或者2个16位长的码元来表示，因此UTF-16也是用变长字节表示的。
3. UTF-16 编码规则：
4. 编码识别
那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？
UTF-16 编码肯定也考虑到了这个问题，在基本平面内，从 U+D800 — U+DFFF 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。
辅助平面共有 220 个字符位，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 — U+DBFF，称为高位（H），后 10 位映射在 U+DC00 — U+DFFF，称为低位（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。
因此，当遇到两个字节时，发现它的码点在 U+D800 —U+DBFF之间，就可以知道，它后面的两个字节的码点应该在 U+DC00 — U+DFFF 之间，这四个字节必须放在一起进行解读。
5. 举例说明
以 “?” 字为例，它的 Unicode 码点为 0x21800，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：
（4） UTF-32
UTF-32 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。
比如“马” 字的Unicode编号是：U+9A6C，整数编号是39532，直接转化为二进制：1001 1010 0110 1100，这就是它的UTF-32编码。
（5）总结
Unicode、UTF-8、UTF-16、UTF-32有什么区别？
JavaScrip面试题

ㅤ普通",
常见的位运算符有哪些 其计算规则是什么,"现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。
常见的位运算有以下几种：
1. 按位与运算符（&）
定义： 参加运算的两个数据按二进制位进行“与”运算。 运算规则：
总结：两位同时为1，结果才为1，否则结果为0。 例如：3&5 即：
因此 3&5 的值为1。 注意：负数按补码形式参加按位与运算。
用途：
（1）判断奇偶
只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((i & 1) == 0)代替if (i % 2 == 0)来判断a是不是偶数。
（2）清零
如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。
2. 按位或运算符（|）
定义： 参加运算的两个对象按二进制位进行“或”运算。
运算规则：
总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：
因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。
3. 异或运算符（^）
定义： 参加运算的两个数据按二进制位进行“异或”运算。
运算规则：
总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：
因此，3^5的值为6。 异或运算的性质:
4. 取反运算符 (~)
定义： 参加运算的一个数据按二进制进行“取反”运算。
运算规则：
总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：
在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就直接取其补码，变为十进制：
因此，~6的值为-7。
5. 左移运算符（<<）
定义： 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a=1010 1110，a = a）**
定义： 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。
7. 原码、补码、反码
上面提到了补码、反码等知识，这里就补充一下。 计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。
（1）原码
原码就是一个数的二进制数。例如：10的原码为0000 1010
（2）反码
例如：-10
（3）补码
例如：-10
JavaScrip面试题

ㅤ普通",
为什么函数的 arguments 参数是类数组而不是数组 如何遍历类数组,"arguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组。
要遍历类数组，有三个方法：
（1）将数组的方法应用到类数组上，这时候就可以使用call和apply方法，如：
（2）使用Array.from方法将类数组转化成数组：‌
（3）使用展开运算符将类数组转化成数组
JavaScrip面试题

ㅤ普通",
什么是 DOM 和 BOM,"JavaScrip面试题

ㅤ普通",
对类数组对象的理解，如何转化为数组,"一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。
常见的类数组转换为数组的方法有这样几种：
JavaScrip面试题

ㅤ普通",
escape、encodeURI、encodeURIComponent 的区别,"JavaScrip面试题

ㅤ普通",
对AJAX的理解，实现一个AJAX请求,"AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。
创建AJAX请求的步骤：
使用Promise封装AJAX：
JavaScrip面试题

ㅤ普通",
JavaScript为什么要进行变量提升，它导致了什么问题,"变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。
造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。
首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。
，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。
那为什么会进行变量提升呢？主要有以下两个原因：
（1）提高性能 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。
在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。
（2）容错性更好
变量提升可以在一定程度上提高JS的容错性，看下面的代码：
如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。
虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。
总结：
变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：
在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。
由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。
JavaScrip面试题

ㅤ普通",
什么是尾调用，使用尾调用有什么好处,"尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。
JavaScrip面试题

ㅤ普通",
ES6模块与CommonJS模块有什么异同,"ES6 Module和CommonJS模块的区别：
ES6 Module和CommonJS模块的共同点：
JavaScrip面试题

ㅤ普通",
常见的DOM操作有哪些,"1）DOM 节点的获取
DOM 节点的获取的API及使用：
2）DOM 节点的创建
创建一个新节点，并把它添加到指定节点的后面。 已知的 HTML 结构如下：
要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：
3）DOM 节点的删除
删除指定的 DOM 节点， 已知的 HTML 结构如下：
需要删除 id 为 title 的元素，做法是：
或者通过子节点数组来完成删除：
4）修改 DOM 元素
修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。
将指定的两个 DOM 元素交换位置， 已知的 HTML 结构如下：
现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：
JavaScrip面试题

ㅤ普通",
use strict是什么意思 使用它区别是什么,"use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：
区别：
JavaScrip面试题

ㅤ普通",
如何判断一个对象是否属于某个类,"JavaScrip面试题

ㅤ普通",
强类型语言和弱类型语言的区别,"两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。
JavaScrip面试题

ㅤ普通",
解释性语言和编译型语言的区别,"（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下
（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：
两者主要区别在于： 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。
JavaScrip面试题

ㅤ普通",
for…in和for…of的区别,"for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下
总结： for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。
JavaScrip面试题

ㅤ普通",
如何使用for…of遍历对象,"for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。
如果需要遍历的对象是类数组对象，用Array.from转成数组即可。
如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。
JavaScrip面试题

ㅤ普通",
ajax、axios、fetch的区别,"（1）AJAX Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：
（2）Fetch fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。
fetch的优点：
fetch的缺点：
（3）Axios Axios 是一种基于Promise封装的HTTP客户端，其特点如下：
JavaScrip面试题

ㅤ普通",
数组的遍历方法有哪些,"JavaScrip面试题

ㅤ普通",
forEach和map方法有什么区别,"这方法都是用来遍历数组的，两者区别如下：
JavaScrip面试题

ㅤ普通",
对原型、原型链的理解,"在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。
当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。
特点： JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。

JavaScrip面试题

ㅤ普通",
原型修改、重写,"可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候p.constructor = = = Object ，而不是p.constructor = = = Person。要想成立，就要用constructor指回来：
JavaScrip面试题

ㅤ普通",
原型链指向,"JavaScrip面试题

ㅤ普通",
如何获得对象非原型链上的属性,"使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：
JavaScrip面试题

ㅤ普通",
对闭包的理解,"闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
闭包有两个常用的用途；
比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。
在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题
首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：
在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。
JavaScrip面试题

ㅤ普通",
对作用域、作用域链的理解,"1）全局作用域和函数作用域
（1）全局作用域
（2）函数作用域
2）块级作用域
作用域链： 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。
作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。
作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。
当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。
JavaScrip面试题

ㅤ普通",
对this对象的理解,"this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。
这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。
JavaScrip面试题

ㅤ普通",
call() 和 apply() 的区别,"它们的作用一模一样，区别仅在于传入参数的形式的不同。
JavaScrip面试题

ㅤ普通",
实现call、apply 及 bind 函数,"（1）call 函数的实现步骤：
（2）apply 函数的实现步骤：
（3）bind 函数的实现步骤：
JavaScrip面试题

ㅤ普通",
异步编程的实现方式,"JavaScript中的异步机制可以分为以下几种：
JavaScrip面试题

ㅤ普通",
Promise解决了什么问题,"在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：
上面的代码有如下缺点：
Promise出现之后，代码变成这样：
这样代码看起了就简洁了很多，解决了地狱回调的问题。
JavaScrip面试题

ㅤ普通",
Promise.all和Promise.race的区别的使用场景,"（1）Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。
Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。
需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。
（2）Promise.race
顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：
JavaScrip面试题

ㅤ普通",
对象创建的方式有哪些,"一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。
但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可
复用的对象创建方式，常见的有以下几种：
（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复
用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代
码，而没有建立起对象和类型间的关系。
（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属
性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对
象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，
所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，
造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么
每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。
（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构
造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复
用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有
办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个
对象，一个实例对引用类型值的改变会影响所有的实例。
（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和
原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型
对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使
用了两种不同的模式，所以对于代码的封装性不够好。
（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性
是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模
式进行了封装。
（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要
是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对
象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。
JavaScrip面试题

ㅤ普通",
对象继承的方式有哪些,"（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被
所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。
（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现
的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且
超类型原型定义的方法子类型也没有办法访问到。
（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数
的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上
面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构
造函数，造成了子类型的原型中多了很多不必要的属性。
（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向
函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类
型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型
链方式相同。
（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然
后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继
承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。
（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必
要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要
的属性。
JavaScrip面试题

ㅤ普通",
列出JS基本和非基本数据类型之间的一些区别,"1.目前JS中有6种基本数据类型: Undefined、Null、Boolean、Number、Symbol 和 String。还有1种复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。Object、Array和Function则属于引用类型。
2.基本数据类型是不可变的，而非基本数据类型是可变的。
3.基本数据类型是不可变的，因为它们一旦创建就无法更改，但非基本数据类型刚可更改，意味着一旦创建了对象，就可以更改它。
4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型并具有相同的值，那么它们是严格相等的。
5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。
JavaScrip面试题

ㅤ普通",
module.exports 和 exports 之间有什么区别,"module和exports是Node.js给每个js文件内置的两个对象。可以通过console.log(module)和console.log(exports)打印出来。如果你在main.js中写入下面两行，然后运行$ node main.js:
从打印咱们可以看出，module.exports和exports一开始都是一个空对象{}，实际上，这两个对象指向同一块内存。这也就是说module.exports和exports是等价的（有个前提：不去改变它们指向的内存地址）。
例如：exports.age = 18和module.export.age = 18，这两种写法是一致的（都相当于给最初的空对象{}添加了一个属性，通过require得到的就是{age: 18}）。
JavaScrip面试题

ㅤ普通",
js 执行机制、事件循环,"JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript 语言的设计者意识到这个问题，将所有任务分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous），在所有同步任务执行完之前，任何的异步任务是不会执行的。
当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：

导图要表达的内容用文字来表述的话：
同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的 Event Loop(事件循环)。
我们不禁要问了，那怎么知道主线程执行栈为空啊？js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。换一张图片也许更好理解主线程的执行过程：

上图用文字表述就是：主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。只要主线程空了，就会去读取”任务队列”，这就是 JavaScript 的运行机制。
说完 JS 主线程的执行机制，下面说说经常被问到的 JS 异步中 宏任务（macrotasks）、微任务（microtasks）执行顺序。JS 异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入 Event Queue，然后再执行微任务，将微任务放入 Event Queue，但是，这两个 Queue 不是一个 Queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的 Queue 拿宏任务的回调函数。如下图：

JavaScrip面试题

ㅤ普通",
promise.all,"Promise.all()方法将多个Promise实例包装成一个Promise对象（p），接受一个数组（p1,p2,p3）作为参数，数组中不一定需要都是Promise对象，但是一定具有Iterator接口，如果不是的话，就会调用Promise.resolve将其转化为Promise对象之后再进行处理。
使用Promise.all()生成的Promise对象（p）的状态是由数组中的Promise对象（p1,p2,p3）决定的。
JavaScrip面试题

ㅤ普通",
介绍一下rAF(requestAnimationFrame),"专门用来做动画，不卡顿，用法和setTimeout一样。对 rAF 的阐述MDN 资料
定时器一直是 js 动画的核心技术，但它们不够精准，因为定时器时间参数是指将执行代码放入 UI 线程队列中等待的时间，如果前面有其他任务队列执行时间过长，则会导致动画延迟，效果不精确等问题。
所以处理动画循环的关键是知道延迟多长时间合适：时间要足够短，才能让动画看起来比较柔滑平顺，避免多余性能损耗；时间要足够长，才能让浏览器准备好变化渲染。这个时候 rAF 就出现了，采用系统时间间隔(大多浏览器刷新频率是 60Hz，相当于 1000ms/60≈16.6ms)，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制。并且 rAF 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成。
JavaScrip面试题

ㅤ普通",
javascript 的垃圾回收机制讲一下,"定义：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。
像 C 这样的编程语言，具有低级内存管理原语，如 malloc()和 free()。开发人员使用这些原语显式地对操作系统的内存进行分配和释放。
而 JavaScript 在创建对象(对象、字符串等)时会为它们分配内存，不再使用对时会“自动”释放内存，这个过程称为垃圾收集。
内存生命周期中的每一个阶段:
分配内存 —  内存是由操作系统分配的，它允许您的程序使用它。在低级语言(例如 C 语言)中，这是一个开发人员需要自己处理的显式执行的操作。然而，在高级语言中，系统会自动为你分配内在。
使用内存 — 这是程序实际使用之前分配的内存，在代码中使用分配的变量时，就会发生读和写操作。
释放内存 — 释放所有不再使用的内存,使之成为自由内存,并可以被重利用。与分配内存操作一样,这一操作在低级语言中也是需要显式地执行。
四种常见的内存泄漏：全局变量，未清除的定时器，闭包，以及 dom 的引用
JavaScrip面试题

ㅤ普通",
两种方式实现字符串反转函数,"JavaScrip面试题

ㅤ普通",
事件委托代理,"在构建应用程序时，有时需要将事件绑定到页面上的按钮、文本或图像，以便在用户与元素交互时执行某些操作。
如果我们以一个简单的待办事项列表为例，面试官可能会告诉你，当用户点击列表中的一个列表项时执行某些操作。他们希望你用 JavaScript 实现这个功能，假设有如下 HTML 代码:
你可能想要做如下操作来将事件绑定到元素:
虽然这在技术上是可行的，但问题是要将事件分别绑定到每个项。这对于目前 4 个元素来说，没什么大问题，但是如果在待办事项列表中添加了 10,000 项(他们可能有很多事情要做)怎么办?然后，函数将创建 10,000 个独立的事件侦听器，并将每个事件监听器绑定到 DOM ，这样代码执行的效率非常低下。
在面试中，最好先问面试官用户可以输入的最大元素数量是多少。例如，如果它不超过 10，那么上面的代码就可以很好地工作。但是如果用户可以输入的条目数量没有限制，那么你应该使用一个更高效的解决方案。
如果你的应用程序最终可能有数百个事件侦听器，那么更有效的解决方案是将一个事件侦听器实际绑定到整个容器，然后在单击它时能够访问每个列表项， 这称为事件委托，它比附加单独的事件处理程序更有效。
下面是事件委托的代码:
JavaScrip面试题

ㅤ普通",
什么是跨域 跨域请求资源的方法有哪些,"1、什么是跨域？
由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况：
2、跨域请求资源的方法：
(1)、porxy代理
定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。
实现方法：通过nginx代理；
注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。
(2)、CORS 【Cross-Origin Resource Sharing】
定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。
使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：
(3)、jsonp
定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。
特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。
实例如下：
缺点：
1、这种方式无法发送post请求（这里）
2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。
JavaScrip面试题

ㅤ普通",
开发过程中遇到的内存泄露情况，如何解决的,"1、定义和用法：
内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。
2、内存泄露的几种情况:
(1)、当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。
实例如下:
解决方法如下：
(2)、由于是函数内定义函数，并且内部函数–事件回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。
实例如下：
解决方法如下：
JavaScrip面试题

ㅤ普通",
JavaSe面试题分类阅读指南(附答案),"大家好，我是帅地。
由于 Java 内容较多，为了方便大家复习，这里采取了分类阅读的方式
 Java基础面试题阅读指南
 Java基础面试题阅读指南
 Java集合面试题阅读指南
 Java集合面试题阅读指南
Java并发面试题阅读指南
Java并发面试题阅读指南
JVM 面试题阅读指南
JVM 面试题阅读指南
同时帅地也上线了配套小程序哦

持续更新～持续更新～持续更新～
记得收藏呀
Java面试题",
谈谈你对 MyBatis 的理解？,"Mybatis是一个半ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 Statement 等繁杂的过程。程序员直接编写原生态 SQL，可以严格控制 SQL 执行性能，灵活度高。
MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。
通过 XML 文件或注解的方式将要执行的各种 Statement 配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 MyBatis 框架执行 SQL并将结果映射为 Java 对象并返回。（从执行 SQL到返回 Result 的过程）。
MyBatis面试题",
MyBaits 的优缺点有哪些？,"优点：
与 JDBC 相比，减少了代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；
很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）；
提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。
缺点：
SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求；
SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。
MyBatis面试题",
MyBatis 与 Hibernate 有哪些不同？,"MyBatis 和 Hibernate不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 SQL 语句；Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用 Hibernate 开发可以节省很多代码，提高效率；
MyBatis 直接编写原生态 SQL，可以严格控制 SQL 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套 SQL 映射文件，工作量大。
MyBatis面试题",
MyBatis 中 #{} 和 ${}的区别是什么？,"#{} 是预编译处理，${} 是字符串替换
MyBatis 在处理 ${}  时，
就是把 ${} 替换成变量的值。
MyBatis面试题",
MyBatis 是如何进行分页的？分页插件的原理是什么？,"MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 SQL 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数
MyBatis面试题",
MyBatis 有几种分页方式？,"数组分页
SQL 分页
拦截器分页
RowBounds 分页
MyBatis面试题",
MyBatis 逻辑分页和物理分页的区别是什么？,"物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。
物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加到应用端来，就算速度上存在优势，然而其它性能上的优点足以弥补这个缺点。
MyBatis面试题",
MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？,"Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在MyBatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke() 方法发现 a.getB() 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 SQL，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName() 方法的调用。这就是延迟加载的基本原理。
MyBatis面试题",
说一下 MyBatis 的一级缓存和二级缓存？,"一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；
二级缓存：与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)，可在它的映射文件中配置  ；
对于缓存数据更新机制，当某一个作用域(一级缓存 Session / 二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。
MyBatis面试题",
Mybatis 有哪些执行器（Executor）？,"Mybatis 有 3 种基本的执行器（Executor）：
SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象；
ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map 内，供下一次使用。简言之，就是重复使用 Statement 对象；
BatchExecutor：执行 update（没有 select，JDBC 批处理不支持select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement对 象都是 addBatch() 完毕后，等待逐一执行 executeBatch() 批处理。与 JDBC 批处理相同。
MyBatis面试题",
MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL的执行原理不？,"MyBatis 动态 SQL 可以让我们在 XML 映射文件内，以标签的形式编写动态 SQL，完成逻辑判断和动态拼接 SQL 的功能；
MyBatis 提供了 9 种动态 SQL 标签：trim、where、set、foreach、if、choose、when、otherwise、bind；
执行原理：使用 OGNL 从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL，以此来完成动态 SQL 的功能。
MyBatis面试题",
MyBatis,"MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。
通过 XML 文件或注解的方式将要执行的各种 Statement 配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 MyBatis 框架执行 SQL并将结果映射为 Java 对象并返回。（从执行 SQL到返回 Result 的过程）。
优点：
与 JDBC 相比，减少了代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；
很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）；
提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。
缺点：
SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。
MyBatis 和 Hibernate不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 SQL 语句；Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用 Hibernate 开发可以节省很多代码，提高效率；
MyBatis 直接编写原生态 SQL，可以严格控制 SQL 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套 SQL 映射文件，工作量大。
#{} 是预编译处理，${} 是字符串替换
MyBatis 在处理 {} 时，就是把{} 替换成变量的值。
MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 SQL 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。
SQL 分页
拦截器分页
RowBounds 分页
物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。
物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加到应用端来，就算速度上存在优势，然而其它性能上的优点足以弥补这个缺点。
Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在MyBatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke() 方法发现 a.getB() 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 SQL，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName() 方法的调用。这就是延迟加载的基本原理。
一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；
二级缓存：与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)，可在它的映射文件中配置  ；
对于缓存数据更新机制，当某一个作用域(一级缓存 Session / 二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。
Mybatis 有 3 种基本的执行器（Executor）：
SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象；
ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map 内，供下一次使用。简言之，就是重复使用 Statement 对象；
BatchExecutor：执行 update（没有 select，JDBC 批处理不支持select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement对 象都是 addBatch() 完毕后，等待逐一执行 executeBatch() 批处理。与 JDBC 批处理相同。
MyBatis 动态 SQL 可以让我们在 XML 映射文件内，以标签的形式编写动态 SQL，完成逻辑判断和动态拼接 SQL 的功能；
MyBatis 提供了 9 种动态 SQL 标签：trim、where、set、foreach、if、choose、when、otherwise、bind；
执行原理：使用 OGNL 从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL，以此来完成动态 SQL 的功能。
MyBatis面试题",
MyBatis面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 谈谈你对 MyBatis 的理解？
1. 谈谈你对 MyBatis 的理解？
2. MyBaits 的优缺点有哪些？
2. MyBaits 的优缺点有哪些？
3. MyBatis 与 Hibernate 有哪些不同？
3. MyBatis 与 Hibernate 有哪些不同？
4. MyBatis 中 #{} 和 ${}的区别是什么？
4. MyBatis 中 #{} 和 ${}的区别是什么？
5. MyBatis 是如何进行分页的？分页插件的原理是什么？
5. MyBatis 是如何进行分页的？分页插件的原理是什么？
6. MyBatis 有几种分页方式？
6. MyBatis 有几种分页方式？
7. MyBatis 逻辑分页和物理分页的区别是什么？
7. MyBatis 逻辑分页和物理分页的区别是什么？
8. MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？
8. MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？
9. 说一下 MyBatis 的一级缓存和二级缓存？
9. 说一下 MyBatis 的一级缓存和二级缓存？
10. Mybatis 有哪些执行器（Executor）？
10. Mybatis 有哪些执行器（Executor）？
11. MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL的执行原理不？
11. MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL的执行原理不？
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
MyBatis面试题",
请说下你对 MySQL 架构的了解？,"大体来说，MySQL 可以分为 Server 层和存储引擎两部分。
Server 层包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖了 MySQL 的大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等等。
存储引擎层负责：数据的存储和提取。其架构是插件式的，支持 InnoDB、MyISAM 等多个存储引擎。从 MySQL5.5.5 版本开始默认的是InnoDB，但是在建表时可以通过 engine = MyISAM 来指定存储引擎。不同存储引擎的表数据存取方式不同，支持的功能也不同。
从上图中可以看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。
MySQL面试题",
一条 SQL 语句在数据库框架中的执行流程？,"查询缓存，如果查询缓存是打开的，服务器在接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相对应的查询数据，如果存在，则直接返回给客户端。只有缓存不存在时，才会进行下面的操作；
查询优化处理，生成执行计划。这个阶段主要包括解析 SQL、预处理、优化 SQL 执行计划；
MySQL 根据相应的执行计划完成整个查询；
将查询结果返回给客户端。
详细过程可以看这篇博客https://blog.csdn.net/pcwl1206/article/details/86137408
MySQL面试题",
数据库的三范式是什么？,"第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项；
第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性；
第三范式：任何非主属性不依赖于其它非主属性。
MySQL面试题",
char 和 varchar 的区别？,"char(n) ：固定长度类型，比如：订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。
varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。
所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。
MySQL面试题",
varchar(10) 和 varchar(20) 的区别？,"varchar(10) 中 10 的涵义最多存放 10 个字符，varchar(10) 和 varchar(20) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 order by col 采用 fixed_length 计算 col 长度
MySQL面试题",
谈谈你对索引的理解？,"索引的出现是为了提高数据的查询效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。
同样索引也会带来很多负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。
建立索引的原则：
在频繁使用的、需要排序的字段上建立索引。
不适合建立索引的情况：
对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引；
对于一些特殊的数据类型，不宜建立索引，比如：文本字段（text）等。
MySQL面试题",
索引的底层使用的是什么数据结构？,"索引的数据结构和具体存储引擎的实现有关,，在MySQL中使用较多的索引有 Hash 索引、B+树索引等。而我们经常使用的 InnoDB 存储引擎的默认索引实现为 B+ 树索引。
MySQL面试题",
谈谈你对 B+ 树的理解？,"B+ 树是基于 B 树和叶子节点顺序访问指针进行实现，它具有 B 树的平衡性，并且通过顺序访问指针来提高区间查询的性能。
在 B+ 树中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。
进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。
插入、删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。
MySQL面试题",
为什么 InnoDB 存储引擎选用 B+ 树而不是 B 树呢？,"用 B+ 树不用 B 树考虑的是 IO 对性能的影响，B 树的每个节点都存储数据，而 B+ 树只有叶子节点才存储数据，所以查找相同数据量的情况下，B 树的高度更高，IO 更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。
MySQL面试题",
谈谈你对聚簇索引的理解？,"聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。
聚簇索引和非聚簇索引的区别：
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。
MySQL面试题",
谈谈你对哈希索引的理解？,"哈希索引能以 O(1) 时间进行查找，但是失去了有序性。无法用于排序与分组、只支持精确查找，无法用于部分查找和范围查找。
InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如：快速的哈希查找。
MySQL面试题",
谈谈你对覆盖索引的认识？,"如果一个索引包含了满足查询语句中字段与条件的数据就叫做覆盖索引。具有以下优点：
一些存储引擎（例如：MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。
MySQL面试题",
索引的分类？,"Hash 索引
从物理存储角度
非聚集索引（non-clustered index）
从逻辑角度
普通索引
唯一索引
主键索引
联合索引
全文索引
MySQL面试题",
谈谈你对最左前缀原则的理解？,"MySQL 使用联合索引时，需要满足最左前缀原则。下面举例对其进行说明：
1、 B+ 树的数据项是复合的数据结构，比如：(name, age, sex) 的时候，B+ 树是按照从左到右的顺序来建立搜索树的，比如：当(小明, 22, 男)这样的数据来检索的时候，B+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据。但当 (22, 男) 这样没有 name 的数据来的时候，B+ 树就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。
2、 当 (小明, 男) 这样的数据来检索时，B+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于小明的数据都找到，然后再匹配性别是男的数据了， 这个是非常重要的性质，即索引的最左匹配特性。
关于最左前缀的补充：
最左前缀匹配原则会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配，比如：a = 1 and b = 2 and c > 3 and d = 4 如果建立 (a, b, c, d) 顺序的索引，d 是用不到索引的。如果建立 (a, b, d, c) 的索引则都可以用到，a、b、d 的顺序可以任意调整。
= 和 in 可以乱序，比如：a = 1 and b = 2 and c = 3 建立 (a, b ,c) 索引可以任意顺序，MySQL 的优化器会优化成索引可以识别的形式。
MySQL面试题",
怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?,"使用 Explain 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possilbe_key、key、key_len 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。
MySQL面试题",
什么情况下索引会失效？即查询不走索引？,"下面列举几种不走索引的 SQL 语句：
1、索引列参与表达式计算：
2、 函数运算：
3、%词语%–模糊查询：
4、 字符串与数字比较不走索引：
“`mysql
CREATE TABLE 'a' ('a' char(10));
EXPLAIN SELECT * FROM 'a' WHERE 'a'=""1"" — 走索引
EXPLAIN SELECT * FROM 'a'WHERE 'a'=1 — 不走索引，同样也是使用了函数运算
 “`
5、 查询条件中有 or ，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引：
6、正则表达式不使用索引。
7、 MySQL 内部优化器会对 SQL 语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引。
MySQL面试题",
查询性能的优化方法？,"减少请求的数据量
只返回必要的行：使用 LIMIT 语句来限制返回的数据。
缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。
减少服务器端扫描的行数
MySQL面试题",
InnoDB 和 MyISAM 的比较？,"事务：MyISAM不支持事务，InnoDB支持事务；
全文索引：MyISAM 支持全文索引，InnoDB 5.6 之前不支持全文索引；
关于 count()：MyISAM会直接存储总行数，InnoDB 则不会，需要按行扫描。意思就是对于 select count() from table; 如果数据量大，MyISAM 会瞬间返回，而 InnoDB 则会一行行扫描；
外键：MyISAM 不支持外键，InnoDB 支持外键；
锁：MyISAM 只支持表锁，InnoDB 可以支持行锁。
MySQL面试题",
谈谈你对水平切分和垂直切分的理解？,"水平切分是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。
垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。例如：将原来的电商数据库垂直切分成商品数据库、用户数据库等。
MySQL面试题",
主从复制中涉及到哪三个线程？,"主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。
binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Relay log）中。
SQL 线程 ：负责读取重放日志并重放其中的 SQL 语句。

MySQL面试题",
主从同步的延迟原因及解决办法？,"主从同步的延迟的原因：
假如一个服务器开放 Ｎ 个连接给客户端，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个， 当某个 SQL 在从服务器上执行的时间稍长或者由于某个 SQL 要进行锁表就会导致主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。
主从同步延迟的解决办法：
实际上主从同步延迟根本没有什么一招制敌的办法， 因为所有的 SQL 必须都要在从服务器里面执行一遍，但是主服务器如果不断的有更新操作源源不断的写入，那么一旦有延迟产生，那么延迟加重的可能性就会原来越大。当然我们可以做一些缓解的措施。
我们知道因为主服务器要负责更新操作， 它对安全性的要求比从服务器高，所有有些设置可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而 slave 则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭 binlog、innodb_flushlog、innodb_flush_log_at_trx_commit 也 可以设置为 0 来提高 SQL 的执行效率。
增加从服务器，这个目的还是分散读的压力， 从而降低服务器负载。
MySQL面试题",
谈谈你对数据库读写分离的理解？,"读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。
读写分离能提高性能的原因在于：
主从服务器负责各自的读和写，极大程度缓解了锁的争用；
从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
增加冗余，提高可用性。
MySQL面试题",
请你描述下事务的特性？,"原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性：执行事务前后，数据库从一个一致性状态转换到另一个一致性状态。
隔离性：并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间数据库是独立的；
持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响。
MySQL面试题",
谈谈你对事务隔离级别的理解？,"READ_UNCOMMITTED（未提交读）: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；
READ_COMMITTED（提交读）: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；
REPEATABLE_READ（可重复读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；
SERIALIZABLE（串行化）: 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。
MySQL面试题",
解释下什么叫脏读、不可重复读和幻读？,"表示一个事务能够读取另一个事务中还未提交的数据。比如：某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。
是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果 只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题
不可重复读的重点是修改 :同样的条件 ,   你读取过的数据 ,   再次读取出来发现值不一样了
指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。
幻读的重点在于新增或者删除：同样的条件 ,   第 1 次和第 2 次读出来的记录数不一样
MySQL面试题",
MySQL 默认的隔离级别是什么？,"MySQL默认采用的 REPEATABLE_READ隔离级别。
Oracle 默认采用的 READ_COMMITTED 隔离级别。
MySQL面试题",
谈谈你对MVCC 的了解？,"数据库并发场景：
读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；
写-写：有线程安全问题，可能会存在更新丢失问题。
多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。
MVCC 可以为数据库解决以下问题：
在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；
同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。
MySQL面试题",
说一下 MySQL 的行锁和表锁？,"MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。
表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。
行级锁：开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。
MySQL面试题",
InnoDB 存储引擎的锁的种类有哪些？,"Record lock：单个行记录上的锁；
Gap lock：间隙锁，锁定一个范围，不包括记录本身；
Next-key lock：record+gap 锁定一个范围，包含记录本身。
MySQL面试题",
MySQL 问题排查都有哪些手段？,"使用 show processlist 命令查看当前所有连接信息；
使用 Explain 命令查询 SQL 语句执行计划；
开启慢查询日志，查看慢查询的 SQL。
MySQL面试题",
MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？,"当 CPU 飙升到 500% 时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。
如果是 mysqld 造成的，通过 SHOW PROCESSLIST 查看正在运行的线程，是不是有消耗资源的 SQL 在运行，找出其中消耗高的 SQL，看看执行计划是否准确， index 是否缺失，或者是数据量太大造成。
然后 kill 掉这些线程（同时观察 CPU 使用率是否下降），等进行相应的调整（比如说加索引、改 SQL、改内存参数）之后，再重新跑这些 SQL。
若每个 SQL 消耗资源都不多，只是同一时间大量的 session 连进来导致 CPU 飙升，这种情况就需要分析为何连接数会激增，再做出相应的调整，比如说限制连接数等
MySQL面试题",
Redis 内存淘汰策略有哪些？,"volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰；
volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。
volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。
allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。
allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。
MySQL面试题",
MySQL,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里：MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题",
MySQL的redo log，undo log，bin log都是干什么的,"redo log是InnoDB引擎特有的，只记录该引擎中表的修改记录。binlog是MySQL的Server层实现的，会记录所有引擎对数据库的修改。
redo log是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑。
redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
1、redolog记录修改内容（哪一页发生了什么变化），写于事务开始前，用于数据未落磁盘，但数据库挂了后的数据恢复
2、binlog记录修改SQL，写于事务提交时，可用于读写分离
3、undolog记录修改前记录，用于回滚和多版本并发控制
MySQL面试题",
SQL 与 MySQL 有什么区别,"SQL 和 MySQL 是 DBMS 中最令人困惑的两个术语，二者之间存在本质上的区别。
MySQL面试题",
添加索引的原则,"索引虽好，但也不是无限制使用的，以下为添加索引时需要遵循的几项建议性原则：
MySQL面试题",
有哪些事务状态,MySQL面试题,
什么是死锁？如何解决死锁？,"死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。
常见的解决死锁的方法
MySQL面试题",
什么是超键？什么是主键？,"超 键：在关系中，能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
候选键：是最小超键，即没有冗余元素的超键。
主 键：数据库表中对储存数据对象予以 唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。
外 键：在一个表中存在的另一个表的主键称此表的外键，外键可以有重复的, 可以是空值。外键是用来和其他表建立联系用的。
MySQL面试题",
DROP、DELETE 与 TRUNCATE 的区别,"三种都可以表示删除，其中的细微区别之处如下：
因此，在不再需要一张表的时候，采用 DROP；在想删除部分数据行时候，用 DELETE；在保留表而删除所有数据的时候用 TRUNCATE。
MySQL面试题",
为什么要分库分表,"数据库中的数据量不一定是可控的，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地数据操作，例如 增删改查的开销 也会越来越大；另外，若不进行分布式部署，而一台服务器的 资源 （CPU、磁盘、内存、IO 等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。所以，从 性能 和 可用性 角度考虑，会进行数据库拆分处理，具体地说，把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上，即 分库分表。
MySQL面试题",
分库分表存在哪些问题,"事务问题：分库分表后，就成了分布式事务。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。
跨库跨表的 JOIN 问题：在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法 JOIN 位于不同分库的表，也无法 JOIN 分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。
额外的数据管理负担和数据运算压力：额外的数据管理负担，最为常见的是数据的 定位问题 和数据的 增删改查 的重复执行问题，这些都可以通过应用程序来解决，但必然会引起额外的逻辑运算。
MySQL面试题",
MySQL 读写分离的实现方案,"MySQL 读写分离的实现方式主要基于 主从复制，通过 路由的方式 使应用对数据库的写请求只在 Master 上进行，读请求在 Slave 上进行。
具体地，有以下四种实现方案：
方案一：基于 MySQL proxy 代理
在应用和数据库之间增加 代理层，代理层接收应用对数据库的请求，根据不同请求类型（即是读 read 还是写 write）转发到不同的实例，在实现读写分离的同时可以实现负载均衡。MySQL 的代理最常见的是 mysql-proxy、cobar、mycat、Atlas 等。
方案二：基于应用内路由
基于应用内路由的方式即为在应用程序中实现，针对不同的请求类型去不同的实例执行 SQL。
具体实现可基于 spring 的 aop：用 aop 来拦截 spring 项目的 dao 层方法，根据方法名称就可以判断要执行的类型，进而动态切换主从数据源。
方案三：基于 MySQL-Connector-Java 的 JDBC 驱动方式
Java 程序通过在连接 MySQL 的 JDBC 中配置主库与从库等地址，JDBC 会自动将读请求发送给从库，将写请求发送给主库，此外， MySQL 的 JDBC 驱动还能够实现多个从库的负载均衡。
方案四：基于 sharding-jdbc 的方式
sharding-sphere 是强大的读写分离、分表分库中间件，sharding-jdbc 是 sharding-sphere 的核心模块。
MySQL面试题",
Node.js基础面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
Node.js面试题

ㅤ普通",
请介绍一下node里的模块是什么,"Node中，每个文件模块都是一个对象，它的定义如下：
所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。
Node.js面试题

ㅤ普通",
我们知道node导出模块有两种方式，一种是exports.xxx=xxx和Module.exports={}有什么区别吗,"Node.js面试题

ㅤ普通",
"为什么用Nodejs,它有哪些缺点","当然Nodejs也有一些缺点：
Node.js面试题

ㅤ普通",
如何用Node监听80端口,"Node.js面试题

ㅤ普通",
node.js有哪些常用模块,"util是node 里面一个工具模块，node里面几乎所有的模块都会用到这个模块
功能：
1.实现继承这是主要功能
2.实现对象的完整输出
3.实现判断数据类型
path模块
功能：格式规范化路径
fs模块
功能：
1.操作文件
2.操作目录
http模块：用于搭建HTTP服务端和客户端
url模块：用户解析和处理URL字符串
url.parse(将url字符串解析并返回一个url的对象)
url.format(将url对象编程一个url字符串并返回)
url.resolve(将url中的参数用/进行拼接)
zlib模块：提供了用Gzip和Deflate/Inflate实现的压缩功能
socket.io: 实现客服端与服务端之间的实时通信方式
uglify-js: 用来压缩合并js文件
child_process：新建子进程。
querystring：解析URL中的查询字符串。
crypto：提供加密和解密功能。
Node.js面试题

ㅤ普通",
node如何实现异步非阻塞（I/O）,"在node中，I/O（输入输出）是异步非堵塞的关键，I/O操作通常比较耗时但不会独占CPU，典型的I/O比如文件读写，远程数据库读写，网络请求等，如果用同步API来进行I/O操作，在返回结果之前就只能等待，此时阻塞代码会霸占cpu，导致本进程所有代码都等待，而node.js里面的I/O API都是不会霸占CPU的（原因：node中的核心库libuv会将建立的所有I/O操作内容绑定到单个线程上。只要每个事件循环在不同的线程中，就可以运行多个事件循环，libuv为Node.js提供了跨平台、线程池、事件池、异步I/O等能力），所以是非阻塞的。拿JS中的setTimeout来打比方，当用户使用setTimeout时，JS会开辟出一个异步线程池，与主线程分开执行，结果就是之前的代码继续执行，setTimeout的代码延时执行，等成功后再调用主线程的方法
Node.js面试题

ㅤ普通",
node中的exports如何实现的，它和module.exports有什么关系,"exports实现：exports = module.exports = {};就好像是var a = {  } var b = a，看上去没有太大区别，但使用起来却又不同module是一个对象，当我们在控制台输入node并执行，在node中执行module或者执行js文件打印module时会发现以下log
不难发现，module是Module的实例，exports是其中一个属性，也就是说当你在node中执行一个js文件或者使用
require引入模块时，nodejs都会新建一个var module = new Module（），并执行exports = module.exports，
这也就是为什么直接打印exports和exports时，控制台不会报错，如果在node中执行以下代码，就能清楚的看出
这二者的引用关系了
Node.js面试题

ㅤ普通",
谈谈Node.js加载模块机制,"node.js中模块有两种类型：核心模块和文件模块
核心模块直接使用名称获取，文件模块只能按照路径加载（可以省略默认的.js拓展名，不是js文件的话需要显示声明书写）
模块加载规则：
核心模块优先级最高，直接使用名字加载，在有命名冲突的时候首先加载核心模块可通过绝对路径和相对路径查找查找node_modules目录，我们知道在调用 npm install  命令的时候会在当前目录下创建node_module目录(如果不存在) 安装模块，当 require 遇到一个既不是核心模块,又不是以路径形式表示的模块名称时,会试图 在当前目录下的 node_modules 目录中来查找是不是有这样一个模块。如果没有找到,则会 在当前目录的上一层中的 node_modules 目录中继续查找,反复执行这一过程,直到遇到根目录为止
Node.js面试题

ㅤ普通",
Node.js的适用场景,"Node.js面试题

ㅤ普通",
node中的Connect模块是什么，Koa与Express的中间件有什么区别,"Connect是一个node中间件（middleware）框架，每个中间件在http处理过程中通过改写request或（和）response的数据、状态，实现了特定的功能Koa与Express中间件的区别：Express主要基于Connect中间件框架，中间件一个接一个的顺序执行，通常会将 response 响应写在最后一个中间件中而koa主要基于co中间件框架，它的中间件是通过 async await 实现的，中间件执行顺序是“洋葱圈”模型。执行效果类似于Promise.all
Node.js面试题

ㅤ普通",
Node.js有什么优势,"以下是Node.js的主要优点：
Node.js面试题

ㅤ普通",
两个 Node. js程序之间如何交互,"通过fork实现父子程序之间的交互。子程序用 process.on、 process. send访问父程序，父程序用 child.on、 child.send访问子程序。
关于 parent. JS的示例代码如下。
关于 child .js的示例代码如下。
Node.js面试题

ㅤ普通",
解释NodeJS中间件概念,"一般来说，中间件是一个接收请求和响应对象的函数。换句话说，在应用程序的请求-响应循环中，这些函数可以访问各种请求和响应对象以及循环的下一个函数。中间件的 next 功能是借助一个变量来表示的，通常命名为 next。中间件功能最常执行的任务是：
执行任何类型的代码
更新或修改请求和响应对象
完成请求-响应循环
调用堆栈中的下一个中间件
Node.js面试题

ㅤ普通",
Node.js 中 readFile 和 createReadStream 的区别,"Node.js 提供了两种读取和执行文件的方式，分别是使用 readFile 和 CreateStream。readFile() 是一个完全缓冲的进程，只有当完整的文件被推入缓冲区并被读取时才返回响应。这是一个内存密集型过程，在大文件的情况下，处理速度可能非常慢。而 createReadStream 是部分缓冲的，它将整个过程视为一个事件系列。整个文件被分成块，然后被处理并作为响应一一发回。完成后，它们最终会从缓冲区中删除。与 readFile 不同，createReadStream 对于大文件的处理非常有效。
Node.js面试题

ㅤ普通",
有什么nodejs类库可以直接指定时区吗,"主要表现在各种日期数据转换和存储上面。前后端在传递和存储日期时都有几种选择回:
1,unix的时间戳。
2,格式化后的字符串格式，如2012-04-01 10:00:00等。
3,直接存储日期类型.mongoose中。
容易出现问题的是驱动在处理不同日期格式上的差异。
目前在做一个小应用中碰到了这方面的问题。
当然这个也可能是自己的了解不深入，写在这里也希望有更多的人能讲解一下日期、时区等方面的知识。
问题表现在mysql中。mongo的时间是utc时间的，不带时区信息。
如果做数据转换工具得注意这些问题了。
Node.js面试题

ㅤ普通",
请介绍一下Node事件循环的流程,"Node.js面试题

ㅤ普通",
请问实现一个node子进程被杀死，然后自动重启代码的思路,"Node.js面试题

ㅤ普通",
如果使用过koa、egg这两个Node框架，请简述其中的中间件原理，最好用代码表示一下,"koa中间件实现源码大致思路如下：
Node.js面试题

ㅤ普通",
谈下你对 Redis 的了解？,"Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。
Redis面试题",
Redis 一般都有哪些使用场景？,"Redis 适合的场景
排行榜：利用 Redis 的 SortSet（有序集合）实现；
计数器/限速器：利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便解决一些共同好友、共同爱好之类的功能；
消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；
Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。
Redis 不适合的场景
数据量太大、数据访问频率非常低的业务都不适合使用 Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。
Redis面试题",
Redis 有哪些常见的功能？,"数据缓存功能
分布式锁的功能
支持数据持久化
支持事务
支持消息队列
Redis面试题",
Redis 支持的数据类型有哪些？,"字符串类型是 Redis 最基础的数据结构，首先键是字符串类型，而且其他几种结构都是在字符串类型基础上构建的。字符串类型实际上可以是字符串：简单的字符串、XML、JSON；数字：整数、浮点数；二进制：图片、音频、视频。
使用场景：缓存、计数器、共享 Session、限速。
在 Redis中哈希类型是指键本身是一种键值对结构，如 value={{field1,value1},……{fieldN,valueN}}
使用场景：哈希结构相对于字符串序列化缓存信息更加直观，并且在更新操作上更加便捷。所以常常用于用户信息等管理，但是哈希类型和关系型数据库有所不同，哈希类型是稀疏的，而关系型数据库是完全结构化的，关系型数据库可以做复杂的关系查询，而 Redis 去模拟关系型复杂查询开发困难且维护成本高。
列表类型是用来储存多个有序的字符串，列表中的每个字符串成为元素，一个列表最多可以储存 2 ^ 32 – 1 个元素，在 Redis 中，可以队列表两端插入和弹出，还可以获取指定范围的元素列表、获取指定索引下的元素等，列表是一种比较灵活的数据结构，它可以充当栈和队列的角色。
使用场景：Redis 的 lpush + brpop 命令组合即可实现阻塞队列，生产者客户端是用 lpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。

集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中不允许有重复的元素，并且集合中的元素是无序的，不能通过索引下标获取元素，Redis 除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。合理的使用好集合类型，能在实际开发中解决很多实际问题。
使用场景：如：一个用户对娱乐、体育比较感兴趣，另一个可能对新闻感兴趣，这些兴趣就是标签，有了这些数据就可以得到同一标签的人，以及用户的共同爱好的标签，这些数据对于用户体验以及曾强用户粘度比较重要。
有序集合和集合有着必然的联系，它保留了集合不能有重复成员的特性，但不同得是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是：它给每个元素设置一个分数，作为排序的依据。
使用场景：排行榜是有序集合经典的使用场景。例如：视频网站需要对用户上传的文件做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。
Redis面试题",
Redis 为什么这么快？,"完全基于内存，绝大部分请求是纯粹的内存操作，非常快速；
数据结构简单，对数据操作也简单；
采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
使用多路 I/O 复用模型，非阻塞 IO。
Redis面试题",
什么是缓存穿透？怎么解决？,"缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。
解决办法：
1、缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
缓存空对象带来的问题：
缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如：过期时间设置为 5分钟，如果此时存储添加了这个数据，那此段时间就会出现缓存和存储数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。
2、布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。
Redis面试题",
什么是缓存雪崩？该如何解决？,"如果缓存集中在一段时间内失效，所有的查询都落在数据库上，造成了缓存雪崩。
解决办法：
加锁排队：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待；
数据预热：可以通过缓存 reload 机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀；
做二级缓存，或者双缓存策略：Cache1 为原始缓存，Cache2 为拷贝缓存，Cache1 失效时，可以访问 Cache2，Cache1 缓存失效时间设置为短期，Cache2 设置为长期。
在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。
Redis面试题",
怎么保证缓存和数据库数据的一致性？,"一般有如下四种方案，详情看这里：
第一种和第二种方案，没有人使用的，因为第一种方案存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。
第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。
目前主要用第三和第四种方案，详情看这里：
双写一致性方案一：先删除缓存，后更新数据库
双写一致性方案一：先删除缓存，后更新数据库
双写一致性方案二：先更新数据库，后删除缓存
双写一致性方案二：先更新数据库，后删除缓存
Redis面试题",
Redis 持久化有几种方式？,"持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis 提供了两种持久化方式：RDB（默认） 和 AOF。
RDB
RDB 是 Redis DataBase 的缩写。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即 Snapshot 快照存储，对应产生的数据文件为 dump.rdb，通过配置文件中的 save 参数来定义快照的周期。核心函数：rdbSave（生成 RDB 文件）和 rdbLoad（从文件加载内存）两个函数。

AOF
AOF 是 Append-only file 的缩写。Redis会将每一个收到的写命令都通过 Write 函数追加到文件最后，类似于 MySQL 的 binlog。当 Redis 重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。每当执行服务器（定时）任务或者函数时，flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作：

RDB 和 AOF 的区别：
AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据；
AOF比 RDB 更安全也更大；
RDB 性能比 AOF 好；
如果两个都配了优先加载 AOF。
Redis面试题",
Redis 常见性能问题和解决方案？,"Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；
为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内；
主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3…
Redis面试题",
Redis,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里： Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
Redis面试题",
Redis面试题阅读指南,"大家好，我是帅地。
Redis 更新到 62 道，段时间内应该不更新了，把大部分考到的问题基本都写了，大家可以把这个当作突击使用。
登录后免费查看
 隐藏内容登录后免费查看
 
持续更新～持续更新～持续更新～
记得收藏呀
Redis面试题",
Shopee 前端岗开发面经汇总,"本系列将提供Shopee 前端岗位历年面经，所有面经都有候选人面试之后根据回忆整理而出，大家可以通过面经来复习以及看看Shopee面试难度。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 【Shopee】前端岗-社招面经分享
1. 【Shopee】前端岗-社招面经分享
2. 【Shopee】前端岗-热乎的的虾皮2022秋招面经
2. 【Shopee】前端岗-热乎的的虾皮2022秋招面经
3. 【Shopee】前端岗-base深圳二次面试经历
3. 【Shopee】前端岗-base深圳二次面试经历
4. 【Shopee】前端岗-2021校招提前批
4. 【Shopee】前端岗-2021校招提前批
5. 【Shopee】前端岗-虾皮第四批(已oc)
5. 【Shopee】前端岗-虾皮第四批(已oc)
Shopee面试
前端开发岗

ㅤ普通",
【Shopee】前端岗-社招面经分享,"发现shopee今年还是挺火的，招的人也挺多，但是面经很少，所以记录一波，有需要的看下。
1.自我介绍
2.单向链表输出倒数第K个元素
3.看代码输出结果（考察变量、函数提升）
4.看代码输出结果（考察异步代码先后顺序）
5.手写instanceof关键字
6.手写Promise
7.react中为什么不能在for循环、if语句里使用hooks，说下react hooks实现原理。
8.说下react fiber。
9.看你之前做过RN开发，说下RN的原理。
10.说下输入一个url地址的全过程。
11.http的缓存策略。
12.说下https，证书是如何校验的？
13.说下http2，你觉得阻碍http2发展的问题是什么？（这题后面的问题挺有意思，可以网上搜下答案）
14.算法题。跳格子问题，假设一次只能跳一个格子和两个格子，N个格子有多少种跳法？
1.自我介绍
2.为什么要离职？
3.对你的项目经历中RN做的app挺感兴趣的，你能详细说下这个项目吗？
4.RN中原生和js端是如何通信的？你说后面使用JSI了，你能说下JSI的实现原理吗？
5.如果要你对这个app进行性能优化，你有哪些办法（面试官问了三次还有其他办法吗？）
代码层面，按照react的优化，减少re-render次数。图片加载用react-native-fast-image,页面初始化的逻辑使用InteractionManager.runAfterInteractions。去掉无用的View层。
进行分包加载，启动时只加载启动页面bundle，二级及更深页面等访问到再加载。
一些复杂的控件，写原生模块，比如日期选择、下拉选择、级联、播放器等。
6.你们的RN热更新服务是怎么做的？热更新原理是什么？你们的热更新策略怎么做的？
客户端用的微软的code-push,服务端用的code-push-server。
热更新原理就是app每次启动会请求热更新服务器，对比下本地bundle版本和服务器的bundle版本，如果版本不一致，就会根据配置的更新策略下载、更新bundle,然后重新reload bundle。
我们就是在检查到新的bundle后，会弹窗强制更新。
7.设计一个RN热更新服务，需要考虑哪些地方？
bundle体积大的问题。打包的时候需要进行分包，使用增量更新，减少下载体积。
用户的网络不稳定、网速差问题。需要用CDN加速，支持断点续传。
安全性问题。
bundle被中间人劫持篡改。使用https下载，并按照https的加密思路，对bundle用hash算法进行签名，然后app端检验签名是否被篡改。
bundle下载地址被暴力攻击。检查User-Agent,只允许手机设备下载，记录设备id，在一定时间内限制下载次数。
8.你有什么要问我的吗？
就一些简单的问题，这里就不说了。到hr面，基本都能过。
整体难度一般，一面没有区分度，感觉一年经验和五年经验都是一样的。二面不错，对项目进行了深挖，考察了架构设计。问的问题偏向于RN，最后进来也是做C端的RN开发。
在shopee的工作体验确实轻松，不卷，但是过于轻松，又担心自己的产出。差不多就这样吧。大家自己看一看我写的面经，或许有所帮助吧。
Shopee面试
前端开发岗

ㅤ普通",
【Shopee】前端岗-热乎的的虾皮2022秋招面经,"超级无敌好的面试官，面试正式开始前还说他会用电脑做记录，可能有停顿，希望不要介意（我不介意！！！您慢慢记！！！多记点好的了）
介绍一下在实验室做了些什么
除了 flex做响应式布局，还有别的方案吗（说了 grid）
介绍一下你了解的flex
css实现垂直水平居中，尽可能多的方案
问我更擅长哪一方面，他就问什么（太好了吧? 说了css和js）
元素隐藏的方法
我：display: none、visibility: hidden、opacity: 0, z-index,
面试官： position: absolute移到可视区域外、缩放 transform:scale(0),
面完后我搜到的：文本缩进属性text-indent: -999px、lip-path: polygon(0 0, 0 0, 0 0, 0 0)、height: 0; overflow: hidden;
什么是重绘和重排，怎么减少
怎么引起重绘和重排
答：样式改变触发重绘（这个不太对，所以面试官又接着问了） dom结构改变引起重排（应该没答完整所以继续追问了）
单纯改变样式会引起重排吗，比如padding和margin
答：会引起
哪些样式改变会引起重绘，哪些会引起重排
答：调整字体大小、窗口大小、样式改变（我仿佛脑抽了用问题回答问题，其实我想说颜色这种样式的改变，被抓住了这一点，见13）会引起重排
所有样式改变都会引起重排吗
答：改颜色只会引起重绘
缩小元素怎么不引起重排，比如10px * 10px 变5px * 5px；
答：一紧张说了个translation？？给面试官逗笑了55555
面试官：translate / transform确实不影响真实占位不会重排，但是改位置和改尺寸会引起重排，因为要重新计算div的位置大小，
只要不改div在整个布局的位置和尺寸就不引起重排，比如你刚说的改变字体大小和窗口大小就会引起重排。
我主动补充了opacity:0和position: absolute/fixed脱标可以减少重排
面试官：先绝对定位掉，等全部渲染完再（什么什么听不清了）减少重排的次数
promise解决了什么问题（回调地狱）
promise的方法
说了then, catch, 面试官补充了all race
对算法和数据结构有信心吗（我没有哈哈哈）
面试官是css组的（耶！躲过一劫！ ）但是说了需要去了解算法思想
考考正则，命名转小驼峰
可能的输入：TestVal，test_val, TEST_VAL ，要求实现驼峰命名的输出
面试时只考虑了后面两种，所以就直接先转小写然后匹配下划线
css选择器考察
（1）获取当前页面的所有 dom节点
（2）获取当前页面的所有 p节点
（3）获取当前页面带有data-click属性的节点，color设为白色
伪类和伪元素，知道哪些，有什么区别自我介绍+项目介绍（超温柔的面试官就是问的问题一点也不温柔，会一直深挖?）
反问环节
（1）看中面试者的那一方面（只要有一个方面够突出就行，了解的多并有专精能力）
（2） 公司业务
项目中身份校验用的token和sessionStorage
问：为什么信息存在sessionStorage而不是别的地方
问：sessionStorage和localStorage区别
问：sessionStorage在同一个标签页跳转之后还在吗
为什么项目使用vue而不是react
vue3.0了解吗？他的特性
vue3.0的生命周期为什么变更
vue3.0的proxy解决了什么问题
用ES5还是ES6
ES6的promise的异步回调解决了什么问题
作用域和作用域链
箭头函数的特性，它的this指向在编译的时候决定还是运行的时候决定
写代码：new操作符干了什么
写代码：
给定一个只包括 ‘(‘，’)’，'{‘，’}’，'[‘，’]’ 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。
https是怎么实现，解决了什么问题
服务端发送给客户端的证书咋校验有效的
Shopee面试
前端开发岗

ㅤ普通",
【Shopee】前端岗-base深圳二次面试经历,"选择，单选10，多选5
padding继承父级宽度
flux流程
cookie的几个属性，must-revalidate，same-site等
抽象类中可以有非抽象方法，有抽象方法的一定都是抽象类
cache-control属性
css浏览器前缀
。。。还有一些忘了
代码
返回排序后前n个元素
第二题题目太长
判断一棵树的对称性(层序遍历判断)
7.11 50分钟
面试官的自我介绍？？
为什么学前端？离职原因？
浏览器多进程架构
缓存存储位置，Cache文件夹
常见状态码
协商缓存和强缓存
Etag生成原理
http和https
cookie
同源网站和同站点网站的cookie设置
公司内部的单点登录系统的原理
内存泄漏，导致的原因，减少方法
dom事件流机制
事件循环
看代码输出
setTimeout(() => {   console.log(1); }, 0); console.log(2); new Promise(res => {  res(console.log(3)) console.log(4); }).then(() => {   console.log(5); }); (async () => console.log(6))();
reflow和repaint
减少上述两个的方法
js脚本的async和defer属性，顺序问题，(defer可以保证插入的顺序，async不能保证顺序)
css的预加载属性(prefetch)
数字的精度问题(Number.MAX_VALUE和安全整数)
(双精度，64位存储，1位符号，10位指数，53位底数存储，最大是2^53，超出显示会有精度缺失，还有一个安全整数，超过这个安全整数的运算会有精度问题)
代码:
字符串相加 原题https://leetcode-cn.com/problems/add-strings/
还有好多，忘了。。。考的挺广的
1小时，7.14
自我介绍
es6 新语法
let，var，const
Set,map,weakSet,weakMap
弱引用的具体场景
箭头函数
ts的知识，不会，过
defer和async的script脚本
css 0.5 px实现
reflow、减少机制，措施
博客、分享
实习项目，和我自己的项目做的时候的难点、亮点分享
代码:
代码一般一道题或者两道题，看剩余时间，打的快可以多做一道加分题(面试官说的)
Promise.all 和 race 实现
7.23 hr 已面，通知八月底再联系offer情况
Shopee面试
前端开发岗

ㅤ普通",
【Shopee】前端岗-2021校招提前批,"去年年底在牛客网找了Shopee新加坡的前端内推，目前已完成终面，来分享一下经验。
面试流程一共四轮：
HR电话面（简单了解情况，无技术内容）：
是哪里人，为什么会选择新加坡岗位，找工作优先考虑哪些因素，为什么选择前端
一上来先简单问了下做过项目的难点，然后顺带问了一下浏览器的强缓存和协商缓存机制。
接着是几道手撕代码题（有几题记不清了
这轮考察数据结构和算法，全程就一道题手撕代码。
输入如下：
const sourceData = [
[“bag”, “purse”],
[“purse”, “hand purse”],
[“bag”, “backpack”],
[“purse”, “purse wallet”],
[“purse wallet”, “coin wallet”],
[“purse wallet”, “man purse”],
[“shoe”, “nike shoe”],
];
根据输入建立一个如下图的sankey diagram（类似电商的商品搜索路径图）
“bag”  ➡  “purse”     ➡  “hand purse”
↘             ↘
↘             “purse wallet”  ➡  “coin wallet”
↘                           ↘
↘                           “man purse”
↘
“backpack”
“shoe”  ➡ “nike shoe”
要求实现一个函数返回该图的width(最长路径)和height(路径总数)。如上图的width = 4, height = 5。
我的思路是用类似树状结构存储数据，每个树节点有一个array用来存放子节点。然后用DFS遍历整棵树求出叶子节点个数即为height，用backtracking思想可求出最长路径width。
（我自定义树节点构造函数的时候有挺多语法错误，有点尴尬；面试官说我思路正确，然后点了几个可以优化的地方让我修改了下）。
终面也是技术面。上来先做自我介绍，问了一些项目经历（我项目经历真的少），问我为什么使用Django，为什么会学习React，怎样学习CSS的，学习编程语言的方法；
然后问了从在浏览器地址栏输入url，到用户看到页面发生了什么。
我说的有点笼统，然后又详细问了DOM树和CSSOM树的元素是不是一一对应的（我真不会）；
浏览器先加载还是先渲染页面，为什么会这样；
如果有defer属性将如何执行，问我了不了解的defer和async（我真不了解async）；
接着问了cookie的具体存储形式，是由浏览器还是服务器端设置的，为何能保存用户登录信息（问的太细了，我真没咋准备好）。
顺带问了cookie, session storage, local storage的异同，我提到了同源，又问了一下同源是什么；
然后给了一个场景，给定一个DOM元素和一个字符串，问如何根据DOM元素的最大宽度返回能容纳的最长的子字符串（说思路即可）。
我实在不会DOM的API，面试官就给了一个Helper函数，能返回字符串在页面中的实际宽度。
然后我的想法是从后往前截短字符串，直到子字符串实际长度小于等于最大宽度。
面试官于是问了时间复杂度（O(n)？），问我如何优化；我说二分法应该可以优化到O(logn)。
又问有没有O(const)的解决方案，我当时没想出来（现在想想应该是用个map记录所有合法字符的所占宽度，然后从头扫描字符串当总宽度大于DOM元素宽度时停止，这样空间换时间应该能达到常量时间复杂度）。
接着问了我平时怎么学习新技术（我说上MDN看文档，看GitHub项目源码，大神博客），问我会不会去看CSS标准（说实话没咋看过）
问我在这个团队希望能学到什么东西，为什么；
然后就是反问环节，我水了两个问题就结束了。
总结：面试体验很好，面试官都很年轻很随和。
二面就一道题考数据结构和算法，考的挺全面的，基础一定还是要打好，各种链表二叉树BFSDFS等等都得熟练。
终面真的就是一路追问到你答不上来为止（也可能我太菜了，感觉我终面说得最多的一句话就是“这部分我没有深入了解”），千万不要给自己挖坑随便提一些不了解的知识点。
许愿能上岸吧。
祝各位也好运。
Shopee面试
前端开发岗

ㅤ普通",
【Shopee】前端岗-虾皮第四批(已oc),"虾皮前端第四批
4.7 笔试
15:00 55min
postiton各属性
样式优先级
bfc
flex
跨域CORS
CORS如何携带cookie
事件循环
http缓存
promise
判断输出结果：
1.es6 module循环引用题
2.TS泛型题
手撕：手写数组扁平化
数组哪些方***使原数组发生改变
有些不记得了，都是基础题。
15:00 47min
聊项目
聊公司
如何考虑是否去一家公司
事件循环题判断输出
手撕：斐波那契数列三个写法：递归、动态规划、缓存
React hook
useCallBack
pureComponent原理
xss攻击
二面大部分时间还是聊聊天，面试官也很nice，也聊了聊他的经历。虾皮面试总体还是很简单的，都很基础。
4.24 HR面 20min
4.29 oc sp
Shopee面试
前端开发岗

ㅤ普通",
Shopee 客户端岗开发面经汇总,"本系列将提供Shopee 客户端岗位历年面经，所有面经都有候选人面试之后根据回忆整理而出，大家可以通过面经来复习以及看看Shopee面试难度。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 【Shopee】客户端岗-ios开发一二hr面经
1. 【Shopee】客户端岗-ios开发一二hr面经
2. 【Shopee】客户端岗-不错的安卓面试体验
2. 【Shopee】客户端岗-不错的安卓面试体验
3. 【Shopee】客户端岗-还愿shopee！附iOS面经
3. 【Shopee】客户端岗-还愿shopee！附iOS面经
4. 【Shopee】客户端岗-秋招的第一场面试
4. 【Shopee】客户端岗-秋招的第一场面试
5. 【Shopee】客户端岗-安卓SP专场
5. 【Shopee】客户端岗-安卓SP专场
Shopee面试
客户端开发岗

ㅤ普通",
【Shopee】客户端岗-ios开发一二hr面经,"楼主方向是C/C++，没接触过ios，但是ios开发不卷，投递的人很少，岗位要求也没说一定要接触过iOS开发，遂尝试投递
面试官感觉雷厉风行
自我介绍
不问项目
（1h）
C++多态（静态多态，动态多态）
动态多态内部原理（虚函数指针，虚函数表，一顿背）
继承用过吗？继承的优点？缺点？
继承和组合的区别（没答上来）
设计模式知道几个
归并排序具体原理和时间复杂度
知道什么是动态语言和静态语言吗（不知道）
什么是用户态和内核态
进程通信的mmap
虚拟内存知道吗？有什么用？
哈希表实现原理？有哪些映射方法？有哪些解决冲突的办法？
有没有了解哈希表什么时候要扩容，什么时候时间复杂度最差？
HTTP1.1和2.0的区别（还好面试前看面经看了一下）
HTTP2.0为什么采用二进制传输，多路复用能详细说说吗（没答上来）
TCP的滑动窗口机制
手撕代码：求删除一个字符串的一些字符，使其所有字符的频次不同，问最小删除字符个数
没见过的题，倒腾了20多分钟，最后经面试官提示写出来了，题不难，有点丢人
中秋节前一天，面试官感觉要回家赶火车，很急的样子
自我介绍
介绍项目
一面有没有什么问题你不会的
C++虚函数
C++内存分配
HTTP连接过程
数组和链表的区别
哈希表原理，知道LRU吗，是怎么实现的，为什么要用双向链表？
介绍一下快速排序
STL里面的sort为什么要用快速排序，不用别的排序
10G数据，只有256M内存，如何排序
手撕代码：二叉树的最大路径和，我问面试官要自己构建二叉树吗，于是面试官又换了一个合并两个有序链表，自己构建链表，不允许使用递归。
写到一半面试官溜了，换了一个新面试官，和他说了说代码思路
反问新面试官
问成绩
介绍项目
问一些个人信息
问求职最看重的点
个人性格
等等
反问
许愿意向书！
Shopee面试
客户端开发岗

ㅤ普通",
【Shopee】客户端岗-不错的安卓面试体验,"无语了，shopee应该是没hc了吧，昨晚十一点多 收到感谢信，大周末还在刷人真的辛苦了。
发发面经祝大家好运
首先自我介绍
首先事C++基础知识：
static 修饰变量和修饰函数
操作系统：
a = 100 是否是原子操作？不是的话原因是什么？
死锁的概念，四个条件以及解决办法
网络的问了很多
send recv accept三个函数是干什么的
什么是阻塞的什么是非阻塞的
socket通信中哪些函数是阻塞的
了解多路复用吗？讲一下select poll epoll
DNS解析的过程
https获取数字证书的过程，以及进行加密通信的流程，问的比较详细
mysql:
主键索引和唯一索引和复合索引
为什么不是所有字段都加索引
算法：
没有手撕代码
问了快排的思路和平均时间复杂度，最差时间复杂度
还问了归并排序的思路和时间复杂度以及是否是稳定的。
问了LRU
让讲一下思路以及设计的过程中那些部门是需要考虑多线程安全的
（没让手撕代码太爽了）
问的挺多的，可能有个别不记得了。面试官很好（虽然戴口罩了，但是感觉挺帅的）
等了一周多才等来的二面
首先自我介绍，听到我说主要用的C++
就问了用98还是11比较多，我说都用，他就问11新特性用过哪些
我答lambda表达式，范围for，auto关键字，智能指针
让讲一下智能指针的原理，我blabla
提到了构造析构，什么时候会析构？blabla
然后问了一段代码编译的整个过程
讲完问我如果有两个函数：if() 调用函数A else 调用函数B
在编译的整个过程中怎么判断B被调用了
他自己举例子把打印的方法说了，让我再想个方法
我答了链接阶段的（不太会，瞎蒙）
问了我知道哪些抓包工具，我就答了一个
然后问我一个URL到网页渲染的整个过程（老八股了）
然后问我整个过程中有哪些地方是不安全的（八股变股）
我答了DNS劫持和DDos攻击，问我怎样防范（我给忘了贼尴尬）
后面问了linux平常会怎样检查程序的错误啥的（不太会，说我做的是网络相关的）
就问了HTTP/2.0的优势，我答他问还有吗，问到没有为止（我已经一头汗了）
然后问多线程了解吗
讲一下进程线程
问线程同步的方式，方式的适用场景
然后又问了进程间通信的方式，共享映射区是怎么共享的
大概40min,结束了，让我反问
面试官很幽默，聊的挺好，就是给我问一头汗
基本就是八股深挖或者延伸出一些问题，不知道为啥一句项目也没问，是觉得太LOW了吗哈哈哈哈
目前虾皮和网易面试体验并列第一，美团面试也比较专业，虽然可能答不出来，但是态度好让人没那么紧张，而且不会很难受
大家加油，我撤退了
Shopee面试
客户端开发岗

ㅤ普通",
【Shopee】客户端岗-还愿shopee！附iOS面经,"时间：3月24号，120mins
15道选择题，三道算法题
第一题AC，第二题90%，第三题70%。
时间:3月28号，持续40mins左右
一.自我介绍
 面试官问为什么选ios端(= =)
我解释一番以后，然后面试官直接来了一句”那感觉也没什么好问的” 🙁
瞬间感觉凉了。。。
二.数据结构与算法
1.二叉树
 二叉搜索树,平衡二叉树,红黑树,以及它们出现的背景、特点等
这里问了一句:红黑树有什么特点?（五大性质,不会…）
2.排序
 说出几个主流的排序算法,说了冒泡,插入,选择,希尔,快排,堆排,归并
说一下希尔排序实现原理?比起插入排序,希尔排序有什么特点?
三.计算机网络
1.TCP与UDP的区别
 老面试题了，TCP可靠，延迟高，首部开销大，只能点对点等说了一遍
2.TCP的可靠传输机制
 校验和、编号-确认-超时重传机制、滑动窗口、拥塞控制
每个部分都说明具体的实现原理，漏了一个校验和，面试官提醒我的
3.ICMP协议
 不记得了。。。就记得用于追踪路由和检查网络用的
四.操作系统
1.线程与进程的区别
老面试题了，从单位、独立性、通信、上下文切换等角度谈
2.切换线程时，线程的上下文有什么？
这题不常见，书上写得很含糊，网上搜也比较难得到一个确切的答案，我就说了程序计数器、寄存器、还有缓存里的数据
3.悲观锁与乐观锁
3.1问了两者的区别，然后细问乐观锁的实现：CAS
3.2CAS以外还有什么办法实现乐观锁吗？（我也不知道。。。，胡扯了一个机器指令lock前缀）
4.Linux里，fork()方法是如何节省空间的
懒加载机制，没答出来，后面查的
5.进程的调度策略
FCFS、轮转、SPN、SRT、HRRN、反馈
五.数据库
1.索引的作用
加快查询速度
2.什么情况下不该用索引
值单一的属性、修改频率远高于读的频率
3.索引为什么用的是B+树而不是B树、红黑树等
六.算法
只有一道，求数组的最大子数组之和
七.反问与感悟
1.面试哪里做得还不够好
2.什么时候出结果
面完了还以为自己铁定挂了，结果第二天晚上就发二面邀请了。。。面试官一开始那句话真的吓人
时间:4月2号，持续50mins左右
一.自我介绍
面试官又问为什么选ios端(= =)
二.计算机网络
1.三次握手
1.1三次握手的流程
三次握手的流程，一开始说的比较简单被打断，要求我说出跟报文段相关的字段（ACK,SYN,ack,seq等）
这里还提了一嘴：第三次握手时，客户端可以携带正式数据，如果不携带，那么seq跟第三次握手的seq一样
1.2第三次握手的必要性
防止服务器建立重复的连接
这里还顺便说了每一次握手都能够检验客户端或者服务器的接收功能或者发送功能是正常的
2.HTTP
2.1 手写：HTTP的GET请求格式
反手啪得一声就上来一道题目，很快啊
要我写出HTTP的GET报文段的格式。一开始不理解什么意思，后来说是写HTTP请求的首部段的格式，也就是请求方法，URL，HTTP版本那些的
后来问了一句，abc.xyz.com?x1=y1&x2=y2里，x1和x2存放到哪里？（这里我不会，就说不确定，好像是后端如apache的web服务器会根据url解析参数）
2.2 HTTP响应报文里的状态码
从1-5开头的状态码和大体上的分类说了一遍
2.3 TCP和UDP的区别
次次面试都会问。。。
2.4 TCP的可靠机制
同上，这些算是shopee必问了吧，每次都会问这些。。
分别讲了拥塞控制里的四大部分和滑动窗口的具体实现
三.操作系统
1.进程和线程的区别
感觉每次shopee面试都会问这个问题
2.用户态和内核态
定义，区别等
3.死锁的充分条件
互斥、占有且等待、不可抢占、循环等待
四.数据库
1.手写：建立个表
2.索引
索引的作用,索引的缺点
五.数据结构与算法
1.主流的排序算法以及对应的复杂度
说了个七七八八
2.快排的实现原理
枢纽+分治
六.其他
算法题的顺序并不是连续的，记得第一道算法题是穿插在面试中间的
1.第一道算法题
判断一棵树是否为平衡二叉树
2.第二道算法题
给定一个字符串，求最长不重复字符串
真是欧皇啊，面试前练手刚好就是这道题。。。希望这运气不是从别的面试身上拿来的。。。
3.指针与引用
写完算法题以后，面试官见我用c++，问我c++的引用和指针的区别
4.Java的GC
4.1 判断对象是否为可回收对象
引用计数法、可达性分析算法
4.2 GC算法
标记-清除、标记-复制、标记-整理
5.hr问题
平常怎么学习，怎么解决问题，怎么分工合作
七.反问与感悟
1.面试哪里做的不好的
面试官说都做得不错，没有哪里不好的，还笑了。。。（然后自己也偷偷笑了一把，以为稳了）
2.什么时候出结果
hr统一处理，反正肯定是清明放假回来后了
感觉这一次面试很灵活，面试官完全是根据我的回答或者细节来出题的，中间也是边回答问题边写代码
shopee ios二面算是我最好的一次面试了，仅仅有一个小细节不确定，其他的都能答出来
按照面试官的反映，感觉稳了，希望不要毒奶自己，等hr面
等了很久，第二周周五晚上终于打电话来了。。。
时间：4月9日 19：30 14mins
从清明放假就一直等结果，不停在牛客上看别人的结果，后来8号的时候我的同学收到了后端的hr电话，9号的时候我一直都没有等到电话。本来以为至少要等到下周了，结果刚要吃饭就打电话来了。。。
大概就是问了为什么选择shopee、为什么选择ios端、希望有什么工作环境、个人的优点、缺点等常规hr问题
OC
时间： 4月16日
感谢shopee对我的认可！太开心了，还愿！
助大家拿到自己的offer！
Shopee面试
客户端开发岗

ㅤ普通",
【Shopee】客户端岗-秋招的第一场面试,"无自我介绍，面试官读了半天简历，然后问了个简历上的实习经历是做啥的
场景题：
User(user_id, order_id), Product(product_id, price, category), Order(order_id, product_id, count) 三个数据库表，假设class已经建好了
sdk提供形如 get xxx by xxx的api，比如getOrdersByUserId就会返回一个Order对象的list，sdk通过请求服务端直接返回数据
需求：写一个函数，给定user_id，返回这个人购买的所有商品中哪个category花的钱最多
简单循环遍历，维护一个map累计每个category的花费，最后找最大值。不知道还能咋写。。
然后面试官问，请求api时需要请求服务端，如果有大量用户同时请求的话就可能承受不了，如何优化？
本地缓存+定期跟服务端校验数据完整性，下新订单时更新本地缓存。但个人感觉在本地缓存里面放这种东西给人感觉有点奇怪。。不过也想不出更好的办法了
算法题：
nesting depth加括号，312 -> (((3))1(2)), 221 -> ((22)1), 021 -> 0((2)1) 以前似乎shopee考过，也没啥算法，维护括号个数遍历就行了
操统：
虚拟内存作用，如果物理内存足够大能不能不用虚拟内存，如何保护内存不被恶意破坏
进程&线程，线程共享的资源，线程是不是越多越好
进程内存布局
系统设计：
假设你是Apple早期开发者，如何实现推送系统。
答APNS相关 -> APNS如何实现给指定设备推送 -> 确定设备唯一device id之后怎么推送 (不懂，查了下是长链接)
光知道有这么个东西大致是干啥的，早知道就复习一下APNS的细节了，亏得之前还是接触过的。。。凉凉
iOS相关：
UIView frames和bounds的区别（光知道区别，忘了哪个是哪个了，我说用的时候现查就行了。。）
OC如何实现内存管理 -> ARC -> 引用计数 -> 如何不用引用计数实现自动内存管理（不知道，gg）
反问：
介绍下Shopee的部门情况？确实新加坡是偏基架的，业务少，都用RN了
总结
秋招第一场面试，之前一直all in iOS看了一堆OC高级特性，甚至App crash&稳定性之类的东西，结果都没问。。(显然)
基础知识也没复习完，算法题也没怎么刷，答得也不咋地，感觉凉凉，希望不会被挂吧。。
update：7.17技术终面，竟然没挂
Shopee面试
客户端开发岗

ㅤ普通",
【Shopee】客户端岗-安卓SP专场,"面试官首先介绍shopee业务，他说他是金融部门的，做的相当于东南亚的支付宝
手撕：int数组里最大子序列和（用了动态规划，后面被面试官点出来发现并不需要dp数组）
java基础：
StringBulider和StringBuffer（区别、底层）
list、set、map
final、finally、finalize
equals、==、hashCode
线程创建
并行和并发
如何实现线程安全
volatile实现的内存结构
线程异常处理
Thread类的stop方法和interrupt方法
JDBC创建过程
union和unionAll的区别
有自己写过安卓吗（零基础。。。）
对象变量赋null，原对象会被马上回收吗
首先问我有没有了解安卓的基础，一面后有没有看过（当然。。没看过）
多线程安全问题
JVM内存模型
HTTPs与HTTP（区别、过程）
数字证书CA原理（没深入了解）
TCP与UDP
滑动窗口
TCP分片（回答了粘包和拆包，其实不然）
为什么选安卓–送命题（感觉说对安卓感兴趣太假了，所以就老实交待了）
面试官人很好，他说他之前都是面社招了，不太会问校招的问题，问的都比较偏基础一点，然后看我讲的比较细，后面就干脆不问了，跟我谈了十几分钟的人生，以过来人的身份给我说了很多经验，希望我不要太拘谨，放开一点，自信张扬一点，等到了30岁再收敛、谦逊一点也不迟。。。嗨。。。感慨一下我是真的老了。
收获还是挺多，感觉那大哥在团队里是一个挺有感染力的一个人，希望能进入下一轮！
Shopee面试
客户端开发岗

ㅤ普通",
Shopee面经汇总(按岗位划分),"大家好，我是帅地。
接下来一段时间，我会在这个专题收集 Shopee 相关面经，包括后端开发，前端开发，测试岗，算法岗，等等。
你可以通过这个专题，看看 Shopee 的面试官，都在问什么，并且帅地会尽力收集不同产品线的面经，顺便看看差别
Shopee Golang岗开发面经汇总
Shopee Golang岗开发面经汇总
Shopee 客户端岗开发面经汇总
Shopee 客户端岗开发面经汇总
Shopee 前端岗开发面经汇总
Shopee 前端岗开发面经汇总
Shopee C++岗开发面经汇总
Shopee C++岗开发面经汇总
Shopee Java岗开发面经汇总
Shopee Java岗开发面经汇总
C++面试题阅读指南（必看）
C++面试题阅读指南（必看）
 Java面试题面试题阅读指南（必看）
 Java面试题面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
Shopee面试
大厂面经",
使用 Spring 框架的好处是什么？,"轻量：Spring 是轻量的，基本的版本大约 2MB。
控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
容器：Spring 包含并管理应用中对象的生命周期和配置。
MVC框架：Spring 的 Web 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。
事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常
Sping面试题",
解释下什么是 AOP？,"AOP（Aspect-Oriented Programming，面向方面编程），可以说是 OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP 引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP 则显得无能为力。也就是说，OOP 允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如：安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在 OOP 设计中，它导致了大量代码的重复，而不利于各个模块的重用。
而 AOP 技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP 代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。
使用“横切”技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似。比如：权限认证、日志、事务处理。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。
Sping面试题",
AOP 的代理有哪几种方式？,"AOP 思想的实现一般都是基于代理模式 ，在 Java 中一般采用 JDK 动态代理模式，但是我们都知道，JDK 动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会按照下面两种情况进行切换，因为 Spring AOP 同时支持 CGLIB、ASPECTJ、JDK 动态代理。
如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；
如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类。不过这个选择过程对开发者完全透明、开发者也无需关心。
Sping面试题",
怎么实现 JDK 动态代理？,"JDK 动态代理最核心的一个接口和方法如下所示：
1. java.lang.reflect 包中的 InvocationHandler 接口：
对于被代理的类的操作都会由该接口中的 invoke 方法实现，其中的参数的含义分别是：
使用方法首先是需要实现该接口，并且我们可以在 invoke 方法中调用被代理类的方法并获得返回值，自然也可以在调用该方法的前后去做一些额外的事情，从而实现动态代理。
2. java.lang.reflect 包中的 Proxy 类中的 newProxyInstance 方法：
其中的参数含义如下：
interfaces：被代理类的接口数组；
invocationHandler：调用处理器类的对象实例
该方法会返回一个被修改过的类的实例，从而可以自由的调用该实例的方法
Sping面试题",
AOP 的基本概念：切面、连接点、切入点等？,"切面（Aspect）：官方的抽象定义为“一个关注点的模块化，这个关注点可能会横切多个对象”。
连接点（Joinpoint）：程序执行过程中的某一行为。
通知（Advice）：“切面”对于某个“连接点”所产生的动作。
切入点（Pointcut）：匹配连接点的断言，在 AOP 中通知和一个切入点表达式关联。
目标对象（Target Object）：被一个或者多个切面所通知的对象。
AOP 代理（AOP Proxy）：在 Spring AOP 中有两种代理方式，JDK 动态代理和 CGLIB 代理。
Sping面试题",
通知类型（Advice）型（Advice）有哪些？,"前置通知（Before advice）：在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行。ApplicationContext 中在 < aop:aspect > 里面使用 < aop:before > 元素进行声明；
后置通知（After advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。ApplicationContext 中在 < aop:aspect > 里面使用 < aop:after > 元素进行声明。
返回后通知（After return advice ：在某连接点正常完成后执行的通知，不包括抛出异常的情况。ApplicationContext 中在 < aop:aspect > 里面使用 << after-returning >> 元素进行声明。
环绕通知（Around advice）：包围一个连接点的通知，类似 Web 中 Servlet规范中的 Filter 的 doFilter 方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。ApplicationContext 中在 < aop:aspect > 里面使用  < aop:around > 元素进行声明。
抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。ApplicationContext 中在 < aop:aspect > 里面使用 < aop:after-throwing > 元素进行声明。
Sping面试题",
谈谈你对 IOC 的理解？,"IOC 是 Inversion of Control 的缩写，多数书籍翻译成“控制反转”。简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC 理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：

由于引进了中间位置的“第三方”，也就是 IOC 容器，使得 A、B、C、D 这 4 个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC 容器，所以，IOC 容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把 IOC 容器比喻成“粘合剂”的由来。　　
把上图中间的 IOC 容器拿掉，然后再来看看这套系统：

现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D 这 4 个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现 A 的时候，根本无须再去考虑 B、C 和 D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现 IOC 容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！
我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：
软件系统在没有引入 IOC 容器之前，对象 A 依赖于对象 B，那么对象 A 在初始化或者运行到某一点的时候，自己必须主动去创建对象 B 或者使用已经创建的对象 B。无论是创建还是使用对象 B，控制权都在自己手上。
软件系统在引入 IOC 容器之后，这种情形就完全改变了，由于 IOC 容器的加入，对象 A 与对象 B 之间失去了直接联系，所以，当对象 A 运行到需要对象 B 的时候，IOC 容器会主动创建一个对象 B 注入到对象 A 需要的地方。
通过前后的对比，我们不难看出来：对象 A 获得依赖对象 B 的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。
Sping面试题",
Bean 的生命周期？,"在传统的 Java 应用中，bean 的生命周期很简单，使用 Java 关键字 new 进行 Bean 的实例化，然后该 Bean 就能够使用了。一旦 Bean 不再被使用，则由 Java 自动进行垃圾回收。
相比之下，Spring 管理 Bean 的生命周期就复杂多了，正确理解 Bean 的生命周期非常重要，因为 Spring 对 Bean 的管理可扩展性非常强，下面展示了一个 Bean 的构造过程：

Spring 启动，查找并加载需要被 Spring 管理的 Bean，进行 Bean 的实例化；
Bean 实例化后，对 Bean 的引入和值注入到 Bean 的属性中；
如果 Bean 实现了 BeanNameAware 接口的话，Spring 将 Bean 的 Id 传递给 setBeanName() 方法；
如果 Bean 实现了 BeanFactoryAware 接口的话，Spring 将调用 setBeanFactory() 方法，将 BeanFactory 容器实例传入；
如果 Bean 实现了 ApplicationContextAware 接口的话，Spring 将调用 Bean 的 setApplicationContext() 方法，将 Bean 所在应用上下文引用传入进来；
如果 Bean 实现了 BeanPostProcessor 接口，Spring 就将调用它们的 postProcessBeforeInitialization() 方法；
如果 Bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet() 方法。类似地，如果 Bean 使用 init-method 声明了初始化方法，该方法也会被调用；
如果 Bean 实现了 BeanPostProcessor 接口，Spring 就将调用它们的 postProcessAfterInitialization() 方法；
此时，Bean 已经准备就绪，可以被应用程序使用了。它们将一直驻留在应用上下文中，直到应用上下文被销毁；
如果 Bean 实现了 DisposableBean 接口，Spring 将调用它的 destory() 接口方法，同样，如果 Bean 使用了 destory-method 声明销毁方法，该方法也会被调用。
Sping面试题",
Bean 的作用域?,"singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的；
prototype : 每次请求都会创建一个新的 bean 实例；
request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效；
session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效；
global-session：全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。
Sping面试题",
Spring 中的单例 Bean 的线程安全问题了解吗？,"大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。常见的有两种解决办法：
在 Bean 对象中尽量避免定义可变的成员变量（不太现实）。
在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。
Sping面试题",
谈谈你对 Spring 中的事务的理解？,"事务是逻辑上的一组操作，要么都执行，要么都不执行。
事务特性
原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性：执行事务前后，数据保持一致；
隔离性：并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；
持久性: 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
Spring 事务管理接口
TransactionDefinition：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）；
TransactionStatus：事务运行状态；
所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。
Sping面试题",
Spring 中的事务隔离级别？,"TransactionDefinition 接口中定义了五个表示隔离级别的常量：
TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别；
TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；
TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；
TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；
TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。
Sping面试题",
Spring 中的事物传播行为？,"事务传播行为是为了解决业务层方法之间互相调用的事务问题。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 TransactionDefinition 定义中包括了如下几个表示传播行为的常量：
TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务；
TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行；
TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起；
TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。
Sping面试题",
Spring 常用的注入方式有哪些？,"构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。
Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法实例化 bean 之后，调用该 bean 的 Setter 方法，即实现了基于 Setter 的依赖注入。
基于注解的注入：最好的解决方案是用构造器参数实现强制依赖，Setter 方法实现可选依赖。
Sping面试题",
Spring 框架中用到了哪些设计模式？,"工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象；
代理设计模式 : Spring AOP 功能的实现；
单例设计模式 : Spring 中的 Bean 默认都是单例的；
模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式；
包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源；
观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用；
适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式、SpringMVC 中也是用到了适配器模式适配 Controller。
Sping面试题",
ApplicationContext 通常的实现有哪些?,"FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。
ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。
WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 Web 应用的所有 bean。
Sping面试题",
Spring,"控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
容器：Spring 包含并管理应用中对象的生命周期和配置。
MVC框架：Spring 的 Web 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。
事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常
AOP（Aspect-Oriented Programming，面向方面编程），可以说是 OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP 引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP 则显得无能为力。也就是说，OOP 允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如：安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在 OOP 设计中，它导致了大量代码的重复，而不利于各个模块的重用。
而 AOP 技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP 代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。
使用“横切”技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似。比如：权限认证、日志、事务处理。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。
AOP 思想的实现一般都是基于代理模式 ，在 Java 中一般采用 JDK 动态代理模式，但是我们都知道，JDK 动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会按照下面两种情况进行切换，因为 Spring AOP 同时支持 CGLIB、ASPECTJ、JDK 动态代理。
如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类。不过这个选择过程对开发者完全透明、开发者也无需关心。
JDK 动态代理最核心的一个接口和方法如下所示：
1. java.lang.reflect 包中的 InvocationHandler 接口：
“`java
public interface InvocationHandler {
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
 “`
对于被代理的类的操作都会由该接口中的 invoke 方法实现，其中的参数的含义分别是：
使用方法首先是需要实现该接口，并且我们可以在 invoke 方法中调用被代理类的方法并获得返回值，自然也可以在调用该方法的前后去做一些额外的事情，从而实现动态代理。
2. java.lang.reflect 包中的 Proxy 类中的 newProxyInstance 方法：
“`java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException
 “`
其中的参数含义如下：
interfaces：被代理类的接口数组；
invocationHandler：调用处理器类的对象实例
该方法会返回一个被修改过的类的实例，从而可以自由的调用该实例的方法
连接点（Joinpoint）：程序执行过程中的某一行为。
通知（Advice）：“切面”对于某个“连接点”所产生的动作。
切入点（Pointcut）：匹配连接点的断言，在 AOP 中通知和一个切入点表达式关联。
目标对象（Target Object）：被一个或者多个切面所通知的对象。
AOP 代理（AOP Proxy）：在 Spring AOP 中有两种代理方式，JDK 动态代理和 CGLIB 代理。
前置通知（Before advice）：在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行。ApplicationContext 中在  里面使用  元素进行声明；
后置通知（After advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。ApplicationContext 中在  里面使用  元素进行声明。
返回后通知（After return advice ：在某连接点正常完成后执行的通知，不包括抛出异常的情况。ApplicationContext 中在  里面使用 <> 元素进行声明。
环绕通知（Around advice）：包围一个连接点的通知，类似 Web 中 Servlet规范中的 Filter 的 doFilter 方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。ApplicationContext 中在  里面使用  元素进行声明。
抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。ApplicationContext 中在  里面使用  元素进行声明。
IOC 是 Inversion of Control 的缩写，多数书籍翻译成“控制反转”。简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC 理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：

由于引进了中间位置的“第三方”，也就是 IOC 容器，使得 A、B、C、D 这 4 个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC 容器，所以，IOC 容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把 IOC 容器比喻成“粘合剂”的由来。　　
把上图中间的 IOC 容器拿掉，然后再来看看这套系统：

现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D 这 4 个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现 A 的时候，根本无须再去考虑 B、C 和 D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现 IOC 容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！
我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：
软件系统在没有引入 IOC 容器之前，对象 A 依赖于对象 B，那么对象 A 在初始化或者运行到某一点的时候，自己必须主动去创建对象 B 或者使用已经创建的对象 B。无论是创建还是使用对象 B，控制权都在自己手上。
软件系统在引入 IOC 容器之后，这种情形就完全改变了，由于 IOC 容器的加入，对象 A 与对象 B 之间失去了直接联系，所以，当对象 A 运行到需要对象 B 的时候，IOC 容器会主动创建一个对象 B 注入到对象 A 需要的地方。
通过前后的对比，我们不难看出来：对象 A 获得依赖对象 B 的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。
在传统的 Java 应用中，bean 的生命周期很简单，使用 Java 关键字 new 进行 Bean 的实例化，然后该 Bean 就能够使用了。一旦 Bean 不再被使用，则由 Java 自动进行垃圾回收。
相比之下，Spring 管理 Bean 的生命周期就复杂多了，正确理解 Bean 的生命周期非常重要，因为 Spring 对 Bean 的管理可扩展性非常强，下面展示了一个 Bean 的构造过程：

Bean 实例化后，对 Bean 的引入和值注入到 Bean 的属性中；
如果 Bean 实现了 BeanNameAware 接口的话，Spring 将 Bean 的 Id 传递给 setBeanName() 方法；
如果 Bean 实现了 BeanFactoryAware 接口的话，Spring 将调用 setBeanFactory() 方法，将 BeanFactory 容器实例传入；
如果 Bean 实现了 ApplicationContextAware 接口的话，Spring 将调用 Bean 的 setApplicationContext() 方法，将 Bean 所在应用上下文引用传入进来；
如果 Bean 实现了 BeanPostProcessor 接口，Spring 就将调用它们的 postProcessBeforeInitialization() 方法；
如果 Bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet() 方法。类似地，如果 Bean 使用 init-method 声明了初始化方法，该方法也会被调用；
如果 Bean 实现了 BeanPostProcessor 接口，Spring 就将调用它们的 postProcessAfterInitialization() 方法；
此时，Bean 已经准备就绪，可以被应用程序使用了。它们将一直驻留在应用上下文中，直到应用上下文被销毁；
如果 Bean 实现了 DisposableBean 接口，Spring 将调用它的 destory() 接口方法，同样，如果 Bean 使用了 destory-method 声明销毁方法，该方法也会被调用。
singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的；
prototype : 每次请求都会创建一个新的 bean 实例；
request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效；
session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效；
global-session：全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。
大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。常见的有两种解决办法：
在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。
事务是逻辑上的一组操作，要么都执行，要么都不执行。
事务特性
原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性：执行事务前后，数据保持一致；
隔离性：并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；
持久性: 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
Spring 事务管理接口
TransactionDefinition：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）；
TransactionStatus：事务运行状态；
所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。
TransactionDefinition 接口中定义了五个表示隔离级别的常量：
TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别；
TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；
TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；
TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；
TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。
事务传播行为是为了解决业务层方法之间互相调用的事务问题。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 TransactionDefinition 定义中包括了如下几个表示传播行为的常量：
TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务；
TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行；
TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起；
TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。
构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。
Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法实例化 bean 之后，调用该 bean 的 Setter 方法，即实现了基于 Setter 的依赖注入。
基于注解的注入：最好的解决方案是用构造器参数实现强制依赖，Setter 方法实现可选依赖。
工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象；
代理设计模式 : Spring AOP 功能的实现；
单例设计模式 : Spring 中的 Bean 默认都是单例的；
模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式；
包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源；
观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用；
适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式、SpringMVC 中也是用到了适配器模式适配 Controller。
FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。
ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。
WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 Web 应用的所有 bean。
Sping面试题",
谈谈你对 MVC 模式的理解？,"MVC 是 Model — View — Controler 的简称，它是一种架构模式，它分离了表现与交互。它被分为三个核心部件：模型、视图、控制器。

Model（模型）：是程序的主体部分，主要包含业务数据和业务逻辑。在模型层，还会涉及到用户发布的服务，在服务中会根据不同的业务需求，更新业务模型中的数据。
View（视图）：是程序呈现给用户的部分，是用户和程序交互的接口，用户会根据具体的业务需求，在 View 视图层输入自己特定的业务数据，并通过界面的事件交互，将对应的输入参数提交给后台控制器进行处理。
Controller（控制器）：Controller 是用来处理用户输入数据，以及更新业务模型的部分。控制器中接收了用户与界面交互时传递过来的数据，并根据数据业务逻辑来执行服务的调用和更新业务模型的数据和状态。
SpringMVC面试题",
SpringMVC 的工作原理/执行流程？,"简单来说：客户端发送请求-> 前端控制器 DispatcherServlet 接受客户端请求 -> 找到处理器映射 HandlerMapping 解析请求对应的 Handler -> HandlerAdapter 会根据 Handler 来调用真正的处理器来处理请求，并处理相应的业务逻辑 -> 处理器返回一个模型视图 ModelAndView -> 视图解析器进行解析 -> 返回一个视图对象 -> 前端控制器 DispatcherServlet 渲染数据（Model）-> 将得到视图对象返回给用户。

上图用于辅助理解，面试时可用下列 8 步描述 SpringMVC 运行流程：
DispatcherServlet 对请求 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以 HandlerExecutionChain 对象的形式返回；
DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 preHandler(…)方法）
提取 Request 中的模型数据，填充 Handler 入参，开始执行Handler（Controller)。在填充 Handler 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：
（1）HttpMessageConveter：将请求消息（如：Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息；
（2）数据转换：对请求消息进行数据转换。如：String 转换成 Integer、Double 等；
（3）数据格式化：对请求消息进行数据格式化。如：将字符串转换成格式化数字或格式化日期等；
（4）数据验证：验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中;
Handler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；
根据返回的 ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)返回给DispatcherServlet；
ViewResolver 结合 Model 和 View，来渲染视图；
将渲染结果返回给客户端。
SpringMVC面试题",
SpringMVC 的核心组件有哪些？,"作用：Spring MVC 的入口函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。
作用：根据请求的 url 查找 Handler。HandlerMapping 负责根据用户请求找到 Handler 即处理器（Controller），SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。
作用：按照特定规则（HandlerAdapter 要求的规则）去执行 Handler。通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。
注意：编写 Handler 时按照 HandlerAdapter 的要求去做，这样适配器才可以去正确执行 Handler。Handler 是继 DispatcherServlet 前端控制器的后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。由于 Handler 涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发 Handler。
作用：进行视图解析，根据逻辑视图名解析成真正的视图（View ）。View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。
View 是一个接口，实现类支持不同的 View 类型（jsp、freemarker…）。

  注意：处理器 Handler（也就是我们平常说的 Controller 控制器）以及视图层 View 都是需要我们自己手动开发的。其他的一些组件比如：前端控制器 DispatcherServlet、处理器映射器 HandlerMapping、处理器适配器 HandlerAdapter 等等都是框架提供给我们的，不需要自己手动开发。

SpringMVC面试题",
SpringMVC 常用的注解有哪些？,"@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径；
@RequestBody：注解实现接收 HTTP 请求的 json 数据，将 json 转换为 Java 对象；
@ResponseBody：注解实现将 Controller 方法返回对象转化为 json 对象响应给客户。
SpringMVC面试题",
@RequestMapping 的作用是什么？,"RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。RequestMapping 注解有六个属性，下面我们把它分成三类进行说明。
value、method：
method：指定请求的method类型， GET、POST、PUT、DELETE 等；
consumes、produces：
produces：指定返回的内容类型，仅当 request 请求头中的（Accept）类型中包含该指定类型才返回；
params、header：
params：指定 request 中必须包含某些参数值是，才让该方法处理。
headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。
SpringMVC面试题",
如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？,"1.解决 POST 请求乱码问题：在 web.xml 中配置一个 CharacterEncodingFilter 过滤器，设置成 utf-8；
（1）修改 tomcat 配置文件添加编码与工程编码一致，如下：
“`java
<ConnectorURIEncoding=""utf-8"" connectionTimeout=""20000"" port=""8080"" protocol=""HTTP/1.1"" redirectPort
 “`
（2）对参数进行重新编码：
“`java
String userName = new String(request.getParamter(""userName"").getBytes(""ISO8859-1""),""utf-8"")
 “`
SpringMVC面试题",
SpringMVC 的控制器是不是单例模式，如果是会有什么问题，怎么解决？,"是单例模式，所以在多线程访问的时候有线程安全问题。但是不要使用同步，会影响性能，解决方案是在控制器里面不能写字段。
SpringMVC面试题",
SpringMVC 怎么样设定重定向和转发的？,"“`java
</p></li>
<li>重定向：在返回值前面加 ""redirect:""，譬如：
“`

SpringMVC面试题",
SpringMVC 里面拦截器是怎么写的？,"方法一：实现 HandlerInterceptor 接口；
方法二：继承适配器类，接着在接口方法当中，实现处理逻辑，然后在 SpringMVC 的配置文件中配置拦截器即可。
SpringMVC面试题",
SpringMVC 和 Struts2 的区别有哪些?,"SpringMVC 的入口是一个 Servlet 即前端控制器（DispatchServlet），而 Struts2 入口是一个 filter 过虑器（StrutsPrepareAndExecuteFilter）；
SpringMVC 是基于方法开发（一个 url 对应一个方法），请求参数传递到方法的形参，可以设计为单例或多例（建议单例），Struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例；
Struts2 采用值栈存储请求和响应的数据，通过 OGNL 存取数据；SpringMVC 通过参数解析器是将 request 请求内容解析，并给方法形参赋值，将数据和视图封装成 ModelAndView 对象，最后又将 ModelAndView 中的模型数据通过 request 域传输到页面。jsp 视图解析器默认使用 jstl。
SpringMVC面试题",
SpringMVC,"MVC 是 Model — View — Controller 的简称，它是一种架构模式，它分离了表现与交互。它被分为三个核心部件：模型、视图、控制器。

Model（模型）：是程序的主体部分，主要包含业务数据和业务逻辑。在模型层，还会涉及到用户发布的服务，在服务中会根据不同的业务需求，更新业务模型中的数据。
View（视图）：是程序呈现给用户的部分，是用户和程序交互的接口，用户会根据具体的业务需求，在 View 视图层输入自己特定的业务数据，并通过界面的事件交互，将对应的输入参数提交给后台控制器进行处理。
Controller（控制器）：Controller 是用来处理用户输入数据，以及更新业务模型的部分。控制器中接收了用户与界面交互时传递过来的数据，并根据数据业务逻辑来执行服务的调用和更新业务模型的数据和状态。
简单来说：客户端发送请求-> 前端控制器 DispatcherServlet 接受客户端请求 -> 找到处理器映射 HandlerMapping 解析请求对应的 Handler -> HandlerAdapter 会根据 Handler 来调用真正的处理器来处理请求，并处理相应的业务逻辑 -> 处理器返回一个模型视图 ModelAndView -> 视图解析器进行解析 -> 返回一个视图对象 -> 前端控制器 DispatcherServlet 渲染数据（Model）-> 将得到视图对象返回给用户。

上图用于辅助理解，面试时可用下列 8 步描述 SpringMVC 运行流程：
DispatcherServlet 对请求 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以 HandlerExecutionChain 对象的形式返回；
DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 preHandler(…)方法）
提取 Request 中的模型数据，填充 Handler 入参，开始执行Handler（Controller)。在填充 Handler 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：
（1）HttpMessageConveter：将请求消息（如：Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息；
（2）数据转换：对请求消息进行数据转换。如：String 转换成 Integer、Double 等；
（3）数据格式化：对请求消息进行数据格式化。如：将字符串转换成格式化数字或格式化日期等；
（4）数据验证：验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中;
根据返回的 ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)返回给DispatcherServlet；
ViewResolver 结合 Model 和 View，来渲染视图；
将渲染结果返回给客户端。
作用：Spring MVC 的入口函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。
作用：根据请求的 url 查找 Handler。HandlerMapping 负责根据用户请求找到 Handler 即处理器（Controller），SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。
作用：按照特定规则（HandlerAdapter 要求的规则）去执行 Handler。通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。
注意：编写 Handler 时按照 HandlerAdapter 的要求去做，这样适配器才可以去正确执行 Handler。Handler 是继 DispatcherServlet 前端控制器的后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。由于 Handler 涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发 Handler。
作用：进行视图解析，根据逻辑视图名解析成真正的视图（View ）。View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。
View 是一个接口，实现类支持不同的 View 类型（jsp、freemarker…）。

  注意：处理器 Handler（也就是我们平常说的 Controller 控制器）以及视图层 View 都是需要我们自己手动开发的。其他的一些组件比如：前端控制器 DispatcherServlet、处理器映射器 HandlerMapping、处理器适配器 HandlerAdapter 等等都是框架提供给我们的，不需要自己手动开发。

@RequestBody：注解实现接收 HTTP 请求的 json 数据，将 json 转换为 Java 对象；
@ResponseBody：注解实现将 Controller 方法返回对象转化为 json 对象响应给客户。
RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。RequestMapping 注解有六个属性，下面我们把它分成三类进行说明。
value、method：
method：指定请求的method类型， GET、POST、PUT、DELETE 等；
consumes、produces：
produces：指定返回的内容类型，仅当 request 请求头中的（Accept）类型中包含该指定类型才返回；
params、header：
headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。
1.解决 POST 请求乱码问题：在 web.xml 中配置一个 CharacterEncodingFilter 过滤器，设置成 utf-8；
（1）修改 tomcat 配置文件添加编码与工程编码一致，如下：
“`java
<ConnectorURIEncoding=""utf-8"" connectionTimeout=""20000"" port=""8080"" protocol=""HTTP/1.1"" redirectPort
 “`
（2）对参数进行重新编码：
“`java
String userName = new String(request.getParamter(""userName"").getBytes(""ISO8859-1""),""utf-8"")
 “`
是单例模式，所以在多线程访问的时候有线程安全问题。但是不要使用同步，会影响性能，解决方案是在控制器里面不能写字段。
“`java
</p></li>
<li>重定向：在返回值前面加 ""redirect:""，譬如：
“`

方法一：实现 HandlerInterceptor 接口；
方法二：继承适配器类，接着在接口方法当中，实现处理逻辑，然后在 SpringMVC 的配置文件中配置拦截器即可。
SpringMVC 的入口是一个 Servlet 即前端控制器（DispatchServlet），而 Struts2 入口是一个 filter 过虑器（StrutsPrepareAndExecuteFilter）；
SpringMVC 是基于方法开发（一个 url 对应一个方法），请求参数传递到方法的形参，可以设计为单例或多例（建议单例），Struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例；
Struts2 采用值栈存储请求和响应的数据，通过 OGNL 存取数据；SpringMVC 通过参数解析器是将 request 请求内容解析，并给方法形参赋值，将数据和视图封装成 ModelAndView 对象，最后又将 ModelAndView 中的模型数据通过 request 域传输到页面。jsp 视图解析器默认使用 jstl。
SpringMVC面试题",
SpringMVC面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 谈谈你对 MVC 模式的理解？
1. 谈谈你对 MVC 模式的理解？
2. SpringMVC 的工作原理/执行流程？
2. SpringMVC 的工作原理/执行流程？
3. SpringMVC 的核心组件有哪些？
3. SpringMVC 的核心组件有哪些？
4. SpringMVC 常用的注解有哪些？
4. SpringMVC 常用的注解有哪些？
5. @RequestMapping 的作用是什么？
5. @RequestMapping 的作用是什么？
6. 如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？
6. 如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？
7. SpringMVC 的控制器是不是单例模式，如果是会有什么问题，怎么解决？
7. SpringMVC 的控制器是不是单例模式，如果是会有什么问题，怎么解决？
8. SpringMVC 怎么样设定重定向和转发的？
8. SpringMVC 怎么样设定重定向和转发的？
9. SpringMVC 里面拦截器是怎么写的？
9. SpringMVC 里面拦截器是怎么写的？
10. SpringMVC 和 Struts2 的区别有哪些?
10. SpringMVC 和 Struts2 的区别有哪些?
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
SpringMVC面试题",
Spring面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 使用 Spring 框架的好处是什么？
1. 使用 Spring 框架的好处是什么？
2. 解释下什么是 AOP？
2. 解释下什么是 AOP？
3. AOP 的代理有哪几种方式？
3. AOP 的代理有哪几种方式？
4. 怎么实现 JDK 动态代理？
4. 怎么实现 JDK 动态代理？
5. AOP 的基本概念：切面、连接点、切入点等？
5. AOP 的基本概念：切面、连接点、切入点等？
6. 通知类型（Advice）型（Advice）有哪些？
6. 通知类型（Advice）型（Advice）有哪些？
7. 谈谈你对 IOC 的理解？
7. 谈谈你对 IOC 的理解？
8. Bean 的生命周期？
8. Bean 的生命周期？
9. Bean 的作用域?
9. Bean 的作用域?
10. 谈谈你对 Spring 中的事物的理解？
10. 谈谈你对 Spring 中的事物的理解？
11. Spring 中的事务隔离级别？
11. Spring 中的事务隔离级别？
12. Spring 中的事物传播行为？
12. Spring 中的事物传播行为？
13. Spring 常用的注入方式有哪些？
13. Spring 常用的注入方式有哪些？
14. ApplicationContext 通常的实现有哪些?
14. ApplicationContext 通常的实现有哪些?
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
Spring面试题",
Vue基础面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. vue 组件通讯方式有哪些方法
1. vue 组件通讯方式有哪些方法
2. Vue 响应式原理
2. Vue 响应式原理
3. Vue nextTick 原理
3. Vue nextTick 原理
4. 手写 Vue.extend 实现
4. 手写 Vue.extend 实现
5. 什么是 MVVM
5. 什么是 MVVM
6. mvvm 与 mvc 区别 它和其它框架（jquery）的区别是什么 哪些场景适用
6. mvvm 与 mvc 区别 它和其它框架（jquery）的区别是什么 哪些场景适用
7. vue.cli 中怎样使用自定义组件 遇到过哪些问题
7. vue.cli 中怎样使用自定义组件 遇到过哪些问题
8. Vue的双向数据绑定原理是什么
8. Vue的双向数据绑定原理是什么
9. 详细说下你对vue生命周期的理解
9. 详细说下你对vue生命周期的理解
10. vue.cli中怎样使用自定义的组件 有遇到过哪些问题吗
10. vue.cli中怎样使用自定义的组件 有遇到过哪些问题吗
11. vue是渐进式的框架的理解
11. vue是渐进式的框架的理解
12. vue中子组件调用父组件的方法
12. vue中子组件调用父组件的方法
13. vue中 keep-alive 组件的作用
13. vue中 keep-alive 组件的作用
14. vue等单页面应用优缺点
14. vue等单页面应用优缺点
15. Vue 如何去除url中的 #
15. Vue 如何去除url中的 #
16. Vue 响应式原理
16. Vue 响应式原理
17. computed 的实现原理
17. computed 的实现原理
18. computed 和 watch 有什么区别及运用场景
18. computed 和 watch 有什么区别及运用场景
19. 为什么在 Vue3.0 采用了 Proxy,抛弃了Object.defineProperty
19. 为什么在 Vue3.0 采用了 Proxy,抛弃了Object.defineProperty
20. Vue 中的 key 到底有什么用
20. Vue 中的 key 到底有什么用
21. 谈一谈 nextTick 的原理
21. 谈一谈 nextTick 的原理
22. Vue 组件 data 为什么必须是函数
22. Vue 组件 data 为什么必须是函数
23. 说说 Vue 的渲染过程
23. 说说 Vue 的渲染过程
24. 简述每个周期具体适合哪些场景
24. 简述每个周期具体适合哪些场景
25. 什么是vue-router
25. 什么是vue-router
26. Vue2.x和Vue3.x渲染器的diff算法分别说一下
26. Vue2.x和Vue3.x渲染器的diff算法分别说一下
27. 说一下虚拟Dom以及key属性的作用
27. 说一下虚拟Dom以及key属性的作用
28. Vue模版编译原理知道吗，能简单说一下吗
28. Vue模版编译原理知道吗，能简单说一下吗
29. keep-alive了解吗
29. keep-alive了解吗
30. Vue2.x组件通信有哪些方式
30. Vue2.x组件通信有哪些方式
31. computed 的实现原理
31. computed 的实现原理
32. Computed和Watch的区别
32. Computed和Watch的区别
33. slot是什么 有什么作用 原理是什么
33. slot是什么 有什么作用 原理是什么
34. $nextTick 原理及作用
34. $nextTick 原理及作用
35. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么 如何解决
35. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么 如何解决
36. Vue 单页应用与多页应用的区别
36. Vue 单页应用与多页应用的区别
37. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗
37. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗
38. 子组件可以直接改变父组件的数据吗
38. 子组件可以直接改变父组件的数据吗
39. 说一下对 React 和 Vue 的理解，它们的异同
39. 说一下对 React 和 Vue 的理解，它们的异同
40. Vue的优点
40. Vue的优点
41. Vue模版编译原理
41. Vue模版编译原理
42. 对SSR的理解
42. 对SSR的理解
43. Vue的性能优化有哪些
43. Vue的性能优化有哪些
44. 对 SPA 单页面的理解，它的优缺点分别是什么
44. 对 SPA 单页面的理解，它的优缺点分别是什么
45. Vue 子组件和父组件执行顺序
45. Vue 子组件和父组件执行顺序
46. Vue-Router 的懒加载如何实现
46. Vue-Router 的懒加载如何实现
47. 路由的hash和history模式的区别
47. 路由的hash和history模式的区别
48. 使用 Object.defineProperty() 来进行数据劫持有什么缺点
48. 使用 Object.defineProperty() 来进行数据劫持有什么缺点
49. Vue-router跳转和location.href有什么区别
49. Vue-router跳转和location.href有什么区别
50. 对前端路由的理解
50. 对前端路由的理解
51. Redux 和 Vuex 有什么区别，它们的共同思想
51. Redux 和 Vuex 有什么区别，它们的共同思想
52. 为什么 Vuex 的 mutation 中不能做异步操作
52. 为什么 Vuex 的 mutation 中不能做异步操作
53. Vue3.0有什么更新
53. Vue3.0有什么更新
54. defineProperty和proxy的区别
54. defineProperty和proxy的区别
Vue面试题

ㅤ普通",
vue 组件通讯方式有哪些方法,"Vue面试题

ㅤ普通",
Vue 响应式原理,"整体思路是数据劫持+观察者模式
对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。
Vue面试题

ㅤ普通",
Vue nextTick 原理,"nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法
Vue面试题

ㅤ普通",
手写 Vue.extend 实现,"Vue面试题

ㅤ普通",
什么是 MVVM,"MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。
在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。
Vue面试题

ㅤ普通",
mvvm 与 mvc 区别 它和其它框架（jquery）的区别是什么 哪些场景适用,"mvc和mvvm其实区别并不大，都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
区别：vue数据驱动，通过数据来显示视图层而不是节点操作。
场景：数据操作比较多、频繁的场景，更加便捷。
Vue面试题

ㅤ普通",
vue.cli 中怎样使用自定义组件 遇到过哪些问题,"第一步：在components目录新建组件文件（indexPage.vue），script一定要export default {}。
第二步：在需要用的页面（组件）中导入：import indexPage from ‘@/components/indexPage.vue’
第三步：注入到vue子组件的components属性上面,components:{indexPage}
第四步：在template视图view中使用，例如有indexPage命名，使用的时候则index-page。
Vue面试题

ㅤ普通",
Vue的双向数据绑定原理是什么,"vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
具体步骤：
第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个update()方法
3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。
Vue面试题

ㅤ普通",
详细说下你对vue生命周期的理解,"总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。
创建前后：在beforeCreated阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。
载入前后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。
更新前后：当data变化时，会触发beforeUpdate和updated方法。
销毁前后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在
Vue面试题

ㅤ普通",
vue是渐进式的框架的理解,"Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。如下图所示，这里包含了Vue的所有部件，在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念
在我看来，渐进式代表的含义是：主张最少。视图模板引擎每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。
比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：
必须使用它的模块机制
必须使用它的依赖注入
必须使用它的特殊
形式定义组件（这一点每个视图框架都有，难以避免）所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。
Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。渐进式的含义，我的理解是：没有多做职责之外的事。
Vue面试题

ㅤ普通",
vue中子组件调用父组件的方法,"第一种方法是直接在子组件中通过this.parent.event来调用父组件的方法
第二种方法是在子组件里用emit向父组件触发一个事件，父组件监听这个事件就行了。
第三种都可以实现子组件调用父组件的方法，
Vue面试题

ㅤ普通",
vue中 keep-alive 组件的作用,"keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
Vue面试题

ㅤ普通",
vue等单页面应用优缺点,"优点
Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。
缺点
Vue面试题

ㅤ普通",
Vue 如何去除url中的 #,"vue-router默认使用hash模式，所以在路由加载的时候，项目中的url会自带#。如果不想使用#， 可以使用vue-router的另一种模式history

  需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面

Vue面试题

ㅤ普通",
Vue 响应式原理,"核心实现类:
Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新
Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。
Watcher : 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种
Watcher 和 Dep 的关系
watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。
依赖收集
initState 时,对侦听属性初始化时,触发 user watcher 依赖收集
render()的过程,触发 render watcher 依赖收集
re-render 时,vm.render()再次执行,会移除所有 subs 中的 watcer 的订阅,重新赋值。
派发更新
原理
当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。
每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。
一句话总结:
vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动
时发布消息给订阅者,触发响应的监听回调
Vue面试题

ㅤ普通",
computed 的实现原理,"computed 本质是一个惰性求值的观察者。computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。其内部通过 this.dirty 属性标记计算属性是否需要重新求值。当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,computed watcher 通过 this.dep.subs.length 判断有没有订阅者,
有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)
没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)
Vue面试题

ㅤ普通",
"为什么在 Vue3.0 采用了 Proxy,抛弃了Object.defineProperty","Object.defineProperty 本身有一定的监控到数组下标变化的能力,但是在 Vue 中,从性能/体验的性价比考虑,尤大大就弃用了这个特性(Vue 为什么不能检测数组变动 )。为了解决这个问题,经过 vue 内部处理后可以使用以下几种方法来监听数组
由于只针对了以上 7 种方法进行了 hack 处理,所以其他数组的属性也是检测不到的,还是具有一定的局限性。
Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x 里,是通过 递归 + 遍历 data 对象来实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。Proxy 可以劫持整个对象,并返回一个新的对象。Proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。
Vue面试题

ㅤ普通",
Vue 中的 key 到底有什么用,"key 是给每一个 vnode 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速 (对于简单列表页渲染来说 diff 节点也更快,但会产生一些隐藏的副作用,比如可能不会产生过渡效果,或者在某些节点有绑定数据（表单）状态，会出现状态错位。)
diff 算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的 key 与旧节点进行比对,从而找到相应旧节点.
更准确 : 因为带 key 就不是就地复用了,在 sameNode 函数 a.key '===' b.key 对比中可以避免就地复用的情况。所以会更加准确,如果不加 key,会导致之前节点的状态被保留下来,会产生一系列的 bug。更快速 : key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1),源码如下:
Vue面试题

ㅤ普通",
谈一谈 nextTick 的原理,"JS 运行机制
JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤:
所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。主线程不断重复上面的第三步。

主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task)。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。
在浏览器环境中 :
常见的 macro task 有 etTimeout、MessageChannel、postMessage、setImmediate
常见的 micro task 有 MutationObsever 和 Promise.then
异步更新队列
可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。
Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。在 vue2.5 的源码中，macrotask 降级的方案依次是：setImmediate、MessageChannel、setTimeout
vue 的 nextTick 方法的实现原理:
vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕。考虑兼容问题,vue 做了 microtask 向 macrotask 的降级方案
Vue面试题

ㅤ普通",
Vue 组件 data 为什么必须是函数,"new Vue()实例中,data 可以直接是一个对象,为什么在 vue 组件中,data 必须是一个函数呢?
因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。
Vue面试题

ㅤ普通",
说说 Vue 的渲染过程,"调用 compile 函数,生成 render 函数字符串 ,编译过程如下:parse 函数解析 template,生成 ast(抽象语法树)optimize 函数优化静态节点 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从而减少比较的过程,优化了 patch 的性能)generate 函数生成 render 函数字符串调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素
Vue面试题

ㅤ普通",
简述每个周期具体适合哪些场景,"beforeCreate： 在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。在beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法
create： data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作
beforeMount： 执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的
mounted： 执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行
beforeUpdate： 当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步
updated： 页面显示的数据和data中的数据已经保持同步了，都是最新的
beforeDestory： Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁
destroyed： 这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。
Vue面试题

ㅤ普通",
什么是vue-router,"Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：
Vue面试题

ㅤ普通",
Vue2.x和Vue3.x渲染器的diff算法分别说一下,"简单来说，diff算法有以下过程
同级比较，再比较子节点先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
比较都有子节点的情况(核心diff)
递归比较子节点
正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -> O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。
Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，
减少不必要的性能损耗，更加的优雅。
Vue3.x借鉴了ivi算法和 inferno算法
在创建VNode时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)
该算法中还运用了动态规划的思想求解最长递归子序列。
(看到这你还会发现，框架内无处不蕴藏着数据结构和算法的魅力)
Vue面试题

ㅤ普通",
说一下虚拟Dom以及key属性的作用,"由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的产生原因。Vue2的Virtual DOM借鉴了开源库snabbdom的实现。
Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。(也就是源码中的VNode类，它定义在src/core/vdom/vnode.js中。)
VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。
key的作用是尽可能的复用 DOM 元素。
新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。
需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。
Vue面试题

ㅤ普通",
Vue模版编译原理知道吗，能简单说一下吗,"简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段：
生成AST树
优化
codegen
首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。
使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。
Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。
编译的最后一步是将优化后的AST树转换为可执行的
Vue面试题

ㅤ普通",
keep-alive了解吗,"keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。
常用的两个属性include/exclude，允许组件有条件的进行缓存。
两个生命周期activated/deactivated，用来得知当前组件是否处于
活跃状态。
keep-alive的中还运用了LRU(Least Recently Used)算法。
（又是数据结构与算法，原来算法在前端也有这么多的应用）
Vue面试题

ㅤ普通",
Vue2.x组件通信有哪些方式,"父子组件通信
父->子props，子->父 on、emit
获取父子组件实例 parent、children
Ref 获取实例的方式调用组件的属性或者方法
Provide、inject 官方不推荐使用，但是写组件库时很常用
兄弟组件通信
Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue
Vuex
跨级组件通信
Vuex
attrs、listeners
Provide、inject
Vue面试题

ㅤ普通",
computed 的实现原理,"computed 本质是一个惰性求值的观察者。
computed 内部实现了一个惰性的 watcher,也就是 computed
watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。
内部通过 this.dirty 属性标记计算属性是否需要重新求值。当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,computed watcher 通过 this.dep.subs.length 判断有没有订阅者,有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)
没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)
Vue面试题

ㅤ普通",
Computed和Watch的区别,"对于Computed：
不支持异步，当Computed中有异步操作时，无法监听数据的变化
computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。
如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed
如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。
对于Watch：
支持异步监听
监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值
当一个属性发生变化时，就需要执行相应的操作
监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会出大其他操作，函数有两个的参数：
deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。
当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。
总结：
watch 侦听器 : 更多的是观察的作用,无缓存性,类似于某些数据的监听回调,每 当监听的数据变化时都会执行回调进行后续操作。
运用场景：
当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利 用 computed 的缓存特性,避免每次获取值时,都要重新计算。
当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率, 并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。
Vue面试题

ㅤ普通",
slot是什么 有什么作用 原理是什么,"slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。
实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.slot‘中，默认插槽为‘vm.slot中，默认插槽为vm.slot‘中，默认插槽为‘vm.slot.default，具名插槽为vm.slot.xxx‘，xxx为插槽名，当组件执行渲染函数时候，遇到slot标签，使用‘slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用slot.xxx‘，xxx为插槽名，当组件执行渲染“函数时候，遇到slot标签，使用‘slot`中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。
Vue面试题

ㅤ普通",
$nextTick 原理及作用,"nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。
nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理
nextTick 是典型的将底层 JavaScript执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶
同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要
Vue采用了数据驱动视图的思想，但是我们在一些情况下，仍然需要操作DOM。有时候，我们可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。
所以，在以下情况下，会用到nextTick：
在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。
因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。
Vue面试题

ㅤ普通",
Vue 中给 data 中的对象属性添加一个新的属性时会发生什么 如何解决,"点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：
$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。
Vue面试题

ㅤ普通",
Vue 单页应用与多页应用的区别,"概念：
MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。 多页应用跳转，需要整页资源刷新。
区别：

Vue面试题

ㅤ普通",
Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗,"不会立即同步执行重新渲染。
Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。
Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。
然后，在下一个的事件循环”tick”中，Vue 刷新队列并执行实际（已去重的）工作。
Vue面试题

ㅤ普通",
子组件可以直接改变父组件的数据吗,"子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。
Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。
只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。
Vue面试题

ㅤ普通",
说一下对 React 和 Vue 的理解，它们的异同,"（1）相似之处
都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。
都使用了Virtual DOM（虚拟DOM）提高重绘性能
都有props的概念，允许组件间的数据传递
都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性
（2）不同之处
1）数据流
Vue默认支持数据双向绑定，而React一直提倡单向数据流
2）虚拟DOM
Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。
对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过
PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。
3）组件化
React与Vue最大的不同是模板的编写。
React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。
具体来讲：React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们 import 一个组件完了之后，还需要在 components 中再声明下。
4）监听数据变化的实现原理不同
React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。
5）高阶组件
react可以通过高阶组件（Higher Order Components– HOC）来扩展，而vue需要通过mixins来扩展。
原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。
6）构建工具
两者都有自己的构建工具
7）跨平台
Vue面试题

ㅤ普通",
Vue的优点,"轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；
简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；
组件化：保留了 react 的优点，实现了 html 的封装和重用
在构建单页面应用方面有着独特的优势；
视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
虚拟DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；
运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言， vue 存在很大的优势。
Vue面试题

ㅤ普通",
Vue模版编译原理,"ue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。
解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。
优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。
生成阶段：将最终的AST转化为render函数字符串。
Vue面试题

ㅤ普通",
对SSR的理解,"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端
SSR的优势：
SSR的缺点：
开发条件会受到限制，服务器端渲染只支持beforeCreatecreated两个钩子
当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境
更多的服务端负载
Vue面试题

ㅤ普通",
Vue的性能优化有哪些,"（1）编码阶段
v-if和v-for不能连用
如果需要使用v-for给每项元素绑定事件时使用事件代理
SPA 页面采用keep-alive缓存组件
在更多的情况下，使用v-if替代v-show
key保证唯一
使用路由懒加载、异步组件
防抖、节流
第三方模块按需导入
长列表滚动到可视区域动态加载
图片懒加载
（2）SEO优化
（3）打包优化
（4）用户体验
Vue面试题

ㅤ普通",
对 SPA 单页面的理解，它的优缺点分别是什么,"SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
优点：
缺点：
初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。
Vue面试题

ㅤ普通",
Vue 子组件和父组件执行顺序,"加载渲染过程：
1.父组件 beforeCreate
2.父组件 created
3.父组件 beforeMount
4.子组件 beforeCreate
5.子组件 created
6.子组件 beforeMount
7.子组件 mounted
8.父组件 mounted
更新过程：
1.父组件 beforeUpdate
2.子组件 beforeUpdate
3.子组件 updated
4.父组件 updated
销毁过程：
1.父组件 beforeDestroy
2.子组件 beforeDestroy
3.子组件 destroyed
4.父组件 destoryed
Vue面试题

ㅤ普通",
Vue-Router 的懒加载如何实现,"非懒加载：
（1）方案一(常用)：使用箭头函数+import动态加载
（2）方案二：使用箭头函数+require动态加载
方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。
Vue面试题

ㅤ普通",
路由的hash和history模式的区别,"Vue-Router有两种模式：hash模式和history模式。默认的路由模式是hash模式。
1. hash模式
简介： hash模式是开发中默认的模式，它的URL带着一个#，例如：[http://www.abc.com/#/vue]
(http://www.abc.com/#/vue)，它的hash值就是#/vue。
特点：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响，所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。
原理： hash模式的主要原理就是onhashchange()事件：
使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。
除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。
2. history模式
简介： history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。
特点： 当使用history模式时，URL就像这样：[http://abc.com/user/id](http://abc.com/user/id)。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。
API： history api可以分为两大部分，切换历史状态和修改历史状态：
切换历史状态： 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。
虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。
如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：
3. 两种模式对比
调用 history.pushState() 相比于直接修改 hash，存在以下优势:
pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
pushState() 可额外设置 title 属性供后续使用。
hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。 hash模式和history模式都有各自的优势和缺陷，我们还是要根据实际情况选择性的使用。
Vue面试题

ㅤ普通",
使用 Object.defineProperty() 来进行数据劫持有什么缺点,"在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。
在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。
Vue面试题

ㅤ普通",
Vue-router跳转和location.href有什么区别,"使用 location.href= /url来跳转，简单方便，但是刷新了页面；
使用 history.pushState( /url ) ，无刷新页面，静态跳转；
引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为vue-router就是用了 history.pushState() ，尤其是在history模式下。
Vue面试题

ㅤ普通",
对前端路由的理解,"在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。
后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 SPA（单页面应用）。
SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：
由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息
为了解决这个问题，前端路由出现了。
前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。
那么如何实现这个目的呢？首先要解决两个问题：
单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？
从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：
拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。
感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。
Vue面试题

ㅤ普通",
Redux 和 Vuex 有什么区别，它们的共同思想,"（1）Redux 和 Vuex区别
Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可
Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）
通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;
（2）共同思想
本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;
Vue面试题

ㅤ普通",
为什么 Vuex 的 mutation 中不能做异步操作,"Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。
每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。
Vue面试题

ㅤ普通",
Vue3.0有什么更新,"（1）监测机制的改变
消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：
（2）只能监测属性，不能监测对象
（3）模板
同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。
（4）对象式的组件声明方式
3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易
（5）其它方面的更改
支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。
支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。
基于 tree shaking 优化，提供了更多的内置功能。
Vue面试题

ㅤ普通",
defineProperty和proxy的区别,"Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。
Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。
但是这样做有以下问题：
无法监控到数组下标和长度的变化。
Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于Object.defineProperty()，
其有以下特点：
Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。
Proxy 可以监听数组的变化。
Vue面试题

ㅤ普通",
谈下你对 Zookeeper 的认识？,"ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。
ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
Zookeeper面试题",
Zookeeper 都有哪些功能？,"1. 集群管理：监控节点存活状态、运行请求等；
2. 主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程；
3. 分布式锁：Zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。Zookeeper 可以对分布式锁进行控制。
4. 命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息
Zookeeper面试题",
谈下你对 ZAB 协议的了解？,"ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。
当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。
Zookeeper面试题",
Zookeeper 怎么保证主从节点的状态同步？,"Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。
当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。
一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。
Zookeeper面试题",
Zookeeper 有几种部署模式？,"Zookeeper 有三种部署模式：
单机部署：一台集群上运行；
集群部署：多台集群运行；
伪集群部署：一台集群启动多个 Zookeeper 实例运行。
Zookeeper面试题",
说一下 Zookeeper 的通知机制？,"client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。
Zookeeper面试题",
集群中为什么要有主节点？,"在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。
Zookeeper面试题",
集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？,"可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。
集群规则为 2N+1 台，N >0，即最少需要 3 台。
Zookeeper面试题",
说一下两阶段提交和三阶段提交的过程？分别有什么问题？,"1. 第一阶段（投票阶段）：
（1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应；
（2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。
（3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。
2. 第二阶段（提交执行阶段）：
当协调者节点从所有参与者节点获得的相应消息都为”同意”时：
（1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求；
（2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源；
（3）参与者节点向协调者节点发送”完成”消息；
（4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。
两阶段提交存在的问题：
参与者发生故障：协调者需要给每个参与者额外指定超时机制，超时后整个事务失败；
协调者发生故障：参与者会一直阻塞下去。需要额外的备机进行容错；
二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
与两阶段提交不同的是，三阶段提交有两个改动点：
在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。
1. CanCommit 阶段
3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。
（1）事务询问：协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
（2）响应反馈：参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No。
2. PreCommit 阶段
协调者根据参与者的反应情况来决定是否可以继续事务的 PreCommit 操作。根据响应情况，有以下两种可能：
假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。
（1）发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。
（2）事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。
（3）响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。
假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。
（1）发送中断请求：协调者向所有参与者发送 abort 请求。
（2）中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。
3. doCommit 阶段
该阶段进行真正的事务提交，也可以分为以下两种情况。
3.1 执行提交
（1）发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。
（2）事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
（3）响应反馈：事务提交完之后，向协调者发送 ACK 响应。
（4）完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。
3.2 中断事务
协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。
（1）发送中断请求：协调者向所有参与者发送 abort 请求。
（2）事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
（3）反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息。
（4）中断事务：协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。
三阶段提交的问题：
网络分区可能会带来问题。需要四阶段解决：四阶段直接调用远程服务的数据状态，确定当前数据一致性的情况。
Zookeeper面试题",
Zookeeper 宕机如何处理？,"Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。
Zookeeper 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 Zookeeper 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以：
3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票 > 1.5)
2 个节点的 cluster 就不能挂掉任何1个节点了(leader 可以得到 1 票 <= 1)
Zookeeper面试题",
说下四种类型的数据节点 Znode？,"PERSISTENT：持久节点，除非手动删除，否则节点一直存在于 Zookeeper 上。
EPHEMERAL：临时节点，临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与 Zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。
PERSISTENT_SEQUENTIAL：持久顺序节点，基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
EPHEMERAL_SEQUENTIAL：临时顺序节点，基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
Zookeeper面试题",
Zookeeper 和 Dubbo 的关系？,"Dubbo 的将注册中心进行抽象，是得它可以外接不同的存储媒介给注册中心提供服务，有 ZooKeeper，Memcached，Redis 等。
引入了 ZooKeeper 作为存储媒介，也就把 ZooKeeper 的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个 ZooKeeper 群配合相应的 Web 应用就可以很容易达到负载均衡；资源同步，单单有负载均衡还不 够，节点之间的数据和资源需要同步，ZooKeeper 集群就天然具备有这样的功能；命名服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动 的时候，向 ZooKeeper 上的指定节点 /dubbo/${serviceName}/providers 目录下写入自己的 URL 地址，这个操作就完成了服务的发布。 其他特性还有 Mast 选举，分布式锁等。

Zookeeper面试题",
Zookeeper,"ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。
ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
1. 集群管理：监控节点存活状态、运行请求等；
2. 主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程；
3. 分布式锁：Zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。Zookeeper 可以对分布式锁进行控制。
4. 命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。
ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。
当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。
Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。
当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。
一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。
Zookeeper 有三种部署模式：
集群部署：多台集群运行；
伪集群部署：一台集群启动多个 Zookeeper 实例运行。
client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。
在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。
可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。
集群规则为 2N+1 台，N >0，即最少需要 3 台。
1. 第一阶段（投票阶段）：
（1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应；
（2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。
（3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。
2. 第二阶段（提交执行阶段）：
当协调者节点从所有参与者节点获得的相应消息都为”同意”时：
（1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求；
（2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源；
（3）参与者节点向协调者节点发送”完成”消息；
（4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。
两阶段提交存在的问题：
参与者发生故障：协调者需要给每个参与者额外指定超时机制，超时后整个事务失败；
协调者发生故障：参与者会一直阻塞下去。需要额外的备机进行容错；
二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
与两阶段提交不同的是，三阶段提交有两个改动点：
在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。
1. CanCommit 阶段
3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。
（1）事务询问：协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
（2）响应反馈：参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No。
2. PreCommit 阶段
协调者根据参与者的反应情况来决定是否可以继续事务的 PreCommit 操作。根据响应情况，有以下两种可能：
假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。
（1）发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。
（2）事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。
（3）响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。
假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。
（1）发送中断请求：协调者向所有参与者发送 abort 请求。
（2）中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。
3. doCommit 阶段
该阶段进行真正的事务提交，也可以分为以下两种情况。
3.1 执行提交
（1）发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。
（2）事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
（3）响应反馈：事务提交完之后，向协调者发送 ACK 响应。
（4）完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。
3.2 中断事务
协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。
（1）发送中断请求：协调者向所有参与者发送 abort 请求。
（2）事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
（3）反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息。
（4）中断事务：协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。
三阶段提交的问题：
网络分区可能会带来问题。需要四阶段解决：四阶段直接调用远程服务的数据状态，确定当前数据一致性的情况。
Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。
Zookeeper 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 Zookeeper 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以：
3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票 > 1.5)
2 个节点的 cluster 就不能挂掉任何1个节点了(leader 可以得到 1 票 <= 1)
EPHEMERAL：临时节点，临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与 Zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。
PERSISTENT_SEQUENTIAL：持久顺序节点，基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
EPHEMERAL_SEQUENTIAL：临时顺序节点，基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
Dubbo 的将注册中心进行抽象，是得它可以外接不同的存储媒介给注册中心提供服务，有 ZooKeeper，Memcached，Redis 等。
引入了 ZooKeeper 作为存储媒介，也就把 ZooKeeper 的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个 ZooKeeper 群配合相应的 Web 应用就可以很容易达到负载均衡；资源同步，单单有负载均衡还不 够，节点之间的数据和资源需要同步，ZooKeeper 集群就天然具备有这样的功能；命名服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动 的时候，向 ZooKeeper 上的指定节点 /dubbo/${serviceName}/providers 目录下写入自己的 URL 地址，这个操作就完成了服务的发布。 其他特性还有 Mast 选举，分布式锁等。

Zookeeper面试题",
计算机网络面试真题简介,"大家好，我是帅地。
计算机网络基本属于面试题必考，无论你是前端开发还是后端，是校招还是社招，考的非常多，帅地把大部分会考到的都总结在这里了，跟着专题把它刷了就差不多了，但是切记，面试题只是帮助你快速复习和查漏补缺，自己有时间最好是跟着书系统学一下，实在不行也可以把我写的十几个协议看一下：计算机网络入门简介
计算机网络入门简介
如果有时间的话，可以把《计算机网络自顶向下》这本书刷个两三遍就差不多了，这本书的具体阅读指南：计算机网络《自顶向下》阅读指南
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
计算机网络《自顶向下》阅读指南
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. OSI 的七层模型分别是？各自的功能是什么？
1. OSI 的七层模型分别是？各自的功能是什么？
2. 为什么需要三次握手？两次不行？
2. 为什么需要三次握手？两次不行？
3. 为什么需要四次挥手？三次不行？
3. 为什么需要四次挥手？三次不行？
4. TCP与UDP有哪些区别？各自应用场景？
4. TCP与UDP有哪些区别？各自应用场景？
5. HTTP1.0，1.1，2.0 的版本区别
5. HTTP1.0，1.1，2.0 的版本区别
6. POST和GET有哪些区别？各自应用场景？
6. POST和GET有哪些区别？各自应用场景？
7. HTTP 哪些常用的状态码及使用场景？
7. HTTP 哪些常用的状态码及使用场景？
8. HTTP状态码301和302的区别，都有哪些用途？
8. HTTP状态码301和302的区别，都有哪些用途？
9. 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？
9. 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？
10. HTTP 如何实现长连接？在什么时候会超时？
10. HTTP 如何实现长连接？在什么时候会超时？
11. TCP 如何保证有效传输及拥塞控制原理
11. TCP 如何保证有效传输及拥塞控制原理
12. IP地址有哪些分类？
12. IP地址有哪些分类？
13. GET请求中URL编码的意义
13. GET请求中URL编码的意义
14. 什么是SQL 注入？举个例子？
14. 什么是SQL 注入？举个例子？
15. 谈一谈 XSS 攻击，举个例子？
15. 谈一谈 XSS 攻击，举个例子？
16. 讲一下网络五层模型，每一层的职责？
16. 讲一下网络五层模型，每一层的职责？
17. 简单说下 HTTPS 和 HTTP 的区别
17. 简单说下 HTTPS 和 HTTP 的区别
18. 对称加密与非对称加密的区别
18. 对称加密与非对称加密的区别
19. 简单说下每一层对应的网络协议有哪些？
19. 简单说下每一层对应的网络协议有哪些？
20. ARP 协议的工作原理？
20. ARP 协议的工作原理？
21. TCP 的主要特点是什么？
21. TCP 的主要特点是什么？
22. UDP 的主要特点是什么？
22. UDP 的主要特点是什么？
23. TCP 和 UDP 分别对应的常见应用层协议有哪些？
23. TCP 和 UDP 分别对应的常见应用层协议有哪些？
24. 为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？
24. 为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？
25. 保活计时器的作用？
25. 保活计时器的作用？
26. TCP 协议是如何保证可靠传输的？
26. TCP 协议是如何保证可靠传输的？
27. 谈谈你对停止等待协议的理解？
27. 谈谈你对停止等待协议的理解？
28. 谈谈你对 ARQ 协议的理解？
28. 谈谈你对 ARQ 协议的理解？
29. 谈谈你对滑动窗口的了解？
29. 谈谈你对滑动窗口的了解？
30. 谈下你对流量控制的理解？
30. 谈下你对流量控制的理解？
31. 谈下你对 TCP 拥塞控制的理解？使用了哪些算法？
31. 谈下你对 TCP 拥塞控制的理解？使用了哪些算法？
32. 什么是粘包？
32. 什么是粘包？
33. TCP 黏包是怎么产生的？
33. TCP 黏包是怎么产生的？
34. 怎么解决拆包和粘包？
34. 怎么解决拆包和粘包？
35. forward 和 redirect 的区别？
35. forward 和 redirect 的区别？
36. HTTP 方法有哪些？
36. HTTP 方法有哪些？
37. 在浏览器中输入 URL 地址到显示主页的过程？
37. 在浏览器中输入 URL 地址到显示主页的过程？
38. DNS 的解析过程？
38. DNS 的解析过程？
39. 谈谈你对域名缓存的了解？
39. 谈谈你对域名缓存的了解？
40. 谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？
40. 谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？
41. HTTPS 的工作过程？
41. HTTPS 的工作过程？
42. HTTP 和 HTTPS 的区别？
42. HTTP 和 HTTPS 的区别？
43. HTTPS 的优缺点？
43. HTTPS 的优缺点？
44. 什么是数字签名？
44. 什么是数字签名？
45. 什么是数字证书？
45. 什么是数字证书？
46. Cookie 和 Session 有什么区别？
46. Cookie 和 Session 有什么区别？
47. UDP 如何实现可靠传输？
47. UDP 如何实现可靠传输？
48. Keep-Alive 和非 Keep-Alive 有什么区别？
48. Keep-Alive 和非 Keep-Alive 有什么区别？
49. HTTP 长连接短连接使用场景是什么
49. HTTP 长连接短连接使用场景是什么
50. DNS 为什么用 UDP
50. DNS 为什么用 UDP
51. 简单说下怎么实现 DNS 劫持
51. 简单说下怎么实现 DNS 劫持
52. URI和 URL之间的区别
52. URI和 URL之间的区别
53. TIME_WAIT 状态会导致什么问题，怎么解决
53. TIME_WAIT 状态会导致什么问题，怎么解决
54. 有很多 TIME-WAIT 状态如何解决
54. 有很多 TIME-WAIT 状态如何解决
55. 简单说下 SYN FLOOD 是什么
55. 简单说下 SYN FLOOD 是什么
56. ICMP 有哪些应用？
56. ICMP 有哪些应用？
57. TCP 最大连接数限制
57. TCP 最大连接数限制
58. IP地址和MAC地址有什么区别？各自的用处？
58. IP地址和MAC地址有什么区别？各自的用处？
59. IPV4 地址不够如何解决
 
59. IPV4 地址不够如何解决
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
 Java面试题面试题阅读指南（必看）
 Java面试题面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
后端大厂面试真题",
字节跳动客户端开发面经汇总,"本系列将提供字节跳动客户端岗位历年面经，所有面经都有候选人面试之后根据回忆整理而出，大家可以通过面经来复习以及看看字节跳动面试难度。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读.
下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 【字节跳动】客户端岗-Android方向校招
1. 【字节跳动】客户端岗-Android方向校招
2. 【字节跳动】客户端岗-提前批五面(已拿意向书)
2. 【字节跳动】客户端岗-提前批五面(已拿意向书)
3. 【字节跳动】客户端岗-抖音客户端实习(已OC)
3. 【字节跳动】客户端岗-抖音客户端实习(已OC)
4. 【字节跳动】客户端岗-朝夕光年游戏开发
4. 【字节跳动】客户端岗-朝夕光年游戏开发
5. 【字节跳动】客户端岗-教育prek客户端日常实习
5. 【字节跳动】客户端岗-教育prek客户端日常实习
6. 【字节跳动】客户端岗-教育客户端社招面经
6. 【字节跳动】客户端岗-教育客户端社招面经
7. 【字节跳动】客户端岗-飞书二面面筋
7. 【字节跳动】客户端岗-飞书二面面筋
8. 【字节跳动】客户端岗-抖音暑期实习三轮面试
8. 【字节跳动】客户端岗-抖音暑期实习三轮面试
9. 【字节跳动】客户端岗-幸福里部门1,2,3面+hr面
9. 【字节跳动】客户端岗-幸福里部门1,2,3面+hr面
10. 【字节跳动】客户端岗-科班同学的两轮面经
10. 【字节跳动】客户端岗-科班同学的两轮面经
字节跳动面试
客户端开发岗

ㅤ普通",
【字节跳动】客户端岗-Android方向校招,"直接上面经吧。
字节跳动面试
客户端开发岗

ㅤ普通",
【字节跳动】客户端岗-提前批五面(已拿意向书),"一面约的14号。编译原理那一块问题太尴尬了，都给忘光了，面向对象的特点也不太清楚，当时问Python要是不用类，能实现面向对象吗？我给懵了…然后算法题的话，第一眼看上就像LFU缓存机制的算法题，没有刷过，不过庆幸刷过LRU缓存机制的题（感谢牛客上那篇整理7月字节跳动各岗位算法题的帖子），于是用了哈希表+双向链表，在面试官的提示下做出来了，不然估计一面就得凉。当天晚上接到HR的电话，很高兴一面通过，约了16号的二面。


  二面刚面完。Python装饰器的作用没有答出来，然后线程安全问题没答出来，应该是会导致卡死的，线程跟进程一样也会因为死锁的！二面感觉两道算法题都比一面的简单很多，不过自己还是在第二题上的反转数字上卡壳了，害…..面试官评价我基础知识不太扎实，感觉是凉了。许愿今晚能继续接到HR的电话吧！哈哈运气好过了就继续更三面！

以下是更新：

  二面果然被刷了～不过还好HR说我面试评价总体不错，被另一个部门捞起来了，所以接着冲吧！！


  总体感觉还行，就是面试刚开始的时候出了几次小状况突然没画面了，不过面试官很耐心，切换线路之后正常了。一来就开始讲项目，没有想到1面就会问项目，所以没有提前准备，导致介绍项目的时候逻辑混乱想到什么说什么，也没有突出重点，下次得好好准备一下了。然后是讲完“类方法 静态方法 实例方法”后，面试官说可能Python和其他语言不太一样吧～瞬间感觉是自己答错了hh，后来的问题都蛮常规，也恰好准备到了，算法题也问题不大，不过面试官小哥看得比较仔细，还会问我哪一行的代码有什么作用，感觉和之前不太一样呢。最后反问环节，面试官建议我可以脱离Python，多了解一下面向对象编程的通用概念，我感觉确实是疏忽了，这种编程思想的东西就是不应该就具体语言来讲的，很有收获。
  下午面完没多久就接到HR电话了！约了27号的第二次2面，因为这几天都约满了，看来16号截止投递期限投的同学不少呀。这次2面一定得加油了！（至少让我挺到3面吧求求了！


  这次感觉前面的情景设计题实在是太灵活了，自己的思路也确实不太好。求个3面啊！！许愿许愿！
  当天晚上HR微信告诉我2面过了，我的妈耶太高兴了！后来和3面面试官约了31号晚上9点的面试（面试官真是又忙又辛苦），加油吧！最后一面了！


  建议这题大家动手写一下。我一开始思路有点问题，分了4种情况，导致代码很冗余，自己都看不下去了。后来幸好换了方法，才勉强写下去。最后要注意两个字符串长度不一样的情况，善后要做好，以及最高位的进位也要记得处理。这题应该不算难，但是自己估计写了40分钟，感谢面试官耐心等待！
  写完算法题一度认为自己凉了，感谢HR小姐姐当天晚上微信上就告知我通过了！！目前就是等待意向书～

总结：这次字节跳动提前批，算是自己找工作的首面，抱着试一试的态度投递了客户端的岗位，毕竟客户端接受零基础。面试主要就是考察数据结构，计算机网络，操作系统和算法题，还有自己常用编程语言的一些特性，以及面向对象的思想。大部分面试题都能在牛客网的面经上找到，（非常感谢牛客]网！和各位分享面经的同学！）建议搜集整理好自己投递岗位的面经，然后认真准备就好了！自己一开始投递的部门（2面被刷），后来被另一个部门捞起来（感谢！），然后又经历了3面，这个过程其实还是有点折磨人心智的，不过最终能拿到offer，一切都值了！
所以，坚持不住的时候，记得再坚持一下！
字节跳动面试
客户端开发岗

ㅤ普通",
【字节跳动】客户端岗-抖音客户端实习(已OC),"自动化大二，纯自学。2月17投简历。
面试纯中文，不过我有些专有名词不知道用中文怎么说，回答的英文。下面有些也用英文写了。
自我介绍。
介绍项目，能不能解释一下你项目里面提到的Plasma。
程序和进程的区别。
线程和进程区别
线程同步方式（面试官补充了kernel signals)
我接着上面扯到线程通讯方式，说了future and promise，不过面试官问了我一下这个是不是c++标准库里的 :shrugging:
线程锁
问点数据库的（还没学，跳过）
你项目是用c++的，如果base class 没有virtual destructor 会怎么样？（把c++多态都讲了一遍）
讲一下osi model（我把osi和ip给混了，按照ip给讲了一遍）
编程题：
leetcode125 （第一次面试，过于紧张，一下子没给出最优解，大概15分钟后才弄出最优解）
我听你声音断断续续的，怎么回事
leetcode680 秒了
反问：
我：没啥好问的，这边是IOS的吗？
答：是的，我来给你介绍一下我们部门吧 blablabla….
之后的面试HR会联系你的
大概4天后约2，3面
自我介绍
项目介绍，详细介绍一下项目的难点
学过啥
学过计网是吧，讲一下tcp,udp
tcp 为什么four way close（没继续追问状态）
讲一下http和https的区别
讲一下https连接建立过程
智力题：5L和6L两个桶，怎么倒3L水，水无限。
脑子里空想了一下，讲的时候把步骤给忘了，面试官让我画下图，弄了一会弄出来了
我听你声音断断续续的，怎么回事。（重启了一下视频，好了）
2个Stacks实现FIFO container (queue) 手画了一下，没写代码。
编程题:
leetcode105
不知道对不对，反正方法是对的。没跑，我感觉有点小问题。
反问环节，等一会三面。
自我介绍
音频怎么有杂音？（我：重启视频，但好像还没解决）
虚拟内存有没有问过（答一面问过了）
Three entities of Object Oriented Programming
你是用c++的，多态怎么实现
Source code to binary process
kernel mode and user mode
有哪些Interrupts?
我：你声音断断续续的，能不能重启视频
如果有一个任务要求一周完成，你发现分配到的子任务需要两周才能完成，这时候你怎么办。
leetcode 105, 给了输入，要求手写出答案（不是代码，是结果）。我脑子坏掉了，搞了半天没搞出来。换题了。
leetcode25，不足k也要翻转。不要用recursive的方法，那样太简单了（大喜，反正我也不会recursive的方法）
很快，写完了。被要求解释。
想到我的方法面试官一下子没看懂，我口头解释+画图解释无果。被要求自己写个例子跑一下。
发现list length的代码有个小问题，面试官指出来后改了。程序没问题。面试官：你这个方法我再去看一下。
你认为你自己的优势和缺点是什么。
我听你有杂音，很难受，今天就到这里。
反问：
Q: 这么晚还不下班吗？（7pm）
A: 你自己去网上查查
Q: 抖音是swift写的吗？
A: OC为主
3/10/2021 过了，3/12/2021 HR面, 3/18/2021 Oral Comfirm
字节跳动面试
客户端开发岗

ㅤ普通",
【字节跳动】客户端岗-朝夕光年游戏开发,"自我介绍
总结
第一次面试，人有点紧张，有些问题没回答好，不过面试官很好，十分有耐心，也给了一些提示，最后磕磕绊绊都做出来了。一面结束后一天后告诉我面试通过，进入二面。
总结：这次面试发挥的比较好，问题都回答出来了，上次告诉一面自己也会图形学，这次果然问了很多，面试官也很好。二面结束后3个小时告诉我面试通过，安排三面+HR面的时间。
自我感觉是个压力面，面试官的问题明显深很多，还一直追问，问到大脑空白。
总结： 三面的面试难度明显要比前两面要高很多，问的东西都很深，不仅要了解到知识本身，还要理解他的应用。三面结束后半个小时后通知HR面。
HR面总体来说面试的很愉快，因为我是计算机科学：游戏设计专业（对口专业），问了我很多学校的事情，也问了我问什么选择这个专业。问了问我的项目经历，小组合作开发游戏时候遇到的困难，我的解决方式。也问了我对未来的想法。后面就是正常的HR信息收集。最后问了问评价，HR对我挺满意的。
HR面后两天接到OC，我的面试进度很神速，从一面到OC只用了8天的时间，我上岸了，希望大家也能继续加油，找到自己心仪的offer~
字节跳动面试
客户端开发岗

ㅤ普通",
【字节跳动】客户端岗-教育prek客户端日常实习,"（这两天密集的面试，很多东西真的记不清了，把能回忆出来的尽量回忆出来，不保证全面和准确，仅供参考）
自我介绍
1、ttp 与https 区别，除了安全性之外还有别的不同吗？
2、对称加密和非对称加密在https的应用
3、操作系统内置证书的作用
4、虚拟地址及其作用
5、进程和线程的区别
6、不同进程之间互相有影响吗
7、不同线程之间呢
8、线程退出进程会退出吗
9、用过java线程池吗，java线程池中线程是如何执行任务的？
10、三道算法题
反转链表
快速排序手撕
一堆负数一堆0一堆正数 求最后一个出现的负数 第一个出现的正数（要求时间复杂度为logn）
（面试官从一开始就在笑，全程在笑，好开心的样子，可能是遇到了什么特别开心的事了吧；然后过程中也在憋笑，可能我的某些回答也让他憋不住吧哈哈）
自我介绍 ，聊的内容有点回忆不起来了……
记不起来接下来是什么了，然后面试官说我们做一些题吧，然后再问基础知识
算法题1：给定二叉树的根节点和目标节点，求从根节点到目标节点的路径；（用递归写的，但是面试官说思路对，有一些小细节有问题，让我下去再改改）
面试官说接下来的两道题你不用写代码，说思路就好。
算法题2：一个数组里有一个数的出现次数为奇数，剩下的数字出现的次数为偶数，求出现次数为奇数的数字
算法题3：海量的视频，求播放量次数最多的前k个视频
接下来是基础知识(面试官说你擅长Java语言，那我问你java吧)
1、Java里面有几种内部类，说一下?
2 、你刚刚说到实例内部类可以访问外部类的成员，请问这是为什么?
3 、你刚刚说到引用，请问java里面的引用分为几种？我答了符号引用和直接引用，面试官一直笑，好
像在憋笑，然后说你说说吧，然后我说完之后他又笑，说，“我指的是 强引用
软引用 弱引用 虚引用”，这些你了解吗？我说不了解
4、你刚刚提到了内存，说说java的内存管理机制？
5、 你说说java如何判断对象是否该回收？
6、再聊聊java集合吧
你知道hashtable吗。说说hashtable和hashmap的区别,他们不同在哪里呢
（突然想起来红黑树的问题，不知道是不是这场面试还是别的面试里的，有点记不太清了。 不知道怎么就把话题引到了红黑树的左旋右旋操作那里，然后我答得也非常凌乱……）
用过迭代器吗？为什么要有迭代器呢？
7、你知道fail-fast吗
8、了解双亲委派机制吗？为什么要有双亲委派机制？
基础知识这边好像是只问java了，能记起的就只有这些。
然后是反问环节：
1、我问面试官，想问问这个岗位重视相关经验吗，我看您也没怎么问安卓的东西？面试官又笑我，好像又在憋笑，然后问我，你有客户端经验吗？我说没有，他更笑了。然后解释说公司有友好的培训制度和带新人制度，没有问题
2、我又问，通过面试，您觉得我有哪些明显的劣势。他又笑了！！！在憋笑！！然后说你们学生就爱问这个问题，我不做评价啊，我对这个问题不做评价
3、常规性的问了一下啥时候得到结果，他的回答也挺常规的。当然，他还是在笑！！！
这次面试除了使我觉得我自己太菜之外，还让我认识到，今天的面试官一定很开心，全程在憋笑！辛苦了！！！
先做自我介绍
然后面试官问，你有过客户端开发经验吗，答曰没有。然后那你有了解过Android相关知识吗？我说有了解过安卓四大组件、七大生命周期。然后面试官问你有下个Android Studio之类的吗？我说从Github上下了个源代码在Android Studio运行，可是由于Gradle的问题没成功。面试官还耐心地解释了一下问题。
然后基础知识：
计网
操作系统
Java语言：
1、你说你熟悉java语言，那么读研期间你大概写了多少行JAVA代码？有算过吗？
然后他说好久没问过JAVA的题了。
2、他想了会儿，你说说内存泄漏吧？
3、Java的内存泄漏和C++的内存泄露有什么不同吗？
4、你说java能自动回收垃圾，那你认为Java中还存在内存泄漏的情况吗？
5、你刚刚提到Jvm垃圾回收，那你大概说说垃圾回收吧。
6、 你刚刚提到可达性分析的根对象，那么除了栈中的对象可以作为根对象外，还有别的吗？
7、你说说Java 中常见的数据结构吧
8、你刚刚提到的这些数据结构的底层数据结构你了解吗？（我说我用到的有Array、ArrayList、LinkedList、HashMap、HashSet）
9、你说LinkedList的底层是单向链表还是双向链表（我答了是双向的，不知道对不对），面试官继续问你怎么知道是双向的？我一时不知道怎么回答….
10、你知道LinkedList实现了哪些接口吗？
11、你说LinkedList实现了Deque接口，这个接口里有哪些常用的函数呢？
12、继续说说HashMap、HashSet的底层数据结构
13、你刚刚提到了红黑树，红黑树相比其他二叉树有什么特殊的地方？
14、你刚刚提到了HashTable，你说说HashTable和 HashMap的区别？
15、你刚刚提到了线程安全，如果我想让ArrayList达到线程安全你会怎么做？（我答了加volatile关键字），面试官又问，这样可以保证操作的原子性吗？（我说如果ArrayList存储的元素是基本类型的话，我可以用java  Concurrent包下的原子类，也不知道对不对）？面试官又问还有没有其他的方式呢？（应该是这样的连环问，记得不是很清楚）
16、你知道Collections 类吗？你了解这个类下有哪些函数吗？我说我只用过Collections.reverse ,他笑了，然后说你可以下去再看看，有好多有趣的函数。
设计模式：
1 你知道哪些设计模式？含义及它们的应用说一下
2 你说到代理模式和适配器模式，那代理模式和适配器模式都是增加一层，那么他们的区别在哪里呢
3 了解观察者模式吗？说说观察者模式
4 自己用过哪些设计模式？
算法题：
整理出来的题意是这样的：
两个城市之间有k条航线，给定一个航空公司在这两个城市间的航班表，如果任一时刻在这两个城市间飞行的最大航班数小于等于k，则称该航班安排是完全安全的状态，写函数判断一下。
反问环节：
没啥可记录的
这次最大的感觉是面试官顺着自己的回答而相应地展开连环问，而不是像有个题库一样一个一个割裂地提出问题来问??
字节跳动面试
客户端开发岗

ㅤ普通",
【字节跳动】客户端岗-教育客户端社招面经,"深挖项目，问细节
C++语言有哪些使用技巧
QT信号槽机制
QT一个对象被析构后有什么方法检测，有什么预防崩溃的方法(QPointer)
C++11的新特性知道哪些
讲一下STL
QT复杂Ui的mode
详细说说重写和重载
QT信号槽和回调相比谁的效率高
虚函数表，虚函数表存在哪
算法：递归遍历多叉树
算法：下一个排列Leetcode 31
New malloc区别
QT信号槽机制
堆栈的区别，栈都有哪些元素(函数参数，局部变量)，追问：还有呢(函数状态，返回地址
然后一些八股。。忘得差不多了
面试的时候网络有点卡..做题
算法：缺失的第一个正数Leetcode 41要求空间复杂度o(1)时间复杂度o(N)
有什么要问的
这一面问的很深。。一度问得我怀疑人生
智能指针
QT的ui文件
C++的四种类型转换
C++哪些好的编码技巧
判断New是否成功的方法
结构体内使用指针和对象各有哪些好处
QT中的Moc机制
Static关键字
如何用C语言来实现抛出捕获异常
判断一个程序是死循环还是死锁
主循环为什么占用的内存空间小，你能写一个动态分配内存的程序吗
在什么情况下父类的析构函数不用被声明为虚函数
算法题：非递归中序遍历树
非递归遍历Json和XML
手写深拷贝+动态分配内存
有什么要问的
字节跳动面试
客户端开发岗

ㅤ普通",
【字节跳动】客户端岗-飞书二面面筋,"首先聊项目吗，聊了差不多二十分钟
问是了解Java多一些还是Python多一些
Java
final，和static关键字，作用于哪些地方，分别产生了什么效果
线程池的几个参数
线程池中的keepAliveTime参数主要是作用于哪里的，还有一些关于线程池的基本知识
创建线程的几种方法，分别在哪方面具有效果
synchronized和volatile还有retrantlock之间的区别
编程题：
反转链表手写
还有一个求数组中两个数字相乘，求最大值，并打印出来
聊项目，聊了20分钟，一些东西给我问卡了
聊学Java，看过哪几本书
然后说Java并发编程主要讲了哪些事情，我说保证线程安全，然后原子性，有序性，可见性一直聊
然后说到有序性，让我举个例子什么的，问用什么保证有序性，还有volatile修饰i的情况下，两个线程并发访问i会产生什么效果，这个得分情况答，没回答太好
然后说手写消费者生产者模型吧，我说不会，
又聊了下消费者生产者模型的事情（应该注意的点，没怎么答上来）
然后问操作系统
问我对操作系统的了解，没了解多少，就跟他简单说了下，进程之间的通信方式
Http和Https的区别 SSL的对称加密和非对称加密作用于哪里的？？（没答上）
手写打印二叉树的深度，递归和非递归都写了，并解释非递归的代码的含义
Throwble中的Error和Exception的区别
问的东西都很基础，但是面试官很严肃，一时间不知道怎么办好了。就不写了，总之就很基础。
字节跳动面试
客户端开发岗

ㅤ普通",
【字节跳动】客户端岗-抖音暑期实习三轮面试,"一共66分钟，其中面试官掉线了一次（字节网不好）
面试官是一个三十多岁的男人，头发不多。
先是自我介绍，介绍完看到我简历上有工业设计专业，问我是不是考研考的计算机（拜托！我一开始就说了我大三！）
面试官说客户端开发不要求相关项目经历，确实问的问题也以考察计算机基础为准。
操作系统
数据结构
计算机网络
项目
问的很简单，甚至不问简历上的项目
问了一下你在这几门课中有什么印象深刻的项目
我当时脑子真的坏掉了，我说了我实现内存管理那个项目，然后他又问了一堆内存管理的问题，问了下具体怎么实现的。我觉得这一par答的不太好
问了一下写项目中有遇到什么代码上的问题吗？
我本来把章总数据库标答又答了一遍，结果不是他想要的。他想要的是代码实现和debug的问题。
我实在想不起来代码上遇到的问题，我随便说了一个前后端数据结构不一致，他问我怎么debug（我觉得这一par都答的挺一般的
做题
Leetcode easy 617. 合并二叉树
会让你先说思路再开始写。我就说是一个二叉树的前序遍历，说了一下递归终止条件，就开始写了。因为是二叉树，所以不需要写测试用例，只需要把代码写完他人脑编译就行。
反问
总结一下，就是感觉答的还可以，中途面试官掉线了，但是牛客网显示是我这边网络不好，我给室友说我掉线了，结果面试官在聊天框打字说他听得到我说话，还好我没说啥大逆不道的话，md
二面和三面都很水，我觉得参考价值不太大。问的问题有一些相似，所以放在一起说
前情提要：一面给人感觉是完全脱离了简历在问，一直问计算机基础。我有几次想往简历上项目引导都引导失败，面试官主要在问那些有标准答案的问题。二面三面就完全是结合简历在问。
本人简历里是完全没有客户端经验的，前后端都有一些，这一点在自我介绍的时候着重强调了。
自我介绍。
让我从简历上挑一个项目讲讲，我讲了我最熟悉的云平台项目，但是面试官对这块不太熟，没有细问。
看到第二个项目问了一些git相关操作：
有个项目是写markdown编译器的，问了我markdown怎么渲染的（我扯了一堆编译原理相关东西，包括生成的树，然后扯到HTML DOM树了，被问了很多完全没准备的东西。
问HTML DOM树渲染流程。
前端相关：问了一下Vue 点击button修改元素和纯js修改写法上有什么不同，开了个编辑器让我现场写（完全没准备，写出来了，但是讲得不太好）
最后是一道算法题，题目是英文的，但是很简单。
求根节点到叶节点数字之和
问题都不难，且没有算法题。
自我介绍。
先聊了一下职业规划什么的。我当时提了一下我没有客户端经验但是学习能力还可以，直接给我上了一道英文阅读理解（bushi
问我用没用过awk，我说完全没接触过，他直接给我贴了一个man awk让我现学，然后问我一个命令的意思。
又聊了一些git使用，问挺深的（感觉主要是简历没客户端所以真的不好聊）
感觉基本上没了？挺轻松的，反问问了一下部门具体业务和客户端职业发展路线，面试官人很好。
比较奇怪的是没有HR面，我三面结束后两天给HR打电话说已经在发offer了，三面结束后的第四天收到的offer。
字节跳动面试
客户端开发岗

ㅤ普通",
"【字节跳动】客户端岗-幸福里部门1,2,3面+hr面","八股：
自我介绍
C++多态怎么实现的？
知道纯虚函数吗？
程序编译的整个过程。
TCP三次握手
HTTPS的工作原理
get和post的区别
线程进程的区别
知道锁吗？ 我回答了自旋锁还有互斥锁
进程可以直接通信吗？通信方式有哪些？
怎么创建一个进程?
大概就这些还有点记不清了。。
算法：
1.给了个n乘m的矩阵，每个格子里面一个数，从左上角走到右下角（只能向右和向下）的最小路径和。 dp一下就好
2.字符串转整数。
八股：
自我介绍
#define和const的区别。
写个求2个值中最大值的宏。然后问用我写的宏 max（a++，b）会有什么问题。
指针和引用的区别
然后开始问计网了
http和https的区别
https怎么加密，用到的加密算法是什么
tcp可靠吗？怎么实现保证可靠性的？
讲一下流量控制
还有点又记不清了。。
代码：
1.判断链表是不是回文的？ 要求空间复杂度越低越好（我问能不能丢vector里面 面试官：wtf     然后我直接快慢指针+翻转中心点后面部分）
2.用random5实现random7
八股：
自我介绍
1.死锁是什么
2.死锁的解决方法
3.讲一下银行家
4.osi七层模型每层分别干啥，有哪些协议
代码：
堆排序，写完讲一下（面试官很好，他说让我写堆排之后还说不会可以换题）
字节跳动面试
客户端开发岗

ㅤ普通",
【字节跳动】客户端岗-科班同学的两轮面经,"传统艺能不录音纯靠回忆，记不得的就不写啦。
1、自我介绍
2、了解一下项目是自己想做还是什么活动才做的（我感觉他都想问是不是课程设计了hhh）
计网
3、http状态码（只记得那么几个）
4、http中get与post区别，怎么防止劫持？（这里我自己提到了劫持，挖了个坑）
5、https的具体连接过程
6、中间人劫持了解过吗？（还没了解，我以为可能大概不会被问到，对不起）
7、TCP在哪一层？说下TCP怎么保证可靠性，细说。（巴拉了一堆，四次挥手都还没开始巴拉就被说ok了）
操作系统
8、代码到运行的过程
9、系统怎么把可执行文件装入内存
10、虚拟内存到物理内存怎么映射具体说下
11、程序的内存分布
12、全局int a = 10放在哪？10放在哪？函数里的int a = 10放在哪？10呢？
数据库
13、索引说一下，有哪些类型？底层实现？
14、什么情况用哈希表？
15、有没有了解过索引失效？有哪些情况会导致索引失效？（面试官从全表查询反复提示，然鹅我还是不会）
16、事务介绍一下。
手撕代码：二叉树的前序遍历，迭代实现。
反问：新人培训。
面试体验蛮舒服的，虽然面试官还是没有把我不会的告诉我，不过很温和很耐心，最重要的是会嗯嗯回应我！最后反问问我不想了解业务或者技术栈啥的吗emmmm
这时长好像有点短，不知道能不能过，还是许愿能有二面。
8.26 收到二面通知啦，字节效率好高啊！！
1、自我介绍
2、深挖项目（下面的问题都是在项目里提及到的，没有直接问，但感觉就是问的这些）
3、TCP与UDP的区别
4、TCP的快速重传
5、UDP如何保证可靠性
……省略关于TCP与UDP的一系列探讨。
6、数据库创了哪些表？细说。（字面意义的细说，细到字段，我怕了）
7、对字节的了解
8、为什么要来字节？
9、如果进了，什么时候能来实习？
手撕：最长无重复子串（要求15min）
反问：业务，技术栈。
这次面得我头皮发麻，问题不是说很难，但是项目被挖了个底朝天，孩怕。
面试官挺好的，但对我的回答不满意的时候会问得很细致，虽然他很温和，但我还是各种嘴瓢呜呜呜，手撕代码的时候看到题是自己做过的还挺开心，但是写漏了一行代码，答案一直是错的，我流下了悔恨的泪水。最后还是没改出来，没法调试让我抓心挠肝。面试官看了两眼评论道：确实有问题。
字节跳动面试
客户端开发岗

ㅤ普通",
操作系统面试题简介,"大家好，我是帅地。
在面试中，操作系统考察到的频率非常高，特别是一线互联网大厂，但是考来考去就那些问题，如果你把本专题都学了，估计就差不多了。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 简单说下你对并发和并行的理解？
1. 简单说下你对并发和并行的理解？
2. 同步、异步、阻塞、非阻塞的概念
2. 同步、异步、阻塞、非阻塞的概念
3. 进程和线程的基本概念
3. 进程和线程的基本概念
4. 进程与线程的区别？
4. 进程与线程的区别？
5. 为什么有了进程，还要有线程呢？
5. 为什么有了进程，还要有线程呢？
6. 进程的状态转换
6. 进程的状态转换
7. 进程间的通信方式有哪些？
7. 进程间的通信方式有哪些？
8. 进程的调度算法有哪些？
8. 进程的调度算法有哪些？
9. 什么是死锁？
9. 什么是死锁？
10. 产生死锁的原因？
10. 产生死锁的原因？
11. 死锁产生的必要条件？
11. 死锁产生的必要条件？
12. 解决死锁的基本方法？
12. 解决死锁的基本方法？
13. 怎么预防死锁？
13. 怎么预防死锁？
14. 怎么避免死锁？
14. 怎么避免死锁？
15. 怎么解除死锁？
15. 怎么解除死锁？
16. 什么是缓冲区溢出？有什么危害？
16. 什么是缓冲区溢出？有什么危害？
17. 分页与分段的区别？
17. 分页与分段的区别？
18. 物理地址、逻辑地址、虚拟内存的概念
18. 物理地址、逻辑地址、虚拟内存的概念
19. 页面置换算法有哪些？
19. 页面置换算法有哪些？
20. 谈谈你对动态链接库和静态链接库的理解？
20. 谈谈你对动态链接库和静态链接库的理解？
21. 外中断和异常有什么区别？
21. 外中断和异常有什么区别？
22. 一个程序从开始运行到结束的完整过程，你能说出来多少？
22. 一个程序从开始运行到结束的完整过程，你能说出来多少？
23. 什么是用户态和内核态
23. 什么是用户态和内核态
24. 用户态和内核态是如何切换的？
24. 用户态和内核态是如何切换的？
25. 进程终止的方式
25. 进程终止的方式
26. 守护进程、僵尸进程和孤儿进程
26. 守护进程、僵尸进程和孤儿进程
27. 如何避免僵尸进程？
27. 如何避免僵尸进程？
28. 介绍一下几种典型的锁？
28. 介绍一下几种典型的锁？
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
 Java面试题面试题阅读指南（必看）
 Java面试题面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
操作系统面试题",
简单说下你对并发和并行的理解？,"并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；
并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；
操作系统面试题",
同步、异步、阻塞、非阻塞的概念,"同步：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。
异步：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
阻塞：是指调用结果返回前，当前线程会被挂起，即阻塞。
非阻塞：是指即使调用结果没返回，也不会阻塞当前线程。
操作系统面试题",
进程和线程的基本概念,"进程：进程是系统进行资源分配和调度的一个独立单位，是系统中的并发执行的单位。
线程：线程是进程的一个实体，也是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，有时又被称为轻权进程或轻量级进程。
操作系统面试题",
进程与线程的区别？,"进程是资源分配的最小单位，而线程是 CPU 调度的最小单位；
创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；
不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；
进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；
操作系统面试题",
为什么有了进程，还要有线程呢？,"进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：
进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。
基于以上的缺点，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。
操作系统面试题",
进程的状态转换,"进程包括三种状态：就绪态、运行态和阻塞态。

1. 就绪 —> 执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；
执行 —> 阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；
阻塞 —> 就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；
执行 —> 就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。
操作系统面试题",
进程间的通信方式有哪些？,"进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。
管道
它只能用于父子进程或者兄弟进程之间的进程的通信；
它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write  等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。
命名管道
FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。
消息队列
消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；
消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；
消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。
信号量
信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；
信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；
每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；
支持信号量组。
共享内存
共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；
共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
操作系统面试题",
进程的调度算法有哪些？,"调度算法是指：根据系统的资源分配策略所规定的资源分配算法。常用的调度算法有：先来先服务调度算法、时间片轮转调度法、短作业优先调度算法、最短剩余时间优先、高响应比优先调度算法、优先级调度算法等等。
先来先服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。该算法既可以用于作业调度，也可以用于进程调度。先来先服务比较适合于常作业（进程），而不利于段作业（进程）。
时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片。
短作业优先调度算法是指对短作业优先调度的算法，从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。 短作业优先调度算法是一个非抢占策略，他的原则是下一次选择预计处理时间最短的进程，因此短进程将会越过长作业，跳至队列头。
最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。
高响应比优先调度算法主要用于作业调度，该算法是对 先来先服务调度算法和短作业优先调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。
优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。
操作系统面试题",
什么是死锁？,"死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 如下图所示：如果此时有一个线程 A，已经持有了锁 A，但是试图获取锁 B，线程 B 持有锁 B，而试图获取锁 A，这种情况下就会产生死锁。

操作系统面试题",
产生死锁的原因？,"由于系统中存在一些不可剥夺资源，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。
例如：系统中只有一台打印机，可供进程 A 使用，假定 A 已占用了打印机，若 B 继续要求打印机打印将被阻塞。
系统中的资源可以分为两类：
不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
例如：进程 A 和 进程 B 互相等待对方的数据。
操作系统面试题",
死锁产生的必要条件？,"互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。
操作系统面试题",
解决死锁的基本方法？,"预防死锁
避免死锁
检测死锁
解除死锁
操作系统面试题",
怎么预防死锁？,"破坏请求条件：一次性分配所有资源，这样就不会再有请求了；
破坏请保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源：
破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源；
破坏环路等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反。
操作系统面试题",
怎么避免死锁？,"1. 安全状态

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。
定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。
安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。
2. 单个资源的银行家算法
一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。
3. 多个资源的银行家算法

上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。
检查一个状态是否安全的算法如下：
如果一个状态不是安全的，需要拒绝进入这个状态。
操作系统面试题",
怎么解除死锁？,"资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；
撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；
进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。
操作系统面试题",
什么是缓冲区溢出？有什么危害？,"缓冲区为暂时置放输出或输入资料的内存。缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。计算机中，缓冲区溢出会造成的危害主要有以下两点：程序崩溃导致拒绝服务和跳转并且执行一段恶意代码。
操作系统面试题",
分页与分段的区别？,"段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；
段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；
段向用户提供二维地址空间；页向用户提供的是一维地址空间；
段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。
操作系统面试题",
物理地址、逻辑地址、虚拟内存的概念,"物理地址：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。
逻辑地址：是指计算机用户看到的地址。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。
虚拟内存：是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
操作系统面试题",
页面置换算法有哪些？,"请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入。而内存中给页面留的位置是有限的，在内存中以帧为单位放置页面。为了防止请求调页的过程出现过多的内存页面错误（即需要的页面当前不在内存中，需要从硬盘中读数据，也即需要做页面的替换）而使得程序执行效率下降，我们需要设计一些页面置换算法，页面按照这些算法进行相互替换时，可以尽量达到较低的错误率。常用的页面置换算法如下：
先进先出，即淘汰最早调入的页面。
选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。
即选择最近最久未使用的页面予以淘汰
时钟置换算法也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。
操作系统面试题",
谈谈你对动态链接库和静态链接库的理解？,"静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。
动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能
操作系统面试题",
操作系统,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里： 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
操作系统面试题",
外中断和异常有什么区别？,"外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。
而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。
操作系统面试题",
一个程序从开始运行到结束的完整过程，你能说出来多少？,"四个过程：
（1）预编译 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下
1、删除所有的#define，展开所有的宏定义。
2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。
4、删除所有的注释，“//”和“/**/”。
5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。
6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。
（2）编译 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。
1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。
2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。
3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
4、优化：源代码级别的一个优化过程。
5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。
6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。
（3）汇编
将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。
经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。
（4）链接
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：
1、静态链接： 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
2、动态链接： 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；
更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。
操作系统面试题",
什么是用户态和内核态,"用户态和内核态是操作系统的两种运行状态。

  那么为什么要有用户态和内核态呢？

这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。
操作系统面试题",
用户态和内核态是如何切换的？,"所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即用户态 -> 内核态 -> 用户态，而唯一能够做这些操作的只有 系统调用，而能够执行系统调用的就只有 操作系统。
一般用户态 -> 内核态的转换我们都称之为 trap 进内核，也被称之为 陷阱指令(trap instruction)。
他们的工作流程如下：

操作系统面试题",
进程终止的方式,"进程的终止
进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的
正常退出
多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 exit ，在 Windows 中是 ExitProcess。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。
错误退出
进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令
为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。
严重错误退出
进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。
被其他进程杀死
第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 TerminateProcess（注意不是系统调用）。
操作系统面试题",
守护进程、僵尸进程和孤儿进程,"指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等
创建守护进程要点：
（1）让程序在后台执行。方法是调用fork（）产生一个子进程，然后使父进程退出。
（2）调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid（）使进程成为一个会话组长。setsid（）调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。
（3）禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。
（4）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。
（5）将当前目录更改为根目录。
（6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask（0）将屏蔽字清零。
（7）处理SIGCHLD信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。
如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。
一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。
设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。
操作系统面试题",
如何避免僵尸进程？,"第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。
操作系统面试题",
介绍一下几种典型的锁？,"一次只能一个线程拥有互斥锁，其他线程只有等待
互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁
互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。
如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。
操作系统面试题",
常见内存分配内存错误,"（1）内存分配未成功，却使用了它。
编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p= =NULL) 或if(p!=NULL)进行防错处理。
（2）内存分配虽然成功，但是尚未初始化就引用它。
犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。
（3）内存分配成功并且已经初始化，但操作越过了内存的边界。
例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。
（4）忘记了释放内存，造成内存泄露。
含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。
（5）释放了内存却继续使用它。常见于以下有三种情况：
操作系统面试题",
内存交换中，被换出的进程保存在哪里？,"保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。
操作系统面试题",
原子操作的是如何实现的,"处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。
（1）使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i=1，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2，如图下图所示。
原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。
处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。
（2）使用缓存锁保证原子性 第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。
频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。
所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如上图所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能使用同时缓存i的缓存行。
但是有两种情况下处理器不会使用缓存锁定。 第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。 第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。
操作系统面试题",
抖动你知道是什么吗？它也叫颠簸现象,"刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)
为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率 为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程工作集” 的概念
操作系统面试题",
记一次 shopee 面试：最小栈的最优解,"前阵子面试的时候，在 shopee 的一面中，问了我一道最小栈的问题，关于最小栈的问题，我以前是做过的，以为是送分题，最结果最优解没写出来，不过也脑补了一些优化，算是答的还行。下面我先大致描述下这道题，然后一步步给出最优解以及我在面试中是解法（面试中给出了几个优化，但想不出最优解）。题目如下：

实现一个这样的栈，这个栈除了可以进行普通的push、pop操作以外，还可以进行getMin的操作，getMin方法被调用后，会返回当前栈的最小值。栈里面存放的都是 int 整数，并且数值的范围是 [-100000, 100000]。要求所有操作的时间复杂度是 O(1)。
附加：如果空间复杂度也能O(1)的话可加分。

对于这道题，如果是要求时间复杂度为 O(1)，空间复杂度为 O(n) 或者 时间复杂度为 O(n)，空间复杂度为 O(1) 的话，还是相对比较简单一点的，不过我猜想仍然有部分同学不会，所以我下面都稍微讲解一下。不过如果要求时间复杂度和空间复杂度都是 O(1) 的话，就比较难了，反正我当时是没做出来，只给出了一些优化的思路。

时间复杂度 O(n) + 空间复杂度 O(1) 这个我不讲，因为这个很简单，就是获取最小栈的时候，每次都遍历一次栈，把最小栈返回去就可以了，估计也没有人会问你这个方法

这个要求其实也不难，我们可以用一个辅助栈来存放最小值。例如我们有两个栈 stack 和 helper，stack 是目标栈，helper 是辅助栈，用来存放最小值。每次 getMin 的时候，直接从 helper 栈顶获取即可。下面重点讲一下 push 操作。
每次进行 push 操作的时候，进行如下操作（假设要 push 的元素是 t）
1、对于 stack 栈，我们按照正常情况把元素 push 到栈顶就可以了。
2、然后要把元素 t push 到 helper 栈顶的时候，要先把 t 与 helper 栈顶的元素（假设是 a）进行比较，如果 t <= a，则把元素 t push 到 helper 的栈顶，如果 t > a，这个时候，我们不把 t push 进去，而是重复把 a push 到 helper 的栈顶。
我举个例子吧，例如我们要把数组 arr = {2, 1, 3} 都放入栈中，则存放过程如下：
1、首先 push 2。由于刚开始 stack 和 helper 都是空的，所以直接把 2 放入，此时目标栈和辅助栈的值如下：stack = {2}，helper = {2}。
2、接下来 push 1。由于 helper 栈顶元素比 1 大，所以直接把 1 放入 helper 的栈顶，此时：stack = {2, 1}，helper = {2, 1}。
3、接下来 push 3，由于 helper 栈顶元素比 3 小，所以重复把 栈顶的元素再次入栈，此时： stack = {2, 1, 3}，helper = {2, 1, 1}。
对于 pop 操作，直接把两个栈的栈顶元素删除即可，所以具体代码如下：
不过接着面试官问我，你这个空间复杂度是 O(n)，可以优化到空间复杂度为 O(1) 吗？
这时有点小紧张，因为我之前看的书和别人的讲解中，根本没看过时间和空间都是 O(1) 的解法，不过这道题中，有一个条件限制，就是数值的范围是 [-100000, 100000]，我知道，这个数值限制，一定是一个突破口，可是硬是没想出来要怎么利用，于是我就按照自己的理解，给出了如下的优化方案：
1、优化1
刚才我们在对 helper 进行 push 操作的时候，如果栈顶的元素较小，那么我们是重复把栈顶的元素重复 push 进去的，显然，这是一个单调栈，并且栈顶的元素只会越来越小，假如栈顶的元素很小的话，那么有可能会出现，helper 的栈中有很多一样的元素，例如 helper = {2, 1, 1, 1, 1, 1, 1, 0, 0, 0 , 0, 0, 0}。
为了解决这个问题，我们可以用一个数值，来表示此处有多少个连续的元素，例如上面的辅助栈中有 1 个 2，6 个 1，6 个 0，那么我们可以这样来表示：helper = {2, 1, 1, 6, 0, 6}。这样的话，辅助栈用到的空间可以小一点。

当然，也有可能用的更多了，例如栈中基本没有连续的元素，例如原本 helper = {3， 2， 1}，则会变成 helper = {3, 1, 2, 1, 1, 1}。当然，这是极端的情况。

2、优化2
面试官问我还能有其他方法吗？
显然，我上面的优化中，并没有用到数值范围 [-100000, 100000] 这个条件，所以肯定是不行的，该怎么用利用到这个条件呢？
这个时候我是想到了位运算，一个 int 是 32 位，我打算把它分割成两部分，前面 16 位来存放目标值，后面 16 位来存放最小栈。也就是说，我不需要辅助栈 helper 了，只需要一个 stack 就够了，然后用元素的后 16 位来充当 helper 辅助栈的功能。
例如对于最上面的例子 stack = {2, 1, 3}, helper = {2, 1, 1}。那么这里只需要用一个 stack 来存放就可以了。把元素分割成 两部分，前面 16 位存放 stack 里面的值，后面 16 位存放 helper 里面的值，即 stack = {(2,2), {1, 1}, (3, 1)}。然后每次取值的时候，在通过移位的方法来获取值。
想到了这个方法，虽然没有想出最优解，不过我看面试官还是有那么点小满意的，不过我这个方法的数值范围限制是 [-2^15, 2^15 - 1]，而题目的限制是 [-100000, 100000]，所以会溢出，所以行不通，不过至少提供了一种思路。当然我可以用 long 类型的来存放，不过 Long 所需要的空间是 int 的两倍，所以我觉得也不大行，还是没有达到 O(1)。
然后我自己也想不出啥方法了，后面去网上和群里问被人才找到解法。下面我稍微说下这个方法
这种方法的话，我们的 stack 栈中，不能存放原始数值，而是应该存放 差值，啥差值？就是存放栈顶与最小值的差值。我还是详细一点给大家讲一个案例吧，案例配合代码，应该还是挺好理解的，例如 arr = {2, 1, 3, 0}，那么把这些元素入栈时，stack 栈中元素以及最小值的变化如下

上面表格是 push 时，栈中数值的变化，然后再进行 getMin 和 pop 可以通过相应的判断获取，直接看我的代码实现吧，我会进行相应解释，挺好懂，代码如下：
如果没有进行数值范围限制，上面的方法能行吗？答是不行，因为数值没有限制的话，差值的计算可能会溢出。
虽然这道题总体不难，不过一道题的解法多种多样，我们千万不能止步于最简单的解法，而应该寻找最优解。后面我也会讲一些面试相关的题，并且每次讲的时候，都会给出详细的解答，从暴力一步步到最优。
校招面试
算法面试
面试现场",
记一道字节跳动面试：变形的链表反转,"前几天有个朋友去面试字节跳动，面试官问了他一道链表相关的算法题，不过他一时之间没做出来，就来问了我一下，感觉这道题还不错，拿来讲一讲。
这其实是一道变形的链表反转题，大致描述如下
给定一个单链表的头节点 head,实现一个调整单链表的函数，使得每K个节点之间为一组进行逆序，并且从链表的尾部开始组起，头部剩余节点数量不够一组的不需要逆序。（不能使用队列或者栈作为辅助）
例如：
链表:1->2->3->4->5->6->7->8->null, K = 3。那么 6->7->8，3->4->5，1->2各位一组。调整后：1->2->5->4->3->8->7->6->null。其中 1，2不调整，因为不够一组。
这道题的难点在于，是从链表的尾部开始组起的，而不是从链表的头部，如果是头部的话，那我们还是比较容易做的，因为你可以遍历链表，每遍历 k 个就拆分为一组来逆序。但是从尾部的话就不一样了，因为是单链表，不能往后遍历组起。不过这道题肯定是用递归比较好做，对递归不大懂的建议看我之前写的一篇文章为什么你学不会递归？告别递归，谈谈我的一些经验，这篇文章写了关于递归的一些套路。
为什么你学不会递归？告别递归，谈谈我的一些经验
在做这道题之前，我们不仿先来看看如果从头部开始组起的话，应该怎么做呢？例如：链表:1->2->3->4->5->6->7->8->null, K = 3。调整后：3->2->1->6->5->4->7->8->null。其中 7，8不调整，因为不够一组。
对于这道题，如果你不知道怎么逆序一个单链表，那么可以看一下我之前写的如何优雅着反转单链表
如何优雅着反转单链表
这道题我们可以用递归来实现，假设方法reverseKNode()的功能是将单链表的每K个节点之间逆序(从头部开始组起的哦);reverse()方法的功能是将一个单链表逆序。
那么对于下面的这个单链表，其中 K = 3。

我们把前K个节点与后面的节点分割出来：

temp指向的剩余的链表，可以说是原问题的一个子问题。我们可以调用reverseKNode()方法将temp指向的链表每K个节点之间进行逆序。再调用reverse()方法把head指向的那3个节点进行逆序，结果如下：


再次声明，如果对这个递归看不大懂的，建议看下我那篇递归的文章

接着，我们只需要把这两部分给连接起来就可以了。最后的结果如下：

代码如下：
这两道题可以说是及其相似的了，只是一道从头部开始组起，这道从头部开始组起的，也是 leetcode 的第 25 题。而面试的时候，经常会进行变形，例如这道字节跳动的题，它变成从尾部开始组起，可能你一时之间就不知道该怎么弄了。当然，可能有人一下子就反应出来，把他秒杀了。
其实这道题很好做滴，你只需要先把单链表进行一次逆序，逆序之后就能转化为从头部开始组起了，然后按照我上面的解法，处理完之后，把结果再次逆序即搞定。两次逆序相当于没逆序。
例如对于链表（其中 K = 3）

我们把它从尾部开始组起，每 K 个节点为一组进行逆序。步骤如下
1、先进行逆序

逆序之后就可以把问题转化为从头部开始组起，每 K 个节点为一组进行逆序。
2、处理后的结果如下

3、接着在把结果逆序一次，结果如下

代码如下
类似于这种需要先进行逆序的还要两个链表相加，这道题字节跳动的笔试题也有出过，如下图的第二题

这道题就需要先把两个链表逆序，再节点间相加，最后在合并了。
关于链表的算法题，在面试的时候听说是挺常考的，大家可以多注意注意，遇到不错的链表算法题，也欢迎扔给我勒。
校招面试
算法面试
面试现场",
记一次手撕算法面试：字节跳动的面试官把我四连击了,"字节跳动这家公司，应该是所有秋招的公司中，对算法最重视的一个了，每次面试基本都会让你手撕算法，今天这篇文章就记录下当时被问到的几个算法题，并且每个算法题我都详细着给出了最优解，下面再现当时的面试场景。看完一定让你有所收获
大部分情况下，面试官都会问一个不怎么难的问题，不过你千万别太开心，因为这道题往往可以拓展出更多有难度的问题，或者一道题看起来很简单，但是给出最优解，确实很不容易的。这道题是这样的

给定一个只包括 ‘(‘，’)’的字符串，判断字符串是否有效。注：空字符串属于有效字符串

第一眼看到这道题，我去，这么简单，稳了（因为一面的时候，刚刚被面试官怼过勇者斗恶龙的DP题，在 leetcdoe 属于 hard 级别）。

其实这道题的 leetcode 第 20 题的简化版，属于 easy 级别

于是我也不假思索直接用栈来解决了，相信 99% 都会用栈解决吧？这里我稍微说以下过程吧，步骤如下：
1、在遍历字符串的过程中，遇到 “(” 就让它入栈，遇到 “)” 就判断下栈里面有没有 “(” ：
2、当字符串遍历完成，判断栈是否为空，如果为空则表示字符串有效，否则无效。
为了兼顾小白，我该给你们画了个图演示，，，，我太良心了。

代码如下所示（Java，不过不是学Java也能看懂）
接着面试官说我这道题的空间复杂度是 O(n)，问我能优化一下吗？
说实话，如果你做过 leetcode 的第 20 题，可能你的脑子会被定向也不一定，因为那道题用栈来处理就是最优解的了。不过这道题属于简化版，其实可以把空间复杂度优化成 O(1)，大家可以想一下哦。
由于我们栈里面存放的都是同一种字符 ""("" ，其实我们可以用一个变量来取代栈的，这个变量就记录 ""("" 的个数，遇到 ""("" 变量就加 1，遇到 "")"" 变量就减 1，栈为空就相当于变量的值为 0。
当时脑子有点不知为啥，就马上相当这个方法了，于是一分钟就修改好了代码，如下：
这样子的话，时间复杂度为 O(n)，空间复杂度为 O(1)。
接着面试官就继续就这道题继续加大难度，问题改为如下

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。


其实这道题就是 leetcode 的原题，第 32 题，难度为 hard。

这道题由于我之前做过，微微一笑，假装用严肃的表情思考一下，然后马上给出了思路，刚开始我是用暴力法的。
1、暴力法
暴力法其实很简单，就是最开始把第一个字符当做最长有效括号的首字符来遍历字符串，接着把第二个字符当做最长有效括号的首字符来遍历字符串，接着把第三个字符......
例如对于 s =  ""( ) ) ( ( ) )""。
把第一个字符作为首字符，则 max = 2 （遇到第三个字符 ')' 就匹配不了了）
把第二个字符作为首字符，则 max = 0 （一开始就是 ')'，显然啥也匹配不了）
把第三个字符作为首字符，则 max = 0
把第四个字符作为首字符，则 max = 4
.....
这种做法的时间复杂度为 O(n^2)，空间复杂度为 O(1)

基本上面那道题一样，只是做了 n 次遍历。

接着面试官问，还能优化吗？
早就知道会问优化的了，我自己之前也做过这道题，于是假装思考了一下，马上给出了优化。
2、优化
这道题的优化版本我们仍然是用栈来做，不过入栈的时候，不是让 ""("" 入栈，而是让 ""("" 的下标入栈。步骤如下：
1、先把 -1 放入栈内。（至于为什么？看到后面你就知道了）
2、、对于遇到的每个 '(' ，我们将它的下标放入栈中。
3、对于遇到的每个 ‘)’ ，我们弹出栈顶的元素并将当前元素的下标与遇到的‘(’元素的下标作差，得出当前有效括号字符串的长度。
通过这种方法，我们继续计算有效子字符串的长度，并最终返回最长有效子字符串的长度。
看不懂？没事，我弄个例子画几个图，例如 s = ""( ) ) ( ( ) )""，并且用变量 max 来保存最长有效字符串的程度，i 表示当前字符串的下标
0、初始化：max = 0; i = 0。-1 放入栈内

1、i = 0，s[i] = '('，下标 i = 0  入栈

2、i = 1，s[i] = ')'，出栈; i - 栈顶元素 = 1 - (-1) = 2，此时 max = 2

3、i = 2，s[i] = ')'，出栈；这个时候要注意：由于 -1 出栈后，栈顶没有元素了，所以这个时候我们必须把 ')' 的下标入栈，相当于最开始的初始化。

4、i = 3，s[i] = '('，入栈;

5、i = 4，s[i] = '('，入栈;

6、i = 5，s[i] = ')'，出栈；i - 栈顶 = 5 - 3 = 2；此时 max = 2;

7、i = 6，s[i] = ')'，出栈；i - 栈顶 = 6 - 2 = 4；此时 max = 4;

8、遍历结束，最长有效括号为 4。
看不大懂？没事，看下代码加深理解勒，代码如下：
这种做法的时间复杂度为 O(n)，空间复杂度为 O(n)，能想到用栈来处理，算是很不错的了。
我以为我给出这个解法算是可以的了，面试官应该换一道题的了，然后，面试官又来了一句：还能再优化吗？。这个时候我陷入了沉思.......
看文章的各位大佬们可以想一想在空间上是否还能优化，因为在时间上是不可能优化的了。
想了一会，居然不可以用栈，优化的方案肯定是类似于上面那道题一样，用记录数量的变量来代替栈，然后就被我想出了，具体如下：
实际上，这道题仍然可以像上面那样，用变量来代替栈来优化，不过这个时候我们需要两个变量，我们假设变量为 left 和 right。
我们在从从左到右遍历字符串的过程中，用 left 记录 '(' 的数量，用 right 记录 ')' 的数量。并且在遍历的过程中：
1、如果 left == right，显然这个时候 right 个 ')' 都将一定能够得到匹配。所以当前的有效括号长度为 2 * right。然后更新 max。
2、如果 left < right，显然这个时候部分 ')' 一定得不到匹配，此时我们把 left 和 right 都置为 0。

当遍历完字符串，我们是否就得到最大长度的有效括号了呢？大家可以想一下
答是不可以的，我们还需要从右到左遍历计算一下。
为什么呢？
因为实际上 '(' 和 ')' 其实是等价的，为什么就不可以倒过来遍历计算呢？所以，千万别忽略了哈。
最后的代码如下：
这种做法的时间复杂度为 O(n)，空间复杂度为 O(1)。
说时候，最后一种方法还是比较难想到了，从这次面试中也可以看出，千万不要看一道题很简单，有些题要做出来很简单，但是，如果要以最优解的方式做出来，难度马上指数上升。。
如果你后面看不大懂，建议多看几遍哦，这道题考的频率还是挺高的，主要是可以做的方法多，每种方法的效率又不一样，不过我这里必须给你们的提醒，就是平时在做题的时候，一定要寻找最优解，而不是 ac 了就不管了，应该多看看别人的解法。
校招面试
算法面试
面试现场",
记一次阿里笔试：一行代码解决约瑟夫环问题的,"约瑟夫环问题算是很经典的题了，估计大家都听说过，然后我就在一次笔试中遇到了，下面我就用 3 种方法来详细讲解一下这道题，最后一种方法学了之后保证让你可以让你装逼。

问题描述：编号为 1-N 的 N 个士兵围坐在一起形成一个圆圈，从编号为 1 的士兵开始依次报数（1，2，3…这样依次报），数到 m 的 士兵会被杀死出列，之后的士兵再从 1 开始报数。直到最后剩下一士兵，求这个士兵的编号。

在大一第一次遇到这个题的时候，我是用数组做的，我猜绝大多数人也都知道怎么做。方法是这样的：
用一个数组来存放 1，2，3 … n 这 n 个编号，如图（这里我们假设n = 6, m = 3）

然后不停着遍历数组，对于被选中的编号，我们就做一个标记，例如编号 arr[2] = 3 被选中了，那么我们可以做一个标记，例如让 arr[2] = -1，来表示 arr[2] 存放的编号已经出局的了。

然后就按照这种方法，不停着遍历数组，不停着做标记，直到数组中只有一个元素是非 -1 的，这样，剩下的那个元素就是我们要找的元素了。我演示一下吧：

这种方法简单吗？思路简单，但是编码却没那么简单，临界条件特别多，每次遍历到数组最后一个元素的时候，还得重新设置下标为 0，并且遍历的时候还得判断该元素时候是否是 -1。感兴趣的可以动手写一下代码，用这种数组的方式做，千万不要觉得很简单，编码这个过程还是挺考验人的。
这种做法的时间复杂度是 O(n * m), 空间复杂度是 O(n);
学过链表的人，估计都会用链表来处理约瑟夫环问题，用链表来处理其实和上面处理的思路差不多，只是用链表来处理的时候，对于被选中的编号，不再是做标记，而是直接移除，因为从链表移除一个元素的时间复杂度很低，为 O(1)。当然，上面数组的方法你也可以采用移除的方式，不过数组移除的时间复杂度为 O(n)。所以采用链表的解决方法如下：
1、先创建一个环形链表来存放元素：

2、然后一边遍历链表一遍删除，直到链表只剩下一个节点，我这里就不全部演示了

代码如下：
核心代码
这种方法估计是最多人用的，时间复杂度为 O(n * m),空间复杂度是 O(n)。
还有更好的方法吗？答有，请往下看
其实这道题还可以用递归来解决，递归是思路是每次我们删除了某一个士兵之后，我们就对这些士兵重新编号，然后我们的难点就是找出删除前和删除后士兵编号的映射关系。
我们定义递归函数 f(n，m) 的返回结果是存活士兵的编号，显然当 n = 1 时，f(n, m) = 1。假如我们能够找出 f(n，m) 和 f(n-1，m) 之间的关系的话，我们就可以用递归的方式来解决了。我们假设人员数为 n, 报数到 m 的人就自杀。则刚开始的编号为
…
1
...
m - 2
m - 1
m
m + 1
m + 2
...
n
…
进行了一次删除之后，删除了编号为 m 的节点。删除之后，就只剩下 n - 1 个节点了，删除前和删除之后的编号转换关系为：
删除前     ---     删除后
…          ---      …
m - 2     ---     n - 2
m - 1    ---      n - 1
m         ----    无(因为编号被删除了)
m + 1     ---     1(因为下次就从这里报数了)
m + 2     ----     2
…         ----         …
新的环中只有 n - 1 个节点。且删除前编号为 m + 1, m + 2, m + 3 的节点成了删除后编号为 1， 2， 3 的节点。
假设 old 为删除之前的节点编号， new 为删除了一个节点之后的编号，则 old 与 new 之间的关系为 old = (new + m - 1) % n + 1。

注：有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1.
这样，我们就得出 f(n, m) 与 f(n - 1, m)之间的关系了，而 f(1, m) = 1.所以我们可以采用递归的方式来做。代码如下：

我去，两行代码搞定，而且时间复杂度是 O(n)，空间复杂度是O(1)，牛逼！那如果你想跟别人说，我想一行代码解决约瑟夫问题呢？答是没问题的，如下：
卧槽，以后面试官让你手写约瑟夫问题，你就扔这一行代码给它。
不过那次笔试时，并没有用递归的方法做，而是用链表的方式做，，，，，那时，不知道原来还能用一行代码搞定的，，，，欢迎各位大佬提供半行代码搞定的方法！
校招面试
算法面试
面试现场",
记一次阿里面试：面试挂在了 LRU 缓存算法设计上,"最近春招提前批也要打响了，我会在推送算法+计算机基础的文章下，尽快推一些面试相关的文章
大概是去年的三月份，在找春招实习的时候，面了一次阿里，然后第一面就是写算法题，然而万万没有想到的是，我居然挂在了 LRU 缓存算法上了，这可是我再熟悉不过的算法。。。。。。。今天就来分享一波，说不定，你也做不出！
一、勤于动脑，懒于行动的祸
当时做题的时候，自己想的太多了，感觉设计一个 LRU(Least recently used) 缓存算法，不会这么简单啊，于是理解错了题意（我也是服了，还能理解成这样，，，，），自己一波操作写了好多代码，后来卡住了，再去仔细看题，发现自己应该是理解错了，就是这么简单，设计一个 LRU 缓存算法。
不过这时时间就很紧了，按道理如果你真的对这个算法很熟，十分钟就能写出来了，但是，自己虽然理解 LRU 缓存算法的思想，也知道具体步骤，但之前却从来没有去动手写过，导致在写的时候，非常不熟练，也就是说，你感觉自己会 和你能够用代码完美着写出来是完全不是一回事。
所以在此提醒各位，如果可以，一定要自己用代码实现一遍自己自以为会的东西。千万不要觉得自己理解了思想，就不用去写代码了，独自撸一遍代码，才是真的理解了，而且面试的时候，需要你再记事本里打代码，不给你编译器的。。。。。。。
不过今天我带大家用代码来实现一遍 LRU 缓存算法，并且提供最优解，以后你在遇到这类型的题，保证你完美秒杀它。
设计并实现最近最少经用（LRU）缓存的数据结构。它应该支持以下操作：get 和 put。
get(key) – 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。
put(key, value) – 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，
使最近最少使用的项目无效。
进阶：
你是否可以在 O(1) 时间复杂度内执行两项操作？
示例：
我们要删的是最近最少使用的节点，一种比较容易想到的方法就是使用单链表这种数据结构来存储了。当我们进行 put 操作的时候，会出现以下几种情况：
1、如果要 put(key,value) 已经存在于链表之中了（根据key来判断），那么我们需要把链表中久的数据删除，然后把新的数据插入到链表的头部。、
2、如果要 put(key,value) 的数据没有存在于链表之后，我们我们需要判断下缓存区是否已满，如果满的话，则把链表尾部的节点删除，之后把新的数据插入到链表头部。如果没有满的话，直接把数据插入链表头部即可。
对于 get 操作，则会出现以下情况
1、如果要 get(key) 的数据存在于链表中，则把 value 返回，并且把该节点删除，删除之后把它插入到链表的头部。
2、如果要 get(key) 的数据不存在于链表之后，则直接返回 -1 即可。
大概的思路就是这样，不要觉得很简单，让你手写的话，十分钟你不一定手写的出来。具体的代码，为了不影响阅读，我在文章的最后面在放出来。
时间、空间复杂度分析
对于这种方法，put 和 get 都需要遍历链表查找数据是否存在，所以时间复杂度为 O(n)。空间复杂度为 O(1)。
在实际的应用中，当我们要去读取一个数据的时候，会先判断该数据是否存在于缓存器中，如果存在，则返回，如果不存在，则去别的地方查找该数据（例如磁盘），找到后在把该数据存放于缓存器中，在返回。
所以在实际的应用中，put 操作一般伴随着 get 操作，也就是说，get 操作的次数是比较多的，而且命中率也是相对比较高的，进而 put 操作的次数是比较少的，我们我们是可以考虑采用空间换时间的方式来加快我们的 get 的操作的。
例如我们可以用一个额外哈希表（例如HashMap）来存放 key-value，这样的话，我们的 get 操作就可以在 O(1) 的时间内寻找到目标节点，并且把 value 返回了。
然而，大家想一下，用了哈希表之后，get 操作真的能够在 O(1) 时间内完成吗？
用了哈希表之后，虽然我们能够在 O(1) 时间内找到目标元素，可以，我们还需要删除该元素，并且把该元素插入到链表头部啊，删除一个元素，我们是需要定位到这个元素的前驱的，然后定位到这个元素的前驱，是需要 O(n) 时间复杂度的。
最后的结果是，用了哈希表时候，最坏时间复杂度还是 O(1)，而空间复杂度也变为了 O(n)。
我们都已经能够在 O(1) 时间复杂度找到要删除的节点了，之所以还得花 O(n) 时间复杂度才能删除，主要是时间是花在了节点前驱的查找上，为了解决这个问题，其实，我们可以把单链表换成双链表，这样的话，我们就可以很好着解决这个问题了，而且，换成双链表之后，你会发现，它要比单链表的操作简单多了。
所以我们最后的方案是：双链表 + 哈希表，采用这两种数据结构的组合，我们的 get 操作就可以在 O(1) 时间复杂度内完成了。由于 put 操作我们要删除的节点一般是尾部节点，所以我们可以用一个变量 tai 时刻记录尾部节点的位置，这样的话，我们的 put 操作也可以在 O(1) 时间内完成了。
具体代码如下：
这里需要提醒的是，对于链表这种数据结构，头结点和尾节点是两个比较特殊的点，如果要删除的节点是头结点或者尾节点，我们一般要先对他们进行处理。
这里放一下单链表版本的吧
如果要时间，强烈建议自己手动实现一波。
校招面试
算法面试
面试现场",
记一次网易笔试：前缀和的应用,"8月3号参加了网易提前批的笔试，笔试时间 120 分钟，然后有 10 道选择题（20分）， 4 道编程题（80分）， 2 道主观题（20分）。可以说你编程题凉了那就基本凉了，其他做的再好也没有。所以时刻保持刷题还是很有必要。
这次网易的笔试题还是挺难，四道题都用到了不同的思想，可能你看了题目，然后看了别人的解析会感觉，咦，挺简单的，但是身处考场可能就完全不一样了，基本每道题给你的时间只有 20 分钟，而且还要我们自己处理输入、输出，由于平时大家刷 Leetcode 的时候都是自己给出个方法就可以了，无需考虑输入、输出，所以有些人对输入输出不是很熟悉，调试花了不少时间，所以我这里建议你一定要把标准输入、输出弄熟悉。
今天我要将的这道题是网易 8 月 3 号研发岗笔试的第一题，这道题涉及到前缀和的应用，所以我想借这道题给大家讲一讲前缀和相关的一些知识，以后大家遇到这道题，就可以快速秒杀了。
下面我描述下这道题，不过我给的描述是简化版的，实际上再做笔试题的时候，每道题的描述都巨长，一般都会根据实际场景来给出问题的，有些人可能阅读了十几分钟，然后不知道自己要干嘛，我这里给出最简化的版本。

有一个班级有 n 个人，给出 n 个元素，第 i 个元素代表 第 i 位同学的考试成绩，接下进行 m 次询问，每次询问给出一个数值 t ，表示第 t 个同学，然后需要我们输出第 t 个同学的成绩超过班级百分之几的人，百分数 p 可以这样算：p = (不超过第 t 个同学分数的人数 ) / n * 100%。输出的时候保留到小数点后 6 位，并且需要四舍五入。
输入描述：第一行输入两个数 n 和 m，两个数以空格隔开，表示 n 个同学和 m 次询问。第二行输入 n 个数值 ni，表示每个同学的分数，第三行输入 m 个数值mi，表示每次询问是询问第几个同学。（注意，这里 2<=n，m<=100000，0<=ni<=150，1<=mi<=n）
输出描述：输出 m 行，每一行输出一个百分数 p，代表超过班级百分之几的人。   
示例1：
输入 ：
3  2
50 60 70
1  2
输出
33.333333%
66.666667%

第一题大致是这样，不过不是和原题完全一样哈，再输入和输出有小许区别，以为你具体的输入输出我忘了。
那么这道题难吗？说实话不难，不过你可以先自己再脑子里想想怎么做比较好，或许在考场上 20 分钟你还真不一定做的出来。
有些人说，这还不简单，每次询问的时候，我都遍历一下所有人的成绩，这样的花时间复杂度是 O(n * m)，显然，如果你这样做，那么是一定通不过的，一定会超时。一般暴力法能够通过 20% ~ 30% 的测试用力，如果一道题 20 分的花，能拿到 4~6 分。如果你实在没思路，那么暴力也是个不错的选择。
1、二分法
这道题我是用二分法做的，就是先对所有人的成绩进行排序，不过排序的时候我们需要开一个新的数组来存储。然后每次查询的时候可以通过二分查找进行匹配，由于用到了排序，需要花 O(nlogn) 的时间，m 次查询花的时间大致为 O(mlogn)。所以平均时间复杂度可以算是 O((m+n)logn)。这个时间复杂度通过所有测试用例，代码如下(没学过java的也能看懂)：
不过这道题更好的做法是采用前缀和来做。题设中每个同学的分数不超过 150，不小于 0，那么我们可以用一个数组 arr，然后让 arr[i] 表示分数不超过 i 的人数。通过这种方式，我们可以把时间复杂度控制再 O(n+m)。直接看代码吧，会更好理解（这里我就不写输入的代码了，用a[]存放成绩，m[]存放m次询问）：
这种方法就叫做前缀和，用这种方法简单了很多。当然前缀和还有其他应用，例如：
如果给你一个数组 arr[]，然后进行 m 次询问，每次询问输入两个数 i，j（i <= j）。要求你输出 arr[i] ~ arr[j] 这个区间的和。这个时候就可以使用前缀和的方式了。

前缀和看起来还是挺简单的，不过再做题中，或许会有意想不到的作用，例如这次的笔试，所以今天给大家讲解一下。

最后我再问你一个和前缀和类似的问题，给你一串长度为n的数列a1,a2,a3......an，要求对a[i]~a[j]进行m次操作：

操作一：将a[L]~a[R]内的元素都加上P

操作二：将a[L]~a[R]内的元素都减去P

最后再给出一个询问求a[i]-a[j]内的元素之和。

这个你会怎么做呢？这个时候就涉及到差分的知识了，关于这个知识的应用，我会在后面的文章讲。大家也可以模仿前缀和的思路，想想这道题怎么做。
校招面试
算法面试
面试现场",
二本，从 0 到 1，终拿到腾讯 offer 了,"这是帅地让一位读者写的一份学习经历，这位读者，算是和帅地关系还不错的读者吧，他大一的时候就加了我微信了，当时还是经常骚扰我的，问这问那，甚至让我直接给他的算法题找 bug。。。。。但是，我看他挺真诚，并且每次都给我的朋友圈点赞，我也就每次都耐心回复他了（实不相瞒，经常朋友圈点赞还是有点用，，）

注意，当时帅地还在上学，并没有那么忙，不过现在帅地太忙了，这种问题基本不回复哈。

不夸张的说，我觉得，我还是给了他挺大的影响的，我一直跟他说，不需要按照学校的来，因为有些学校的学习气氛确实不好，编程这玩意，自学就够了，当时他也一直把我当作榜样，我入职了腾讯，也给了他信心，可能是因为，如果我拿不到大厂 offer，他就会觉得大厂 offer 贼难吧，但是我想说的是，大厂 offer，并没有想象中的难，前提是你从大一/大二就开始规划，把该学的都学了，那么真的不是很难。
这位读者，刚开始，我让他专心学算法，后面提前去学习计算机基础，深入学习一门语言，去做项目，功夫不负有心人，在今年的春招中，第一次投递腾讯，就拿到了 offer了。这位读者也是普通二本院校，所以我想把他的经历分享出来，给公众号的读者打打气，以下是他写的文章 + 帅地排版和修改。
Hello，首先自我介绍一下，我是一所普普通通的二本院校的大三学生，坐标江苏。
今年三月份拿到了腾讯实习的offer，人生中第一次面试是腾讯，部门是 TEG 的云架构，并且顺利签约，说实话内心还是挺高兴的，在这里和大家分享一下自己的经历。
下手要果断。不要怕自己不够好不够强，我大概是二月底开始投简历。我一开始使用了牛客网投简历的方式，很遗憾，记得牛客网公众号当时给我的等待面试安排直到现在我都没有收到安排，效率过慢，很容易失去机会。不过我的简历是很简单地使用牛客网的模板写的。
有了想法就果断去投，要去官网投！
帅地注：平时帅地让大家去牛客网，更多的是大家去那里找内推，查看公司招聘时间，笔试时间，最后还是要进去官网投递的，而不是在牛客网投递。
对于大概的需要学习的知识有：
我是遵循着越精简越好的做法写的。本来写了两三页，最后删删改改保留到了最后一页内容，无用的可以删掉，比如学生会经历啥的，基本没用，不过很多公司制定的简历都是要必填的话，可以都写上去。
如果是内推直接发简历的话建议写的少一些，把重点和亮点写上去，让 hr 一眼就直接看见，包含了一定需要的信息，比如姓名学校什么的，自己比较擅长的知识，比如说 redis，爬虫，linux，或者对 jvm 理解比较深，也可以强调一下，面试官会针对着你的简历去问。
项目的话不要太大众化，也千万不要造假，最好是自己真的比较熟悉的，面试官会问有没有 github 链接，这个时候如果没有还是比较尴尬的，可以分条写下重点内容、利用的知识点，最后可以总结不足之处，遇到困难如何解决，后期会如何去改进。项目不用很多，我写的是2个，不过越多一般会比较好，前提是比较有价值的。
腾讯基本上是必问，特别是 TEG这 些部门，我的三轮技术面每一轮都是从计算机网络开始问的，而且问了还挺久的，一定要重视 TCP 协议，三面面试官让我讲TCP 里面的各种机制，然后我因为时间间隔久，说的就比较乱，这里建议可以自己整理一个大纲，然后好好填充，最后复习，不要抄网上的，一个是各种版本太多，还有的是不一定完全正确。
我是从大一开始就看计算机网络自顶向下方法这本书，大概断断续续读了有两三遍，这本书在本科应付面试还是够了。我也只读了这一本书，我觉得自定向下的方式还是挺好的，和 csapp 不太一样，计网还是举了很多比较通俗的小例子，比如邮递员啊，一家人和邻居的互动这些，看着还是挺有趣的，前六章一定要读懂，记住关键知识点。
在校招的层次上，这本书已经是很详细了。举个例子，面试有一个高频题目，就是 web 页面请求的过程，可能大家看过面经的都会粗略的说什么 DNS 查询啊，三次握手，浏览器解析，但是这个问题其实在书上的 326~331 页上有十分详细的过程，同时也囊过了前六章的非常多的知识点，书中是用Bob用他的便携机在学校查询了 www.google.com 主页来举例。你说的越详细，面试官对你越评分会越高。
操作系统是我比较薄弱的地方，我看 csapp 都挺吃力的，经常看的犯困，当时学校教的其实也比较水，就是直接教你怎么算，然后出英文试卷，相当于背题应试。那怎么够呢，我因为看书吃力，于是选择了看 b 站清华大学的操作系统课，老师是向勇和陈渝，对于我这种比较笨的人还是挺友好的，然后对应着 csapp 来看，会好一些。
还有就是 linux，似乎很多面试官会问你平时是不是使用 Linux 编程，我直接就怂，虽然平时项目上线会用 linux，不过我大概只知道一些指令，比如 ps, netstat 这些，然后去 proc 查查 cpu 状态，这个三面面试官也问了，你平时如何查看 cpu 状态，如何查看内存占用情况，如何定位程序出错的地方（大概是）。
然后我就开始扯什么 top 啊，什么利用率负载率啊。最后还算是扯过去了，二面面试官也针对 Linux 问了挺多的，遇到不会的就诚实的说不会，不要强行去解释，也不要逞能，这样会被怼的很惨。三面的时候面试官还问我磁盘问题，RAID1-5，我觉得这个对我来说还是挺深的…
这里扯下 java 的，二面面试官针对java问的比较多，一和三基本没问。
其实我二面是答得最不好的一轮，很多概念模糊了，也犹豫了挺久的，比如他问我抽象类和接口的区别，我大概还是一年前看的了，当时我努力搜寻记忆中的概念…，憋了好一会才憋出来几个区别，不过事后看看真的很简单，基本上是看了一遍就回忆出来了，大概还有类继承的一些问题，jvm 让我每一块分开来说，面向对象，我每个说的都不太详细，还是挺遗憾的，因为我真的对java太有信心了，一直没去复习看它，结果眼高手低了。
所以千万不要放弃每一个知识点，然后聊了一下 go 语言，我之前有去看过云风 c 语言写的协程，大概了解了一些。java 我看的书是 JAVA核心卷，Thinking in Java，effective Java，其实我觉得这三本书是挺够的了，特别是 Thinking in Java，初看是略看，然后多看几次，就能注意到很多细节，而细节往往可以决定成败。
其实说是三本书，还有很多是不必看的，比如 Swing 编程这些。核心卷对于入门来说非常友好，因为很简单。Effective Java 放在最后看，往往是优化代码，让代码更加安全、性能高、优雅。
多线程
我用的是 java 并发编程的艺术这本书，多线程一定要好好学，项目中一定是常用到的，然后推荐大家看一看并发编程网，里面的内容基本是很优秀的。很多是国外搬运翻译的。
算法靠刷，刷多了有题感，不过腾讯是挺爱问排序算法的，那基本的稳定和不稳定排序算法是要熟悉的，比如我二面问了希尔排序，我本来以为大概率是问快速排序的，然后希尔时间复杂度我还说错了，，，，
好在其他我都记得比较熟悉，堆排序，快速排序（随机选基数，三路快排）等，归并排序（我觉得这个很重要，因为 java 的 sort 就是用的快速排序+归并排序），而且归并排序是稳定排序。基于归并排序的算法题延申的都挺多的，有看到其他大厂的笔试算法题就是归并。
算法的话，如果时间充足，比如我是大一寒假开始写算法，我是每一题自己钻，然后看题解，往往一天只写两三题。目前为止刷题总数 leetcode + 牛客，加上一些 OJ 平台，大概是 600+ 的题量，可惜腾讯的面试里问的算法不怎么多…，这里总结一下必要的算法知识，首先是数据结构每一个都需要很熟悉，比如链表，哈希表，树，图，栈，队列，堆。
（1）链表，什么反转链表，环形链表，链表排序等等算法，比如 LRU，就是用一个双向链表 + HashMap 来实现。别看链表基础，但是很多大厂是挺喜欢链表的，比如字节跳动，再比如跳跃表，是 redis 里的 zset 的底层实现。
（2）哈希表，最好要理解底层实现，建议看源码，一定要清楚如何实现。用处也是非常非常多。比如记忆化递归在有时候数组不适用的情况就是用 map，还有HashSet，TreeSet，这些的源码都建议去看。哈希表的用处还非常广泛，这个基本是最常用的数据结构。
（3）树，树有很多，二叉搜索树，AVL 树，红黑树（旋转不如AVL频繁），字典树（敏感词过滤）等，leetcode 树专题，不要犹豫，直接刷，腾讯这次笔试也有树的题目。而且很容易变种，树基本是以递归，不过也会有题目要求使用非递归，这个时候就要用栈和队列来辅助，比如迭代方式前序遍历。关于树的算法题太多了，有一阵子 leetcode 周赛，每次第三题都是树。
（4）图，图的考察点不如以上频繁，大概是有向图，无向图，BFS 和 DFS，还有拓扑排序，Dijkstra 最短路径，Krusal 最小生成树等等。
（5）栈，用法也是多，感觉很多情况是和字符串挂钩，更难一些的是单调栈，某年京东除了一题很难的题目，就是用单调栈。
（6）队列，用法也是很多，比如拓扑排序，求二进制，BFS 等等。
（7）堆，很多时候有妙用，比如拓扑排序，Top K 问题。
以上数据结构一定要很熟悉，应用实在是太广泛了。我大一的时候，用c语言写动态扩容栈、队列，红黑树，斐波那契堆，二叉堆，有向图（包含各种算法），AVL树等挺难的数据结构，如果时间充足可以这么写着玩，锻炼coding能力。
重要的算法有：二分，递归，记忆化递归，回溯，广度优先，动态规划，数学（有蛮多脑筋急转弯题目的），滑动窗口（双指针），排序算法，程序设计（比如设计LRU，LFU）。
如果写后台那大概率是和数据库打交道的，这里推荐大家学习 Mysql，redis，mongoDB。MySQL 可以学习的太多了，首先要写得一手好 sql 语句，这里要注意利用到索引，减少表连接，提高 sql 效率等等，leetcode 上直接就用 sql 练习，刷个几十道足够。
然后深入一点，学习引擎，索引（聚簇索引，二级索引，B+树，Hash索引，最左匹配等），ACID特性等等，索引是重点，三面的时候详细问了B+树，然后就扯到了索引。这里建议重视一下索引，一是它是真的非常有意思，二是它真的很重点…
关于 NoSql，看的出来三面面试官是挺挖掘深度的，对于项目，数据库，操作系统，计网，问的都是挺细节挺深的，他问我聊不了解 MongoDB，我说用过但不是很了解，是以前写爬虫的时候配合用的，可以有什么什么用，扯了一堆。然后 redis 也问了，比如主从辅助，哨兵，选举机制，分区集群，等等。还好我redis学的还可以，都答上来了。
redis是绝对值得认真学习的。
我投了提前批，所以直接参加面试。3.5 给了通知，我刚好到南京见到了女朋友，结果傍晚通知就来了，于是晚上一起在南京吃了一顿索然无味的饭，明明菜做的非常好…
帅地注：如果可以，一定要参加提前批。
3.8 在常州初面，面试官很随和，带着耳机，我自我介绍到一半然后网断了，于是接下来的自我介绍他都没听见，笑着叫我重说，我突然也就不紧张了。上来直接问计算机网络，也没紧张，流畅的答完了，记得的问题就是TCP和UDP，三次握手，为啥不能二次握手，浏览器输入URL，还有的也记不得了，问的挺多的计算机网络，然后似乎对其他没什么兴趣就直接问了项目。
问了 nginx，分布式锁实现，分布式限流实现，令牌桶算法和漏桶算法，除了这些算法你还有什么思路，这些算法的优缺点比较，redis做什么用，优点？异步阻塞队列？和kafka比较？聊天系统，为什么两个项目使用的MQ不一样，MQ对比，心跳机制和选举机制。
大概是这些，总的来说答得还可以，也蛮流畅的，最后问面试官优缺点，他说优点是比较帅，我于是开始觉得我说的并不怎么样…然后第二天早上就接到了二面通知。
3.10 晚上 8 点，我一边喝红牛一边等电话，二面面试官声音比较成熟一些，态度也比较正式，不过人超好，认真的介绍了自己，我一开始都没听清TEG部门…，
然后二面其实说的不怎么好，一开始一样是怼了计网，有一个问题一面面试官问过了，于是我告诉他上一个面试官问过了，然后他就跳过了，印象深的是状态码，从1-5我都说了一些，其中我还说错了，我说我项目中经常看见的Method not allowed，我说成了403，结果是400…很尴尬。
然后怼了java基础，jvm, 排序算法，我说的真的不是很好，因为过于自信…，这一面反而项目问的不怎么多。然后了解了我的性格，学习态度，有点像 HR 面，我中间紧张的时候还安慰了我，说没事喝口水。
然后有的记不得了也耐心等待我，然后聊了聊第一个项目中微信支付怎么做的，其实没什么技术含量…还有一些项目点大概忘了，聊了一下 go 语言。然后我做了一件愚蠢的事情，我问面试官我还有下一面吗，面试官告诉我不管在哪个公司问这个都是不好的，我心里凉凉的…
大家切记…最后说我总体来说挺不错的，可能有些基础忘了，但是其他方面还是不错的。结束了以后我还是挺沮丧的，觉得自己肯定挂了。
然后 3.11 下午躺在宿舍床上接到了深圳总部的电话，是一个声音挺年轻的男声，后来才知道是部门主管…，
约了一下三面技术面时间，我选择了14号周日，然后安排了一下上午的时间，于是愉快（煎熬）地等待。
在学校咖啡馆面试，感觉压迫感还是蛮重得，首先考察计网，很多问题还是在面经上没有的，结合了实际场景，感觉也是在挖掘深度，怼了我的项目，问的很详细，从分布式限流，然后solr，redis分区集群，Linux，定位项目问题，查看cpu状态等，主从复制，哨兵等等，B+树，数据库。
然后说我们部门也负责的数据库，然后我哇，好厉害（确实很厉害），然后操作系统，磁盘，我坦白操作系统是我比较薄弱的地方就不往下问了，还问了存储计算分离，锁，定位功能和附近景区附近的人实现，总的来说还是感觉在挖掘深度。
然后问我兴趣爱好，我说弹钢琴和看动漫，进击的巨人你看过吗，他说你咋不说鬼灭之刃呢，恰好我寒假补完了鬼灭…，感觉人还是很亲和友好的，聊的很开心，最后我问是哪个部门呀，他说是TEG，说实话我心里是非常开心的，因为我是真的喜欢TEG。
最后 3.16HR面试，不得不说腾讯效率高，基本是隔一天就会进入下一轮。HR面也聊了挺久的，从各方面来问，然后让我讲第一个项目从头到尾的过程，我就说了很多很多，从技术方面和团队方面，解决问题，代码规范，然后讲了一下自己的经历，了解了一下家庭情况等等。
最后过了几天打电话给了口头offer，聊了一下薪资，确定了地点是实习时间，当然是开心的不行了。第二天电子offer就发来了，于是愉快的签约。
三个面试官真的都超好，人非常亲和，腾讯效率是真的很棒，总的来说面试体验非常非常好。
帅地注：不得不说，腾讯的面试官真的好评。
首先要感谢一些人，一直支持我的家人，给我提供好的条件，关心我的身体。
然后是女朋友，面试是一路陪我过来的，每一轮面试都默默陪着我，在心情不好的时候安慰我，鼓励我，会一直走下去。
接着是地哥（公众号帅地玩编程），从我大一就一直给我帮助，我有的时候发了一题算法题，过了一会就把详解给我，打的字都超多，平时很忙也没敷衍我，不厌其烦地帮我解答，公众号内容也很赞，干货满满，非常感谢。
然后是我的舍友们，大一是一位舍友，也是兄弟，教了我第一个 C 语言程序，看着小黑框，莫名的成就感油然而生。也是他给了我很多路线上的帮助，我记得大一我学不会指针，他骂了我一顿，然后教我，我还真被给骂会了，我的学习态度也是被他感染的吧，解决一个问题一晚上不睡，吃饭也在思考遇到的问题。
现在虽然人在英国，不过也保持着联系，交流学习，互相帮忙。还有一个搞前端的舍友，我们学校第一前端，和我一起经历了很多时光，一起工作一起玩乐，陪我度过艰难的时刻，感情深厚。
写这篇文章是想告诉一些新人朋友们，不管学校是好是坏，只要自己相信自己，永远不服输，永远认为自己可以，那么你一定可以，学校其实真的不是很重要，重要的是你这个人如何。我以前也很迷茫，觉得一个二本学校怎么可能去大厂，但是事实上不要考虑那么多，人生也是如此，只管不断前进就好了。
无论是春招还是秋招，也无论拿到什么样的 offer，这绝对不是终点，而是人生另外一个重要的起点，为了让我们以后有更多的选择，我们都得持续学习，只有持续学习，我们才能变的更强，当然，所谓学习 ，绝对不局限于编程知识哦。
最后，欢迎大家加入帅地的知识星球，其实大部分情况下，大家都很努力，如果有个过来人指点一下，推一把，或许你可以走的更快

如果你没有自己明确的学习路线，完全可以跟着帅地星球的 PDF 学，完整的学习攻略 + 资料都提供了，而且都是优质资料

关于电子书，具体可以看这篇文章：第一本原创 PDF，帅地肝完了
第一本原创 PDF，帅地肝完了
每当春秋招来临，一份好的简历可以让你拥有更大的面试机会，帅地也可以帮你修改优化简历。

帅地会在星球知无不言，无论是 学习规划，offer 选择，简历修改，还是学习路线，帅地都会在 48 小时以内答复你的问题，并且根据你自身的情况，为你量身定制学习路线。
星球已经有 1300+ 位帅友，这里还有一些 20 元的优惠券，如果你信的过帅地，那么欢迎你的加入，或许可以让你少走很多弯路，即使后悔了，也能 72 小时无条件退款。

知识星球详情：知识星球
知识星球
读者的 offer 之路",
关于春秋招的一切,"对于日后需要找工作的同学来说，春招/秋招可以说是学生生涯中非常重要的一战，但是我发现很多人却对春秋招的了解甚少，有些人甚至以为是毕业之后再开始找工作，进而导致了找工作的最佳时间段。
说实话，要嘛错过春秋招，要嘛临时抱佛脚准备春秋招的人，我可以说是经常遇到，加上我公众号的读者里，学生较多，所以我觉得有必要写一篇关于春秋招的文章，供大家一个参考。
如果你对春秋招不怎么了解，或者不知道怎么准备春秋招，又或者想看看我是如何准备春秋招的，那么还是建议大家好好看一看这篇文章，我这篇文章会写的比较详细，大家也可以根据目录来看。
春招开始的大致时间：每年的 3 月 ～ 5 月。
#####（1）春招是找实习的最佳时机
对于计算机专业的学生来说，如果学校允许，大部分人都会在大三/研二的暑假去各大公司实习，但是大家必须记住的是，这个实习 offer 并不是在暑假期间找的，而是在春招期间找到。
也就说，春招最重要的目的，就是找实习，基本各大公司都会在春招期间发出大量的实习 offer，你在 3 ～ 5 月份拿到实习 offer 之后，可以等到暑假再去公司实习。当然，你拿到 实习 offer 之后，也可以马上申请去公司实习，这主要取决于你（当然，公司不给提前去的话，那就没办法了）。
对于毕业后要直接工作的同学来说，我建议你一定一定要参加春招！
如果你能在春招拿到不错的实习 offer，这不仅让你有了实习经历，甚至还有很大的概率直接在公司转正，就算在春招没拿到 offer，那么也不亏，通过春招的多轮面试，可以让你积累的很多面试经验。
实不相瞒，我在春招就很惨了，面了几家公司，都由于各种各样的原因被刷了，这让我积累的很多面试经验。我觉得自己能够在秋招的提前批就拿到 offer，春招的面试经历是立了很大功劳的。
今年的春招刚过不久，对于现在大二/研一的同学来说，如果要参加明年的春招，我觉得最好提前准备吧。
对于秋招没有找到工作，或者没有找到满意工作或者考验失败要去找工作的同学来说，那么春招，将是你最后一次以校招的身份去找工作了。
不过这个时候，公司只有少量的 offer 了，大量的 offer 都已经在秋招发出去了。当然，竞争的人也少了很多，很多大佬已经在秋招拿了满意的 offer ，不会来跟你竞争了，你的对手估计就是那些考研失败/没有找到工作/没有找到满意工作的学生，所以在最后的这次春招中，找到工作的机会还是非常大了。
所以，对于大四/研三的同学来说，如果在秋招没有找到工作，一定要抓住 3 ～ 5 月份的春招。
秋招开始的大致时间：每年的 8 月 ～ 10 月。
是的，春招最主要的目的是找实习，并且面向大三/研二；而秋招最重要的目的就是，找正式工作的 offer，面向准大四/研二的你。
对于毕业后要找工作的同学，你可千万不能错过，各大公司将会在秋招派出大量的 offer，你也会在秋招期间被笔试虐，被面试官虐，还没面试就被刷简历……总之，秋招，真的很累，每天不停笔试面试，不停被刷……当然，大佬除外。
不过这里有个问题需要说下，秋招 8 月份就开启了，然而我还在公司实习怎么办？
还能怎么办，当然是一边实习一遍偷偷面试笔试，我那会七月底开始投递简历，八月一边实习一边疯狂参加笔试面试，大家都是这样的，不过大部分公司的笔试，往往都是在晚上，我觉得完全有时间参加；面试的话，有些你也可以和面试官商量面试的时间。
当然，如果你刚好在理想的公司实习，并且感觉自己转正的概率挺大，那么我觉得你还是要好好准备一下转正相关的工作，例如答辩啥的。如果成功转正的话，就舒服很多了，不需要跳入秋招这个火海。
春招和秋招的流程其实差不多，大概都是：
（1）投递简历：一般去各大招聘网站投递/官网投递，后面说。
（2）笔试：大部分公司都会有笔试环节，对于很多互联网大厂来说，这个笔试成绩将直接影响你能否进入面试环节，所以说，笔试成绩非常非常重要，并且笔试中最重要的部分就是编程题，编程题绝大部份都是算法题，例如像字节、拼多多、腾讯这些大公司，笔试可能全部都是算法题，一般 3 ～ 5道，时间 120 分钟。
（3）面试：能够进入面试环节，其实也挺不容易，笔试成绩好，面试机会真的会多很多，笔试做的差，你的面试机会真的会少很多，面试一般是 2～3 轮技术面 + 1 轮 HR 面。并且大部分公司都支持远程面试，持续时间 1 周 ～ 1 个月，如果是现场面试的话，就很快，可能一次性面完技术面。
（4）意向书、录用通知书、签三方啥的，能到这个环节的话，那么恭喜你了，99% 稳了。
对于内推，在当时我也百度过什么是内推，也看过很多回答，然而对内推的含义以及流程啥的，依旧不是很懂。所以我今天就以回答问题的形式谈一谈对内推的理解。
什么是内推
显然，内推就是内部员工的推荐。指在求职中，不通过常规的简历投递渠道（包括但不限于网申、双选会、宣讲会现场投递）等方式，而是通过已经在某企业就职的内部员工，将各方面条件优秀的求职者的简历直接投递到HR或部门负责人手中的一种招聘手段。
内推和自己去官网投递有什么区别吗？
对于校招生来说，我认为区别不大。在我看来，内推只是另外一种简历的投递渠道而已，并不存在免笔试/走绿色通道的优势，当然，我指的是在大部分情况下是这样，有个别走绿色通道也是有可能。
到时候你可以去牛客网或者各大招聘公众号看，内推可以说是满天飞，基本没啥门槛，扫码/点击链接即可参加内推，我说这些数据只是想跟你说，通过内推的渠道去投递简历与通过其他渠道去投递简历，区别不大，千万不要觉得有了内推，感觉自己多了很多优势。
内推依然需要经简历筛选，有些依然需要笔试，是的，依然需要笔试。我秋招投递的简历，80% 都是通过内推链接填写的，但好些依然需要笔试，这个还得看公司，不过通过内推形式的话，你可以找内推人查询自己的简历状态，可能这也是内推的一种好处吧。
所以，总的来说就是，内推就是简历的另外一种投递方式，并不存在多大的优势，但也没啥坏处（除了把你的简历暴露给内推人知道了），所以如果有内推，还是可以参加。
基本大部分公司都会有提前批，我还是非常建议大家参加提前批，如果你提前批失败了，那么依然不影响你参加正式批，并且各大公司会在提前批发出大量的 offer，我秋招时就是在提前批拿了 offer 之后，就早早结束秋招了。
例如正式批 9 月份开始的话，可能提前批 8 月份就开始了，建议大家不要错过。
有人可能会问，提前批失败了会影响正式批吗？
我认为影响不大，虽然你失败了，有些公司的系统会记录的面试情况，但我认为影响不大。我参加春秋招那会，有人面试阿里，在秋招失败了好几次，最后还是进了，腾讯也是有好多次面试机会，前面面的很差，后面还是进了。也就是说，提前批失败了，比起你多了一次面试机会，那么我会选择多一次面试机会。
不过我必须说明的是，提前批会比正式批难
是的，提前批高手如云，很多大佬都会参加提前批，并且各大公司在提前批的要求可能也会高一些，毕竟名额有限，大家都想招优秀一点的人，那么提前批肯定会提高要求，反正提前批 offer 有剩的话，我可以在正式批发出，所以提前批会比较难，但这不能阻碍我们去参加提前批，
对于投递渠道，其实我这还真的没啥渠道，我就只有两个渠道：牛客网 + 公众号。
这里我必须强调一个点，很多人跟我说，大公司都没来我们学校宣传，我连投递大公司的机会都没有。每次看到这样的人，我就知道这人对校招一点也不了解。
大公司的战场，不在校园宣传，而是在网上，基本各大公司，你都可以在网上进行简历投递。实不相瞒，学校的校园招聘，我一场都没参加过，我简历基本都是通过牛客网 + 公众号 + 官网投递的。
我觉得，牛客网 + 公众号，可以满足大部分人了，例如在牛客网上，在求职讨论区那里，会有非常多的内推，建议的多关注。并且里面也汇聚了各大公司的招聘时间等，而且也有很多大佬在那里分享面经。
而公众号的话，如果你对哪个公司感兴趣，完全可以去关注这个公司的公众号，例如你对腾讯感兴趣，可以关注腾讯招聘，例如你对字节感兴趣，可以关注字节招聘，这些公众号，会第一时间告知你校招的开启时间以及简历投递方式。
所以，对于投递渠道，我推荐牛客网（https://www.nowcoder.com/） + 微信公众号，至于一些其他的招聘 app，大家可以去百度搜索下。
实不相瞒，春招我特么没准备过，所以我春招被刷了几家之后，我就意识到自己的问题的，于是从 6 月份我就开始准备了，我准备的是 Java后端开发的岗位，如果你也是面试开发岗，那么我的这些你可以做一个参考，我会屏蔽语言特性。
我认为在校招中，最重要的就是算法 + 基础知识 + 项目了。并且这三个模块，完全可以同时进行准备。
我刚才说过，对于很多大公司，笔试将直接影响你是否获得面试的机会，而笔试的大部分题目都是算法题，所以算法就显的非常重要了。
不得不说，算法可以说是很多人的软肋，并且算法不容易短时间提升，所以我建议你，一定要长期保持刷题，如果你是要准备即将到来的秋招，我建议你现在就可以刷了，那么刷哪些题呢？
我建议你先刷《剑指 offer》这本书的题，不过我并没有买这本书，而是在牛客网把剑指 offer 的 66 道编程题都刷了一遍，总的来说，这些题并不难，不过里面包括了很多种常考题型，掌握这 66 道题，一定可以在面试中给你很大的帮助。
刷完剑指 offer，如果你想挑战难一点的，那么我给你推荐另外一本书《程序员代码面试指南:IT名企算法与数据结构题目最优解》，这本书有点难度，不过总结了非常多的题型，适合应付笔试。因为笔试中的题，比面试中的题，难多了。
不过如果你觉得自己刷这本书太吃力了，那么也可以去 leetcode 刷那些 top100 之类的题，反正我是不建议从第 1 题刷到第 n 题这种模式，当然，我这里不是教你怎么学算法，而是如果你不知道怎么准备校招的话，或许可以按照我说的这个来。
总的来说就是：先刷剑指 offer，不过剑指 offer 应付面试还好，应付笔试我觉得不行，而《程序员代码面试指南:IT名企算法与数据结构题目最优解》这本书，我觉得应付笔试挺不错，不过挺难。然后如果你 leetcode 那些热门题没刷过的话，我其实也建议你去看一看，一步一步来。
我自己的话，其实就刷了 剑指 offer，然后刷了牛客网那些 sql 的题，之后刷了部分《程序员代码面试指南:IT名企算法与数据结构题目最优解》的题，这两本书在这里就能找到电子版下载：计算机书籍免费下载（高清带目录完整PDF版）
计算机书籍免费下载（高清带目录完整PDF版）
基础知识我自己其实强调过很多次了，也没什么好说的，我觉得除了深入准备一门语言外，剩下的就是准备基础知识了，我公众号也发过好多，主要就是这几门：计算机网络 + Mysql + 操作系统 + Linux常用命令。如果你没时间准备了，那么我推荐在这个 github 来学习：https://github.com/CyC2018/CS-Notes
我觉得操作系统在这里学习就可以了，感觉操作系统、Linux这些问的不深，对于计算机网络，如果可以，我还是建议你可以刷下《图解HTTP》这本书，很快就能看完了，电子版在里 就能找到：计算机书籍免费下载（高清带目录完整PDF版）
计算机书籍免费下载（高清带目录完整PDF版）
当然，一定要做笔记，因为太多了，做笔记方便复习，我做的是很简洁的笔记的，我把自己整理的思维导图送给大家吧。
九大思维导图助你拿到心仪的 offer

打开计算机网络的思维导图长这样

由于链接容易失效，不方便更新，大家可以在我的微信公众号帅地玩编程回复思维导图，即可获取九大思维导图，相信一定可以在面试时助你一臂之力。
我觉得我整理的这些，你可以看看，根据我的来查漏补缺，基本大部分都整理了，虽然不怎么详细，不过应该可以看的懂。
对于项目的话，其实我自己是突击的，我项目做的太少了，所以这里也给不了太多的建议。不过，项目我觉得不在于多高大上，而是在于你学到了什么，你在这个项目中的思考以及使用到的技术。
如果你没有项目的话，要嘛自己去找资源，要嘛花点钱去买，其实我更加建议大家话花点钱去买，例如去慕课网、网易云这些课堂买，其实也就是几百块钱，买的课程，资料比较全，可以节省你好多时间，相当于花钱买时间，并且可以看项目的评价、用到的技术栈之类的，所以呢，我这里建议没有项目的小伙伴，或许可以考虑下勒。
这篇文章基本详细介绍了春招以及秋招，并且也给大家介绍了需要准备的核心知识，在知识准备上虽然没有说的很细，但也大部分讲到了，因为篇幅有限，我不可能一一展开。当然，我说的这些不可能适合每一个人，更多的是，给你一个参考。
最后帅地也祝即将参考秋招的同学能够拿到满意的 offer，还处于大一大二的同学，则赶紧找到自己的发力点，加油！
校招之路",
春招面了两次腾讯都挂了,"如果你提前批和正常网申都投的话，可能会获得两次笔试/面试的机会，我投了两次腾讯，不过，两次都在二面挂了，特别是第二次二面，我真的决定自己太他妈傻了。作为一个新人，谈谈我面试过程中犯过的一些错吧，或许对你也有点收获。
腾讯提前批的面试应该是一个月前就开始的，我第一个投的公司就是腾讯了，人生的第一次笔试和面试也献给了腾讯。先说下笔试吧，笔试是 5 道编程题，个人觉得，腾讯的笔试题比较简单吧，也就是说，获得腾讯的面试机会应该算是不难的吧，5 道我好像是做出了 3道 + 一道90%测试用例通过 + 一道也是百分之几十来着的，忘了。
最后的结论就是，个人感觉腾讯笔试不怎么难，投了之后获得面试的机会应该非常大，我的简历背景是没有任何亮点的，没有啥比赛，没拿过啥奖，非211/985，普通一本。这里建议秋招有兴趣的一定要投一下，万一面试也过了呢，腾讯技术研发实习一般是 2轮技术 + 一轮HR面，万一2轮技术面过了拿offer机会还是挺大，有时候就会多加一轮技术面。
当然，我听说前端的 HR 面是综合面，听说比前面的两轮还难还难过。
一面是视频面，人生第一次面试，可以说我是很紧张的，一面我完全就是个小白啥套路也不懂，面试官问啥我答啥，完全不会引导，面试完后我感觉自己是真的傻，主要是问了一下问题：
1、浏览器输入一个地址回车之后都发生了啥？
这个可以说是非常高频的面试题了，我觉得自己这方面还可以，压抑自己的紧张，好好详细秀一波，然而，由于我事先并没有去准备过这个问题，而这个问题又涉及到很多步骤，所以我在逻辑上讲非非常非常不好，卡住了好几下，最后不管三七二十一，就说关键词了：有DNS转换啊，ip网络寻址啊，三次挥手啊，可能还有NAT地址转换啊，还有ARP啊。
可能平时看我文章的人会发现，我是喜欢把这些技术一点点推出来，有逻辑着连起来的，这样说出来会特别舒服，不过我这次面试的时候，连不起来的，归根到底就是，没有准备，头脑觉得自己都懂，但是不意味着讲的出来，所以我在这里是建议各位，对于那些高频的面试题，自己最后尝试着口头去表述一下，或者文字书写一下，要是你来回答，你会怎么说？
2、TCP 和 UTP 有什么区别？
我在回答这道题的时候，也是非常简单着回答他们的区别，例如一个面向连接一个非面向连接，一个可靠一个非可靠，非常简单就答完的。
不过这道题是一个高频题目，按上面的那个回答，就算回答出来，我觉得也是一点优势都没有。因为这些简单的区别，99%的人都懂，我觉得我们应该再往深入回答，例如TCP有流量控制，拥塞控制，面向流以及基于这些区别，他们的使用场景等等。
不过我并没有回答，不是我不知道，而是我想假装不说，等着他来问，因为我听说面试官都会一直往深问到你不会为止，然而现实是他并没有问，换话题了。感觉自己错过了一些表现的机会。
这里我想说的就是：如果你知道，你可以多说一点，千万别像我这么傻，等着别人来问。
3、写个快速排序
和算法有关的，我觉得自己还好，写的虽然不是特别快，但感觉自己写的还好，无论是从代码的排版（因为这个一般都是在笔记本写的，不可能给你IDE），以及代码的简便程度，我觉得都不错，这里我想说的就是，自己平时写代码的时候，一定要注意排版，别老是依靠IDE给你一键排版。
虽然我已经写出来了，不过他之后让我说下快速排序的步骤，我老实说了，不过我觉得，这些题都太简单，如果面试官的很基础，你也答的很基础，我觉得没啥优势，对于快速排序，我本来想补充的，例如对中轴的选择问题，与其他排序算法的一些比较，应用场景等，不过，我是想着等他来问我……
按照我这样写文章的话，估计得上万字，我下面简便说下就行了。如果你们感兴趣我这么啰嗦的话，下次我再来吐槽说说我回答的不够好的地方。
4、一条SQL执行的很慢的原因？（之前写过文章，建议看看）
5、MySQL有哪些存储引擎以及他们之间的区别（我其他引擎忘了名字叫啥）
6、如何查看SQL语句的执行状态，知道这条命令吗？（我当时MySQL其实几乎没学，很多都不知道）
7、qq用的是tcp还是udp（两种都有涉及）
8、说说jvm内存模型（其实并没有JVM内存模型，只有Java内存模型以及JVM内存结构，你要问清楚是哪个再答）
9、JVM内存结构中有栈堆等，为啥要用栈这种数据结构？（主要是操作简便，快速）
10、说说垃圾回收？（老年代，新生代，永生代的区别等，各自使用的回收算法，新生代又分eden和survivor区等）
11、说说aop和ioc
12、大致看过哪些书？有逛技术论坛的习惯吗？说几个你常见的技术博客平台？有去逛过国外的技术博客吗？看的懂文档吗？
总体上一面比较简单，面试官没有深入问，不过问的很广，这里问一些，那里问一下。感觉自己答的还好，也顺利过了。第一次面试收获还是挺大。
1、对于懂的一定要多说，可以延伸，只要面试官不打断你的回答。
2、对于高频面试题，一定要自己模拟说一下，而且这些题一般不难，一定要多延伸，不然没啥优势。
3、感觉以后面试不那么紧张了，也就这么回事。
几天后收到复试通知，二面是电话面，二面操作系统和Linux问的有点多，我二面感觉自己就挂在Linux上，我Linux不大懂，被问了好几个个基础的问题都不懂，自己也是醉了，感觉自己应该和面试官说一下我Linux还没学?。操作系统很多细节也忘了，说说二面的面试题吧。
1、说下四次挥手，什么时候会出现time_wait状态？（我扯了一下，面试结束后，发现自己弄错了，真想给自己一巴掌，主要是，其实我对三次握手和四次挥手没去准备过，虽然看过挺多文章，但是具体的没记住，凉凉）
2、红黑树知道吗？说说，为啥有了平衡树还需要红黑树？（平衡树太严格，插入很容易打破平衡，经常需要调整，而红黑树是一种折中方案……）
3、红黑树是如何保证查找效率不会太低下的？（我后面再写一篇关于红黑树，B+树，平衡树这些的文章吧，现在先给出这些遇到过的面试题）
4、红黑树在调整的时候，不是会用到左旋右旋吗？说说会不会出现无限左旋右旋的情况，如果不会，那最多旋转几次？
5、为什么索引能加快查找效率？
6、说说B+树是怎么分裂、合并的，知道具体步骤逻辑吗？
7、你项目用到redis，知道跳跃表吗？说说他是怎么实现的，查找时间复杂度？
数据结构这部分我觉得自己答的还行，几乎都答出来的，不过下面的Linux和操作系统有点惨，怪自己没准备，不过面试就是一个查漏补缺的过程吧。
8、Linux的proc目录有啥用？（忘了，，，，）
9、怎么查看端口的状态？（有条啥命令来着的，忘了）
10、怎么查看某个进程的状态？（也忘了，呵呵，，，，，）
我简历上是写着熟悉Linux常用命令，然而一个也没答出来，尴尬啊，其实我会用的是那些 ls, cp, mkdir, tar等常用命令，对于线程、网络相关的都不会，感觉危险了，这么基础的问题都不会。
11、说说什么是进程，进程包括哪些数据？进程切换的过程是怎么样的？
12、如果想要让多个线程执行到某个点，都达到之后再继续执行，可以用java的那些类来实现？（CountDownLatch和CyclicBarrier这两个）
13、什么是反射？反射有啥用？
14、说说垃圾回收，jvm是如何知道这个对象可以回收的？计数法有啥问题？如果我们想要指定某种垃圾回收算法，该怎么设置？
15说说aop（这个问的刁难了，我该说的都说），他说，那我也可以通过自己配置文件来实现这种切面啊，为啥就要用AOP呢？（他问的问题就相当于，我用servlet也能使用实现一个网站啊，为啥要用spring这些框架呢？我当时应该要吹一波spring中AOP带来的好处的，不过我没说，感觉自己应该吹一下的）
15、接着是问了我那个高并发秒杀系统的项目，说了里面的线程安全问题，然后我这个项目早忘光了，自己也没准备，代码我不是自己敲的，直接看视频的。自己没做过什么项目，就充当了，结果面试官问了一下线程的问题，我一直没get到点，搞的自己也好懵，最后才知道他说的是啥，不过项目这块答的也不好，主要自己也没动手弄过，又是去年快速看视频学的。
总体上，二面除了Linux答的非常非常不好，还有四次挥手说错了，线程包括哪些数据说的也不全之外，以及项目感觉有点被认识不是我做的之后，其它感觉还好。不过。一个多星期后，结果出来，挂了。
不过我也不意外，知道自己有很多需要补的，面试有时运气不好，可能连续问到好几个不好的，估计就得挂了，不过这没方法，最好的做法就是面试过后把自己不足的补上来。
常规网申的笔试题中是20道选择题+3道编程题，过几天就收到面试通知了，有了前面两次之后的面试经验之后，也了解到腾讯是特别喜欢问操作系统+计算机网络+Linux的，于是我把这方面的高频面试题都好好准备了，Linux 进程等相关都准备了，操作系统也大致准备了，下面说说这次涉及到的面试题。
1、说说网络建立连接之后是怎么关闭的（其实就是四次挥手，我详细说了，之前写过文章）。如果出现大量time_wait 状态的连接是怎么回事？（我说了第四次挥手出现了丢包、超时等），假如不会出现丢包、超时等，网络非常流畅呢？（说了短连接导致的）那怎么解决？（我说了限制最大连接，用队列来缓冲），问我还有其他方法吗？（我不大知道，好像面试官不大满意我的回答。不过最好的做法应该是修改 time_wait 等待的最大之间，把时间改小一点）。
2、说说IO阻塞与非阻塞是什么？各自有啥好处？知道多路复用吗？了解过 select 吗？说说他与 epoll 的区别。
我知道的也不是很深入，就常规答法，他问啥就答啥。这里我要说一下，我觉得很多人可能混淆了阻塞、非阻塞与异步、同步的概念。我实话，我觉得自己已经理解了，结果我看了好几篇文章，发现自己反而不懂了，懵了，总觉得缺了点什么影响我对阻塞非阻塞与异步同步的理解，说实话，我看了大概有10篇文章，有80%我觉得都没有说清楚阻塞非阻塞与异步同步的本质区别。这会影响你对同步阻塞，同步非阻塞，异步阻塞，异步非阻塞的理解。有时间我再来写一篇文章说说他们的区别，相信看了你就一定懂了。
3、知道乐观锁吗？说说他们适合应用的情景。
4、说说自适应锁，与其他锁相比，他的优缺点，什么情况下你觉得可以用自适应锁？（之前写过几种锁的文章，不懂的建议看）
5、你平时开发是在Linux上开发的吗？（我靠，Linux上开发？？那不是得对Linux上很熟悉？我虽然准备了Linux面试相关，可是这Linux上开发压根没体验过啊，我马上怂了，马上说没有，并且还加了我对Linux不熟，这门课刚学没几天。之后他就不问了Linux了，然后接下来我就扎心了）
6、那你平时就是在windows下开发了，那如果你平时项目要上线，这个项目的性能突然很差，你是怎么定位问题的？（我靠，在下从来没有上线过项目，连用心写过项目都没有，这下完，我迟疑了一会），他补充说，例如你可以通过观察你电脑的cup, 内存，IO 的指标来进行行定位，可以分析下吗？（可以打开任务管理器来查看cup等的运行情况，然后…..其实我没有上线过项目，也没有这样的经历），他说没事，假如遇到这种情况你会怎么分析？（我下面说一下我是怎么扯的）
心想，扎心了，其实我不大知道究竟要分析啥，好吧不管三七二十一了，然后我开始扯了：
1、如果cup一直很高而其他地方内存，IO很低的话，那很有可能项目里面有某些东西在疯狂运行，但却没啥用，很有可能就是自己设计了乐观锁，但竞争的线程太多，导致一直做无用功。
2、如果磁盘操作很高，但cup很低，这是意味着项目一直在做IO操作，很有可能是SQL语句写的不好，导致扫描了大量的磁盘，然后我就针对SQL语句的问题开始扯了，例如没有用上索引啊，选错索引啊，扯了一大堆，哈哈。（心想，舒服，刚好写过sql语句执行的很慢的原因有哪些）。
7、说说进程与线程的区别？进程有哪些通信方式，（我说了共享内存，消息队列，管道，信号量，套接字，信号驱动），他问还有吗？（我说其他的不知道了），描述下这些具体的通信方式（我有些具体的给忘了，大致描述了几个）
8、说说快速排序的思想，删除单链表倒数第二个节点，你会怎么做？
9、了解MySQL事务吗？说说ACID是啥（我靠，我对事务的隔离理解还强，研究过隔离是如何实现的，然而，，，我突然短路，ACID的D忘了啥，就像你高中那会对一首古诗背的很熟，然后突然就忘了哪句，心里有点扎心），那你具体说说ACID是啥（原子性是，，，隔离性是，，，，一致性？？？？？，我靠，我觉得自己对这四大特性很理解，感觉看名字就知道是啥了，然后说到一致性的时候，我自己的心中产生了疑问，感觉自己并没有真正意义上理解了一致性，然后我没说出来）
心中那个苦，一致性都没说出来，其实我是可以说出来的，但是我总觉得缺了点什么，就像你看了几篇文章觉得自己懂了，结果让你在看几篇文章，你感觉自己有点醒悟了，然后突然发现自己并没有真正意义上的懂，我查了好多篇文章，呵呵，千篇一律，都不能解答我的疑惑，说实话，别觉得自己懂了，其实你根本就没有懂，最后是懵逼了好久，才觉得自己应该是懂了，有时间也要写一篇事务的四大特性的文章。
说实话，网上的很多文章，真的是千篇一律，当你产生了疑惑，很难找到解答，因为你会发现，这几篇说的都是一样的，那个你感觉特别重要的疑惑都没有说到。好吧，不吐槽了，等下要被大佬门怼我写的文章了。
一面大致说了这么多，有些忘了。比起提前批一面，我觉得自己在表述上好多了，也会扯了，这里我想跟大家说的就是，问题就那些，一定要搞懂，延伸，要理解，该背的要背，例如进程有哪些通信方式。如果要面试腾讯的时候，计算机网络、操作系统，Linux这些底层的，要学好，尽管你是面试 java 岗位的，可能他一个 Java 的问题都不问的。
二面我应该就是个傻逼吧，自己给自己挖坑了，最近这些题一直在刷题，复习基础，对于数据结构，算法题，Java，操作系统什么的，自己也想看看有哪些不足，然后他一开始就叫我介绍项目。
1、说说你做的项目。
其实这期间我为了应付以后的面试弄过做过一个项目，不过还没弄好。然后我之前不是说了自己有个很水的高并发秒杀系统项目吗？我自己也没啥项目经验，然后我觉得高并发也是很牛逼的样子，就打算用它了，简历上也写了。不过这个项目我自己没实操过，看视频的，很短，几个小时而已，用到了redis等，不过我已经准备了很多redis相关的知识了，怎么优化的也准备好了。
现实是，呵呵，我被怼的体无完肤。
优化之一就是通过减少事务持有锁的时间来优化的，例如我们秒杀一个物品的话，如果减库存和插入订单两个操作都成功的话，代表秒杀成功，这两个操作会在一个事务里完成。问题来了，是先减库存呢？还是先插入订单呢？
我说了先插入订单在减库存能够减少事务锁的持有时间，然后我就被面试官怼死了，如下：
面试官：你觉得你这个优化有用吗？
我：有啊，可以减少锁的持有时间（确实可以减少锁的持有时间）
面试官：那你说说提高了多少并发量？
我：这个，，没测试过（我是看视频的，自己也没有这样的测试工具，有点尴尬，连测试过都没有？？）
面试官：那你说说这条事务执行需要多少时间
我：我，，好像忘了具体数据，大概是0.00几秒吧。
面试官：你自己都说0.00几秒了，这么短时间，你觉得你的这个优化，用处大吗？有数据来支撑下吗？
我：,,,,，（真的自己给自己挖坑了，早知道随便介绍下就好了，不主动说自己的优化了过程了，毕竟自己没实操过）
面试官：你这个系统能扛多少并发量？
我：…没测试过（我觉得，面试官觉得这个项目是假的了，可能觉得我是从网上随便找的，然后来应付面试的，我觉得自己凉了，欺骗可是非常严重的）。
面试官：那你说说，完成一条请求用了多少时间（测试最大的并发量可能需要相应的工具，他可能为了再次确认我的真伪，故意是一条请求的？这样就不需要工具了）
我：…..没测试过（好吧，我的心已凉）
面试官：好吧，就说到这里，你用过lowJS吗？
我：啊？？lowJS，什么鬼东西？而且他的声音有点小，我再次确认，是指lowJS吗？他说是，我说没听说过（后来才知道，他说的是Node.js，，，，，，麻痹，，，）。
面试官：你还有啥问题要问的？
呵呵，，，已经凉了，这次面试真的是自己给自己挖坑，面试官肯定是知道我项目是伪造的，这是非常严重的事情，然后这个面试大概是持续了10几分钟，其他的面试官的也没问了。想找给人吐槽下自己。
然后，明天就查到挂的信息了，之前二面是一个星期多才查到挂了，这次是十二个小时之后就收到挂了，我也知道10000%挂的了。此刻需要一波安慰！！
总结就是一首凉凉送给自己，还有就是有一些建议，当然，这也是我自己给自己的建义。
1、高频面试题，别停留于表面，大家都懂，说的很表面没啥优势。
2、别以为自己懂了，如果可以，最好自己尝试描述一下，你可能会描述的很没有逻辑。
3、好好准备一个项目吧，一定要自己脚踏实地做一下， 别像我，被怼的体无完肤。
4、框架真的问的很少，好好打基础，数据结构与算法，计算机网络，操作系统，Linux 进程等相关的命令。
5、面试的第一关是笔试，一般都是编程题，建议要刷刷题，不然面试的机会都没有。
先写到这里了，后面会写一下面试相关的题，建议最后看，虽然你看过相关文章了，但看我的，可能你也能够有新的收获！还有就是祝各位大佬面试顺序，不好的运气我来帮你们包揽就行了（留下了委屈的眼泪）
校招之路",
校招简历模版,"今天我们就来聊一聊在校招时，简历该如何写的问题。说实话，对于简历的书写方式，可能不同的人会有不同的见解，并且不同的面试官/HR在筛选的时候也会有所差异，所以在我看来，不存在一种绝对稳的简历模版。
我在之前校招时也问过很多过来人关于简历的问题，并且我也认识不少当过面试官的大佬，当时也都叫帮忙修改过简历，今天我就根据自己的经验以及大佬们的建议，跟大家说一说简历该如何写，或许可以给你带来一些有益的参考。

  最后也会给出我自己参加校招时的简历模版 + 大佬们参加校招时的模版

先来回答一个问题：简历是写一页好还是两页好呢？
对于这个问题，可能你的师兄师姐会告诉你，最好写一页，面试官没那么多时间去看简历；也有人会告诉你，最好写两页，毕竟我们没拿过什么大奖，只能在简历上多点自己会的东西。
我的答案是，一页两页都可以，只要你把想要表达的东西都表达出来了，那么就可以了，但是不建议第一页写不下，第二页只写了 20%，然后其他留空白，个人建议最好不要留空太多。
简历里该有哪些东西？
对于校招生来说，简历里无非就个人背景、教育背景、基础技能、项目经历、个人荣誉、自我评价这几个模块，其中最重要的就是基础技能和项目经历这两个模块了，所以本次也重点讲下这两个模块的书写。
对于想要进大厂的同学来说，基础知识的掌握无非是最重要的一个点，因为大厂更看重你未来的可塑造性，而扎实的基础，便是一个很重要的证明。有人可能会问，什么是基础知识？
基础知识说来说去无非就是我们大学所学的那些课程，例如数据结构与算法、计算机网络、操作系统、数据库、Linux等等。
我看过好多人的简历，很多人在写基础技能的时候，基本都是写的很「简洁」，例如写计算机网络的时候，简历上就单单写了这一行字：掌握计算机网络。
说实话，计算机网络所包含的知识太多了，如果你不是多牛逼的人，我这里是建议大家在写基础技能的时候，写详细一点，例如把你掌握的一些协议写出来：
熟悉 OSI 七层模型和 TCP/IP 四层体系分层结构，掌握常见网络协议，如 ARP、ICMP、TCP、UDP、DNS、DHCP、https 安全工作原理等。
你把这些罗列出来，给人的感觉就是你好像真的掌握一样，并且也方便面试官挑选问题来询问，正常情况下面试官都会挑你懂的技能来问你是不是真的懂，而不是专门找一些简历里不存在的冷门知识来问你。
所以在写基础技能的时候，我建议大家，写的详细一点，把你自己掌握，想要被面试官问的知识罗列出来。
例如你懂数据结构与算法，那么千万别只写「掌握数据结构与算法」，可以把你觉得自己掌握的还不错的算法写出来，例如我就是这样写的：
扎实的数据机构与算法，例如掌握栈、队列、链表、二叉树、图、排序算法、递归、动态规划、分治、回溯等。
因为大家都学过数据结构与算法，可能大部分人都简历里都写着掌握数据结构与算法几个字，具体是掌握多少，不同的人是天壤之别的。
所以呢，在校招的简历上，如果你没有什么比较牛逼的，拿到出手的经历，那么我建议你一定要在基础知识这个方向上下功夫，写的时候尽量详细点，给大家截图下我简历上写的（我的简历是 1 页的，所以力求简洁）

我在秋招那会，面试官问基础技能时，也大部分从我的简历上有列举的知识进行提问，然后延伸。这里需要强调的是，简历上写出来的，一定自己要懂。之前我 Linux 的一些命令写在简历上，结果被面试官一问，特么我刚好那个命令还真没用过，把我尴尬死了。
之前我看过几个要参加春秋招小伙伴的一些简历，经常看到这样的情况：
1、有些人在写项目的时候，项目背景说了一大堆，然后自己做了什么，却是一笔带过，我竟无法从他的项目经历中找出他究竟做了啥。
2、也有很多人问我，自己没有实习项目或者没有真实的线上项目怎么办？
对于校招生来说，其他很多人项目都接触的比较少，并且很多大公司在这方面也不会对你要求太苛刻，所以我觉得，对于一个项目最重要的不是这个项目有多高大上，而是你在这个项目中自己做了什么，用了什么技术解决了什么问题。
并且对于一个项目，我们也可以做一些适当的包装，然后自己准备好相应的面试题，例如你的项目是跟着视频做的，如果觉得自己掌握的不错，其实也是可以包装成自己的实习项目。
在写项目的时候，比较重要的几个点就是：
（1）、使用技术：把自己在项目中用到的技术写出来，例如是否用了 redis，还是用了 spring，springcloud 等等。
（2）、简洁介绍下项目：我猜大多数人的项目都是比较简单的，所以在介绍的时候，可以简单介绍了项目的功能、背景之类的，这方面别写太多。
（3）、我的职责：我觉得这个是最重要的，就是你干了什么，用了什么技术解决了什么问题，并且面试官大概率会从你解决的这些问题中问你问题。例如当时我在项目中就说了用 redis 来充当消息队列，解决异步问题，然后自己也准备的相关的面试题，之后面试官刚好就这个消息队列的问题问了挺多，然后就……
也就是说，在写项目的时候，用到的技术，以及是自己做了什么，解决了什么问题，是最重要的一部分吧，因为简历就是用来展示我们自己的，所以必须要让面试官看到我们会什么，做了什么。
如果你有获得什么好的证书或者比赛，那么可以在这一栏中写进去，例如你的英语六级成绩好不错，那么可以把自己通过六级考试这个事情写进去。但是如果你像我一样，只考了四级，并且四级成绩还贼差，那么就不建议把四级写进去了，因为通过英语四级这个事情，是个本科应该大部分都有这个要求？所以还是不写吧。
还有那些你参加过一些社交活动啊，知识答辩这些证书啊，也没必要写了。写上去的那些荣誉证书啥的，建议和你的专业挂钩，例如你拿到软考高级证书（中级没啥含金量，当然要写也可以），你在学校参加 ACM 拿过奖，自己在网上参加比赛拿过的奖等。
很多人都会在最后来个自我评价，并且大部分人有写和没写一样，因为他是这样写的：
1、本人热爱编程，喜欢学习，喜欢看书，喜欢分享。
2、喜欢探索、喜欢挑战。
说实话，我觉得这些写了和没写一样，因为凡是个人都具有这样的特性，所以在自我评价这一个模块，如果你有写的话，我建议你写具体点。
例如，你说自己喜欢看书，可以顺便举例下看过的一些书；你喜欢分享，可以说下自己写了多少篇文章；喜欢学习，可以说一说你经常去那些社区，例如 csdn，博客园，stackoverflow。
如果你的简历已经写好了，那么可以根据我这篇文章看看有没有可以改进的地方，如果你的简历还没写，或者想要找个简历来参考，那么我这里也准备了两份简历，一份是只有一页的 Java 后台开发岗位的，一份是两页的 Linux/C++ 岗位的。大家可以关注我的微信公众号

在这个公众号回复「简历」，即可获取 word 版本的简历。
最后，也欢迎大家在简历这方面进行补充，毕竟每个人的见解都不尽相同，我给出的这些建议也并非最优，可能对于经验比较少的你，或许可以给你作为一种参考勒。
校招之路",
笔试得刷多少道题才稳？,"想要学习算法、应付笔试或者应付面试手撕算法题，相信大部分人都会去刷 Leetcode，有读者问？如果我在 leetcode 坚持刷它个 500 道题，以后笔试/面试稳吗？
这里我说下我的个人看法，我认为不稳。下面说说为啥不稳以及算法题应该如何刷、如何学才比较好，当然，也会推荐自己学过的资料。
在刷 leetcode 的时候，你会发现，每道题的题意都很短，你只需要花十几秒的时间，就知道这道题是要你干嘛了，并且每道题所用道的算法思想都很明确，动态规划、递归、二分查找等，你可能很快就知道该用哪种方法，只是你不懂如何把代码写出来而已。
而在笔试中是完全不一样的，在笔试中，大部分题目都是情景题，可能读懂个题目都需要花不少时间，偶尔还会遇到不大知道题目要我们干嘛，而且有时间限制，估计每道题给你分配的时间是 30 分钟。这里我随便扔一道题给大家看看（Shopee去年的真题）

并且你可能不容易看出来，这些道题该用什么方法好，有可能是多种方法的结合（当然，不是指这道题哈）。
也就是说，在 leetcode 中，hard 级别的题做的出来，而在笔试中 medium 级别的，由于时间、心态等因素的影响。你可能还做不出来，当然，大佬除外。下面说一说题型的一些题型以及如何学习算法会好应付点。
在笔试中，我认为主要有如下几种题型：
1、基本数据结构的考察：这类题我觉得是比较简单的，主要考场基本数据结构的操作，例如二叉树的层序遍历，链表的逆序等，当然，它不会直接告诉你，让你来逆序或者遍历。例如

2、某种算法思想的掌握：这类题你掌握了某种算法思想，就会比较容易，如果不懂，那就凉凉了。例如动态规划、回溯、枚举、深度/广度、贪心、二分等。其中，我觉得动态规划考的挺多，还要就是 回溯+深度/广度。例如
所以，常见算法思想，一定要掌握。
3、边界条件的考察：这类型的题，估计你一看就有思路，知道该怎么做，但是，它的边界条件特别多，需要分很多种情况来讨论，特别容易出错，有时候会让人陷进去，越做越复杂，这类题主要考场你的思维严谨程度。例如

4、找规律、数学公式：这类型的题，主要是根据数据之间的一些关系，来找一些规律，进而推出他们的通用公式，就像我们高中时，找数列的同项一样。例如

上面说了笔试题的一些情况，也说了主要考察的一些题型。针对这些题型，我觉得在刷题的时候，你要做好下面几件事。
归纳？总结？估计大部分都知道归纳、总结这么一回事，但是，有没有去实践我就不知道了。
（1）、数组和相关题型
对于算法题，还是有很多种题型需要去总结的，如果你懂这个题型，以后遇到类似的题，相信很快就能做出来的。有哪些题型可以总结呢？答是非常多：例如

  （1）、给你一个非负数的数组，求最大子数组和的长度

这算是一个题型，关于这个题型，有很多种变形、拓展，这里建议一起归纳总结，例如

  （2）、刚才给的数组是非负数的，现在变一下，给的数组是可正可负。

还能继续拓展吗？答是可以的，例如

  （3）、给你个矩阵（即二维数组），求最大子矩阵和的面积

还有吗？有，例如刚才是求最大和，现在我改成求最大乘积。
我举上面这些例子，就是想告诉你，对于前期的学习，我建议分类刷题，总结题型，像我上面举的这些例子，在笔试/面试中还是比较常见的，如果你懂得对应的方法，就可以秒杀了，因为这类题，没啥边界或者规律。例如我刚才距离的Shopee的零食柜那道题，实际上就是数组切割题型，相当于给你一个数组，让你切割 n 下，那么可以把数组切割成 n + 1 个子数组，怎么样切割，才能让最大子数组的和最小？
关于题型的，还是很多的，我这里无法一一给你列举，只能靠你刷题的过程中，进行分类、总结。不过我可以给你推荐一些资料，后面推荐哈。下面我在说一些题型吧。
（2）、基本数据结构操作相关题型
刚才我说了，笔试题的考察，有一类题是基本数据结构的考场，而且，这类题在面试中，也是高频考点，在笔试中，倒不是很高频。对于这类题，我觉得你愿意去总结，那么以后遇到，问题不大。例如
链表的各种操作：逆序（部分逆序、按某种条件逆序）、判断是否有环，环的入口节点、删除指定节点等。
二叉树的各种操作：各种非递归的遍历操作（前中后、层）、二叉树的公共祖先、根据前中后的遍历结果来重构二叉树等等。
队列、栈相关操作：最小栈、来队列来实现栈等。
（3）、字符串相关问题
不得不说，字符串相关问题，估计考的最高频，而且，我可以告诉你，对于字符串相关问题，90% 可以用动态规划来解决。反正对于字符串问题，我一般想法就是能否套用动态规划，字符串问题有点多，不过你有时间，建议总结。例如：通配符的匹配、最长公共子串、最小编辑代价、最长回文串等等。大部分都是用动态规划，而且，我觉得解法都差不多，所以强烈建议专门花一段时间来做、总结、归纳。后面我也会写这方面的算法文章，敬请期待。
（1）、边界、找规律题型
刚才我说有一类题型是边界特别多的，对于这类题，我觉得不好总结，这类题考察你逻辑是否严谨，能否化繁为简。这里我建议多做几道，做的时候，多自己思考，千万不要觉得自己知道思路，自己怎么写，只是情况太多，懒的写，直接看别人的答案，这样子，这道题你做了价值不大，因为这类题就是考察你思维完整性的，最好是自己做，可能你用了 十几个 if 语句，没关系。接着你可以把你的 if  语句进行化简，查找他们的共同点。最后你可以看大佬们的做法，你的收获会更大！
对了，也千万别急着动手写，应该想一想可行性，不然你容易陷入无底深渊。
对于找规律的题型也是一样，这类题最后别急着看答案，应该多思考，多做几道，做多了，你的思维会越来越灵敏，以后看到这类型的题，可以很快有思路。
所以，对于这种边界、规律题，个人感觉总结的价值不是特别大，更多的是多思考，多动手。

  注意：每道题，我们都要追求最优解哈，别觉得 ac 了就完事了。

上面说了那么多，可能有人是道理我都懂，可我还是学不会，说实话，学习的方法有很多，每个人的学习方法也都不一样，我这里也只是提供一种参考。但是，无论什么方法，你不去动手执行，那么，一切都是空话。
这里我推荐一些我看过的书，感觉挺不错。

  文中涉及到的书籍，在这里就可以下载：计算机书籍免费下载（高清带目录完整PDF版）

计算机书籍免费下载（高清带目录完整PDF版）
1、书籍推荐
刚才我说了很多种题型，对于按题型刷题总结，首推《程序员代码面试指南：IT名企算法与数据结构题目最优解》，这本书真的挺不错，大部分题型都总结了，而且每个专题有十几二十道，这里建议大家买本来学习。
还要一本我大一看的，感觉也挺不错，叫做《挑战程序设计大赛》，不过这本比较适合不急着面试的吧，这本不像上面那一本，专门来总结各种题型应付面试。
《编程之美》、《编程珠玑》也建议看，这两本我觉得比较有趣，不是说让你一直刷题一直刷题，这两本你可以买来看看，会给你带来一些思路，这两本我是只看，没动手打代码。
Leetcode 刷题的时候，也是可以分题型刷滴，所以也可以去 leetcode 刷题，不过刷题的时候，我这里有个建议，就是别在本地 IDE 写代码，直接在网页端写就行了。因为面试的时候，一般就让你在记事本写代码，不会给你 IDE。如果你不习惯，估计很容易写错代码，而且，有些库函数你也把名字忘记了。网页端其实也是挺方便的，也会有一些代码提示。

  对于，对于连各种算法思想、数据结构都还不懂的同学，上面的数据不大合适哈，推荐我看过的两本书《数据结构与算法分析 — C 语言描述版》、《算法设计与分析基础》（这本代码实现是用伪代码的）。

2、视频推荐
说时候，我视频看的不多，对于算法的学习，特别是刷题，我是不大习惯看视频，如果你想看视频，我觉得牛客网的算法视频还不错吧，我没过几集，分初级班和进阶班，可以这里下载：牛客网算法第四期，其他的我也没看过，所以这里可以推荐的不多
牛客网算法第四期
回到标题，leetcode 刷 500 道题稳吗？说实话，你能坚持刷 500 道题，说明你的能力还是挺强的，但是对于笔试，我觉得不一定稳，得看你怎么做，例如是否追求最优解，是否进行总结归纳，还是说你只是暴力 ac 了之后就不理了，或者不敢跳出舒适区，老是做那些比本来就比较擅长的题目，而遇到自己弱的题目，马上就看答案了。而且我说了，有些题是找规律或者边界很多的，这类题需要你多思考、动手，不是说我多刷几道就可以了。
总之，对于刷题，千万别追求数量！
校招之路",
以过来人的角度聊一聊我艰辛的面试之路,"大家好，我是帅地，今天主要和大家聊一聊自己当时的面试准备以及一些面试心得，最后也给大家准备了一些珍藏已久的资料。
记得去年的这个时候，帅地基本每天都在做各大公司的笔试题，很多笔试题，是真的难，为此我也写了一篇文章：leetcode 刷500道题，笔试/面试稳吗？谈谈算法的学习
leetcode 刷500道题，笔试/面试稳吗？谈谈算法的学习
有些人，手里已经好几个 offer 了，而有些人，笔试受挫，面试受挫，自己明明复习了那么久，学习了那么多，特么在笔试就被刷了，有些甚至连笔试都不给，好不容易进入面试环节，自己明明每个问题都回答出来了，但一查状态，才发现自己进了人才库…
有人可能忍不住会问，双非本科还有机会拿到大厂 offer 吗？
我的回答是，完全有机会。
说到卡学历，我觉得一些中厂比大厂更喜欢卡学历，对于很多大公司来说，基本都会给你笔试的机会，而能不能获得面试的机会，笔试的成绩真的很重要，如果你学历不好，简历也没获得什么大奖，那么这个时候，你的笔试成绩，就尤为重要了。
一般很多大公司，在提前批基本都是 3 ～ 5 道编程题，如果你能做出 60% 的笔试题，那么被发起面试的概率还是挺大的。当然有人可能会说，我特么全 A 了，但还是没收到面试的机会，这又是怎么回事？
说实话，确实，有些公司真的会卡学历，我记得我有次做贝壳找房的笔试题，全 A 了，但还是没有给面试的机会，爱奇艺笔试机会都没给。
但是，由于我笔试做的还不错，大部分公司还是给了我面试的机会，我的简历其实也一般，所以我觉得，如果你笔试做的还不错，就算你是普通本科，还是会有很多大公司愿意给你面试的机会的，毕竟，很多大公司，都不想错过才人。但一些中公司，可能反而不给你面试的机会，直接卡你学历，因为，面试的成本，也挺高。
笔试一直被虐怎么办？
这没办法，现在很多公司处于提前批状态，提前批就是神仙打架，笔试/面试的难度，都会比正式批难，而且提前批大佬贼多，所以就算笔试/面试受挫，大家也不要太灰心，因为，提前批是真的难，反正我是体会过提前批的笔试题了。
提前批被虐了之后，到了正式批就积累了不少经验了，而且很多大佬也已经拿到 offer 了，这个时候 offer 的数量虽然少了挺多，但是，我觉得反而比提前批更加容易拿到 offer 了。记得当时，我的很多同学，基本也是在八九月份，一个 offer 也没有，好些人都想放弃秋招等春招了，但到了十月份，offer 就莫名着陆续来了，好多同学，熬到了十月份，最后也都在十月份拿到了 offer。
所以，我希望，大家不要灰心，应该要不断总结，不断弥补自己的盲点。对于还没有参加校招的同学，也要好好准备下笔试，努力把算法题刷一刷。
作为一个应届生，从春招到秋招，体验了 n 场面试，但说实话，问来问去，每次面试都会问那十几个问题，有些问题，我都回答腻了，例如讲一讲索引，进程与线程的区别…，这些问题，都我回答了几十遍了…
我相信很多人也都会提前早早准备这些问题，例如三次握手，四次挥手，进程通信，垃圾回收，链表反转，等等。
我想，面试官，应该也都知道你们可能都会背诵/默写了吧，可是，他们依然还是会问你：进程的通信方式有哪些？
可是，这些熟悉到能够背诵的问题，当面试官问你的时候，你能让这些问题成功你的加分项吗？
说实话，我认为很多人不能，这些简单/百问不厌的问题，我花了很长时间去研究，因为这些问题被问的概率太大了，我不能和大家一样：当面试官问我进程有哪些通信方式的时候，我熟练着跟面试官说：
1、管道
2、消息队列
3、共享内存
4、信号量
5、Socket
…
直接说出了五六种，松了一口气，心想：幸好没忘。然后就没了。
说实话，这样的回答，我觉得，很多人都能够回答出来吧，我猜应该也有挺多人是死记硬背的，这种回答，很难成为加分项。
我就认识一些人，跟我说，面试官问的，基本都有回答了，但过了几天，收到了简历进入人才库了。
虽然面试官问的，都能回答出来，但不见得你真的回答好了，这些基础的问题，在不同的人手里，回答出来的，真的会很不同。
我的项目经验比较不好，学历也一般，简历也普通，我的优势就是扎实的基础 + 算法，所以，我对这些常见/高频面试题，基本都会去研究一下，绝对不会和绝大多数人回答的一样，我一定要想办法让我的回答成为加分项。
例如，当面试官问我进程通信的时候，我不会直接回答出这五种通信方式，一个会尽量把这五种进程方式给串联起来，例如像我写文章的这种方式回答：记一次面试：进程之间究竟有哪些通信方式？—- 告别死记硬背
记一次面试：进程之间究竟有哪些通信方式？—- 告别死记硬背
当面试官让我说一说MySQL 索引的时候，我可能会由浅入深，从索引的数据结构选型，到索引失效的本质原因，把这些逻辑连贯起来，一层推一层着跟面试官讲…
如果你之前看过我的原创技术文章的话，可能会发现我的文章，并不会硬巴巴着抛出一个概念，然后跟你讲解这个概念是什么意思，而是会从最简单的说起，一步步推出下一个知识点。
是的，我面试的时候也是这样，基本面试官问我这些常见的问题，例如数据库索引啊，锁啊，事务啊，计算机网络的 https，三次挥手四次握手，icmp等啊，还是数据结构等调表，B/B+ 树啊，我基本都会按照自己的理解，从 0 到 1，一层层推理出来跟面试官讲。
而这，也是我面试的优势，当然，当面试官问我项目的时候，由于本人确实没怎么做过项目，基本没有从 0 到 1 做过的项目，都是看视频速成的，所以项目是我的短板，这也是我一定要把基础题回答好的原因，我要让面试官看到我是一个值得培养的人。
线程和进程的区别，这个问题简单吗？你被问过几次？
说实话，我为了回答好这个问题，为了让自己和大部分已有的回答模版不一样，我找了好多资料，也看了好多文章，重新翻开了操作系统，了解他们的本质区别，但依然还是回答的不是很满意…
说这么多，其实我就是想告诉大家，对于一些经常被问到的问题，大家可能也都准备好了回答模版，但是，如果你只是简单的回答，和大部分人的模版一样，那么，觉得面试官问的，虽然你大部分都回答了，但可能回答的并不深刻，所以就算回答了，可能也会被刷，因为其他人也像你这样回答了，而有些人，却回答的很优秀。
所以对于那些高频面试题，最后深入研究一下，总结一套自己的回答模版，让这些百问不厌的面试题成为你的加分题！
校招面试",
读者问答—关于春招的几个问题,"前几天我在视频号做了一场直播，直播过程以及直播过后，不少小伙伴都咨询了我校招相关的问题，其中不乏迷茫，没准备好，要不要参加春招，该如何复习，面试都问什么…等等。所以这篇文章，帅地采用自问自答的形式来回答几个共性问题，如果你还是在校生，或者刚毕业不久，或者想要参加面试，那么可以看一看。
这些问题我先汇总一下，方便你们根据问题查找对应的回答。
1、春招面试官都会问什么？
2、春招开始了，我好多还没有复习，要不要先不参加春招，全力准备秋招？
3、面试问项目，我没有实际的项目经验怎么办？
4、春招暑假实习，留言转正的概率大吗？
5、之前算法题刷的很少，眼下算法该如何准备？
6、目前在一家外包公司实习，不过学到的东西不多，是要继续实习还是辞职全力备战春招？
7、笔试好难啊，有什么技巧吗，有人作弊吗？
8、之前有过实习经验，我不参与春招实习了，全力备战秋招可以吗？
无论是春招还是秋招，基本都是问算法+基础知识+项目+语言相关，下面我详细回答下各种知识点，方便你准备
（1）算法题：面试算法题其实问的不是很多，可能总共就问个两三道（字节跳动除外），并且问的难度都不难，感觉就 leetcode 中的 easy 和 medium 难度吧，并且很多都是原题。
（2）基础知识：一般就问计算机网络会多一些，然后就是操作系统和 Mysql，其实计算机网络问来问去就那几个问题，大家可以多看看，操作系统就更加死板了，就那几个，至于是哪几个？牛课网去看看面经总结下就好了，至于 mysql 的话，索引是重点。
（3）项目：我觉得春招实习，项目问的还是挺多的，甚至比秋招还要多，所以大家一定要亲手做一个项目，一般面试官会根据你项目涉及到的技术栈，问你一些相关的问题，例如你用了 redis，那么会问你 redis 啥的，还会问你如何优化之类的。
（4）语言相关：一般就Java，C++，Go，Python 这几门，你学哪一种，和面试官说下就好了。如果你是学 Java 的，那么多线程，哈希表，垃圾回收，这些就要注意了。
别问，问就是一定要参加春招实习，哪怕你啥也没准备，一定要把春招作为练手，拿不拿的到 offer 倒没关系，至少可以涨一波经验，这会在秋招，给你带来非常非常多的帮助，因为你会发现，面试问来问去就哪些问题，面多了，在一次又一次的总结之后，回答起来会变的很有逻辑。
有人可能会说，我不参加春招，我准备好之后再参加日常实习中，也可以涨面试经验啊？
个人认为，日常实习和春招还是有区别，春招会比日常实习难，而且春招非常非常贴近秋招，所以我还是建议你去参加春招，如果还没有准备，如今最重要的就是，先写好一份简历，然后去各大官网网站投递。
不需要公司的真实项目，你的对手也大部分是没有真实的线上项目的，自己随便找个项目做就可以了，现在不是有很多培训班的免费视频吗？你可以去找一个来做，也可以去慕课网，牛客网这些，付费几百块钱，找一个来做，也就几百块，投资下自己，还是非常值得的。
如果你对应的技术栈学习了，其实全力以赴，一个星期就可以跟着视频，做完一个项目，剩下的就是面试过程不断被虐，然后不断涨经验，不断变强。
首先，我想说的是，不管概率大不大，你都要一边准备秋招，是的，一边实习，一边准备秋招，到时候还得一边实习一边偷偷面试，手里多拿几个 offer，总归比较放心。
至于转正概率？我认为还是挺大的，每个公司的概率不一样，具体还得看公司招了多少实习生，秋招有多少 HC 分给了实习生，像今年腾讯招了 8000 实习生，那转正概率肯定比去年低。
总的来说，按照往年的一些数据，我觉得转正的比例有 1/2～1/4。
如果春招来不及准备了，大家可以在面试之前，把一些简单且高频的算法面试题撸几遍，例如这几道：快速排序，归并排序，希尔排序，链表反转，指针指向链表的中间节点/倒数第二个节点，两数之和，还有几道简单的 DP 问题：例如 不同路径（leetcode 62题），最小路径和（leetcode 64题）。
并且一遍把剑指offer 刷个两三遍，如果你没刷过剑指 offer，可能是来不及刷了，但是可以为秋招准备。
我先说一件事，就是无论你是否继续实习，都要先去投递简历，参加春招，先看看自己被发起面试的概率大不大。
假如你已经实习了几个月，也算有点实习经验了，并且觉得自己能够静下心来复习，我觉得离职出来全力准备春招/秋招也是可以的，但是如果你刚入职，并且实力/学历都很一般，那么还是可以一边实习一边先工作一两个月再离职出来全力准备秋招。
我跟大家说的实话，在春秋招的笔试中，确实挺难，有很多人都是组队一起做的，在牛客网做编程题的实话，是可以切换屏幕的，也就是说，可以从浏览器切换到别的软件应用，这个时侯，是可以做一些手脚的。虽然有摄像头，但是摄像头死角太多，也就是说，笔试作弊的人还是挺多的，而且好多还是同一个实验室的人。
关于笔试作弊这个事情，如果被发现，后果 还是挺严重，之前我们那一届，就有好几组人，腾讯笔试时，被发现了，直接被腾讯拉近黑名单了，因为诚实这玩意，太重要了。
但是，帅地想说的是，大家好好把握，帅地其实也作弊过，但是我不是团队的，我是自己一个人，团队最容易的就是，代码相似度太高，容易被检测出来，有人可能会说，自己一个人也能作弊？我只能说，自己好好研究吧，作为一个博主，在这里倡导大家作弊显然是不对的，我还是建议大家别作弊，你们自己好好体会，好好研究属于自己的方法论吧，这个方法论，也可以为了秋招笔试而研究。
假如你之前有去过不错的公司实习过，并且春招没有拿到大厂实习 offer，我觉得是可以全力备战秋招的，好好补充自己薄弱的环节，直奔秋招提前批（七月份就开始了），但是，还是那句话，一样可以去投递下简历，以放松的心情去参加下面试/笔试。
上面这些问题，是很多读者在微信问了问题之后，我总结提炼出来的共性问题，希望可以给还处于迷茫的你的一个参考。
另外，帅地创建了一个校招群，你们可以进群，但为了减少我的工作量，你们要按照规则来，不然我可能不会邀请你。这里我强调一下，进群之后一定要看群公告，一定要看群公告，一定要看群公告，否则被误踢别怪我。
帅地会在这个群里发一些校招相关的资料，内推等等。
如何进群？

扫码添加我的企业微信，通过好友请求之后，向我发送「校招」，进群之后，大家一定要看群公告哈。
校招之路",
消息队列的基本作用？,"消息队列的主要作用是：解耦、异步、削峰。
A 系统通过接口调用发送数据到 B、C、D 三个系统。那如果现在 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？现在 A 系统又要发送第二种数据了呢？这样的话 A 系统的维护成本就非常的高，而且 A 系统要时时刻刻考虑B、C、D、E 四个系统如果出现故障该怎么办？A 系统是重发还是先把消息保存起来呢？使用消息队列就可以解决这个问题。A 系统只负责生产数据，不需要考虑消息被哪个系统来消费。
A 系统需要发送个请求给 B 系统处理，由于 B 系统需要查询数据库花费时间较长，以至于 A 系统要等待 B 系统处理完毕后再发送下个请求，造成 A 系统资源浪费。使用消息队列后，A 系统生产完消息后直接丢进消息队列，不用等待 B 系统的结果，直接继续去干自己的事情了。
A 系统调用 B 系统处理数据，每天 0 点到 12 点，A 系统风平浪静，每秒并发请求数量就 100 个。结果每次一到 12 点 ~ 13 点，每秒并发请求数量突然会暴增到 1 万条。但是 B 系统最大的处理能力就只能是每秒钟处理 1000 个请求，这样系统很容易就会崩掉。这种情况可以引入消息队列，把请求数据先存入消息队列中，消费系统再根据自己的消费能力拉取消费。
消息队列面试题",
消息队列的优缺点有哪些？,"消息队列的优点就是：解耦、异步、削峰。
降低系统的可用性：系统引入的外部依赖越多，越容易挂掉；
系统复杂度提高：使用 MQ 后可能需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题；
一致性问题：A 系统处理完了直接返回成功了，但问题是：要是 B、C、D 三个系统那里，B 和 D 两个系统写库成功了，结果 C 系统写库失败了，就造成数据不一致了。
消息队列面试题",
如何保证消息队列的高可用？,"根据不同的 MQ 或者你用过的 MQ 进行回答：
RabbitMQ 是基于主从做高可用性的，Rabbitmq有三种模式：单机模式、普通集群模式、镜像集群模式。单机模式一般在生产环境中很少用，普通集群模式只是提高了系统的吞吐量，让集群中多个节点来服务某个 Queue 的读写操作。那么真正实现 RabbitMQ 高可用的是镜像集群模式。
镜像集群模式跟普通集群模式不一样的是，创建的 Queue，无论元数据还是Queue 里的消息都会存在于多个实例上，然后每次你写消息到 Queue 的时候，都会自动和多个实例的 Queue 进行消息同步。这样设计，好处在于：任何一个机器宕机不影响其他机器的使用。坏处在于：1. 性能开销太大：消息同步所有机器，导致网络带宽压力和消耗很重；2. 扩展性差：如果某个 Queue 负载很重，即便加机器，新增的机器也包含了这个 Queue 的所有数据，并没有办法线性扩展你的 Queue。
Kafka 基本架构是多个 broker 组成，每个 broker 是一个节点。创建一个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据，这就是天然的分布式消息队列。就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。
Kafka 0.8 以前，是没有 HA 机制的，任何一个 broker 宕机了，它的 partition 就没法写也没法读了，没有什么高可用性可言。
Kafka 0.8 以后，提供了 HA 机制，就是 replica 副本机制。每个 partition 的数据都会同步到其他机器上，形成自己的多个 replica 副本。然后所有 replica 会选举一个 leader 出来，生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上数据即可。Kafka 会均匀的将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。
消息队列面试题",
如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？,"要保证消息不被重复消费，其实就是要保证消息消费时的幂等性。幂等性：无论你重复请求多少次，得到的结果都是一样的。例如：一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。
那么如何保证幂等性呢？
写数据时，先根据主键查一下这条数据是否存在，如果已经存在则 update；
数据库的唯一键约束也可以保证不会重复插入多条，因为重复插入多条只会报错，不会导致数据库中出现脏数据；
如果是写 redis，就没有问题，因为 set 操作是天然幂等性的。
消息队列面试题",
如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？,消息队列面试题,
如何保证消息的顺序性？,"拆分多个 Queue，每个 Queue一个 Consumer，就是多一些 Queue 而已，确实是麻烦点；或者就一个 Queue 但是对应一个 Consumer，然后这个 Consumer 内部用内存队列做排队，然后分发给底层不同的 Worker 来处理。
一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。
写 N 个内存 Queue，具有相同 key 的数据都到同一个内存 Queue；然后对于 N 个线程，每个线程分别消费一个内存 Queue 即可，这样就能保证顺序性。
消息队列面试题",
大量消息在 MQ 里长时间积压，该如何解决？,"具体可以看这里：https://www.jianshu.com/p/5f4b3a520719
一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：
先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉；
新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量；
然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue；
接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据；
等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。
消息队列面试题",
MQ 中的消息过期失效了怎么办？,"具体可以看这里：https://www.jianshu.com/p/5f4b3a520719
假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 Queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。这时的问题就不是数据会大量积压在 MQ 里，而是大量的数据会直接搞丢。这个情况下，就不是说要增加 Consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。
我们可以采取一个方案，就是批量重导。就是大量积压的时候，直接丢弃数据了，然后等过了高峰期以后开始写程序，将丢失的那批数据一点一点的查出来，然后重新灌入 MQ 里面去，把丢的数据给补回来。
消息队列面试题",
RabbitMQ 有哪些重要的角色？,"RabbitMQ 中重要的角色有：生产者、消费者和代理。
生产者：消息的创建者，负责创建和推送数据到消息服务器；
消费者：消息的接收方，用于处理数据和确认消息；
代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。
消息队列面试题",
RabbitMQ 有哪些重要的组件？,"ConnectionFactory（连接管理器）：应用程序与 rabbit 之间建立连接的管理器，程序代码中使用；
Channel（信道）：消息推送使用的通道；
Exchange（交换器）：用于接受、分配消息；
Queue（队列）：用于存储生产者的消息；
RoutingKey（路由键）：用于把生成者的数据分配到交换器上；
BindingKey（绑定键）：用于把交换器的消息绑定到队列上。
消息队列面试题",
RabbitMQ 有几种广播类型？,"RabbitMQ 有三种广播模式：fanout、direct、topic。
fanout：所有 bind 到此 exchange 的 queue 都可以接收消息；很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 交换机转发消息是最快的。
direct：通过 routingKey 和 exchange 中的 bindingKey 决定的那个唯一的 queue 可以接收消息；
topic：所有符合 routingKey 所 bind 的 queue 可以接收消息。
消息队列面试题",
Kafka 可以脱离 zookeeper 单独使用吗？为什么？,"Kafka 不能脱离 zookeeper 单独使用，因为 Kafka 使用 zookeeper 管理和协调 Kafka 的节点服务器。
补充：最新版本的 Kafka 2.8.0 版本实现了 Raft 分布式一致性机制，意味着可以脱离 ZooKeeper 独立运行
消息队列面试题",
Kafka 有几种数据保留的策略？,"Kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。
消息队列面试题",
Kafka 的分区策略有哪些？,"所谓分区策略就是决定生产者将消息发送到哪个分区的算法。
轮询策略：默认的分区策略，非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上；
随机策略：实现随机策略版的 partition 方法；
按消息键保序策略：也称 Key-Ordering 策略，可以保证同一个 Key 的所有消息都进入到相同的分区里，由于每个分区下的消息处理是有顺序的，所以称之为消息键保序策略；
自定义分区策略：在编写生产者程序时，你可以编写一个具体的类实现org.apache.kafka.clients.producer.Partitioner 接口。这个接口也很简单，只定义了两个方法：partition() 和 close()，通常只用实现 partition() 方法即可。同时还需要设置 partitioner.class 参数为你自己实现类的全限定类名
消息队列面试题",
消息队列,"消息队列的主要作用是：解耦、异步、削峰。
A 系统通过接口调用发送数据到 B、C、D 三个系统。那如果现在 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？现在 A 系统又要发送第二种数据了呢？这样的话 A 系统的维护成本就非常的高，而且 A 系统要时时刻刻考虑B、C、D、E 四个系统如果出现故障该怎么办？A 系统是重发还是先把消息保存起来呢？使用消息队列就可以解决这个问题。A 系统只负责生产数据，不需要考虑消息被哪个系统来消费。
A 系统需要发送个请求给 B 系统处理，由于 B 系统需要查询数据库花费时间较长，以至于 A 系统要等待 B 系统处理完毕后再发送下个请求，造成 A 系统资源浪费。使用消息队列后，A 系统生产完消息后直接丢进消息队列，不用等待 B 系统的结果，直接继续去干自己的事情了。
A 系统调用 B 系统处理数据，每天 0 点到 12 点，A 系统风平浪静，每秒并发请求数量就 100 个。结果每次一到 12 点 ~ 13 点，每秒并发请求数量突然会暴增到 1 万条。但是 B 系统最大的处理能力就只能是每秒钟处理 1000 个请求，这样系统很容易就会崩掉。这种情况可以引入消息队列，把请求数据先存入消息队列中，消费系统再根据自己的消费能力拉取消费。
消息队列的优点就是：解耦、异步、削峰。
系统复杂度提高：使用 MQ 后可能需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题；
一致性问题：A 系统处理完了直接返回成功了，但问题是：要是 B、C、D 三个系统那里，B 和 D 两个系统写库成功了，结果 C 系统写库失败了，就造成数据不一致了。
根据不同的 MQ 或者你用过的 MQ 进行回答：
RabbitMQ 是基于主从做高可用性的，Rabbitmq有三种模式：单机模式、普通集群模式、镜像集群模式。单机模式一般在生产环境中很少用，普通集群模式只是提高了系统的吞吐量，让集群中多个节点来服务某个 Queue 的读写操作。那么真正实现 RabbitMQ 高可用的是镜像集群模式。
镜像集群模式跟普通集群模式不一样的是，创建的 Queue，无论元数据还是Queue 里的消息都会存在于多个实例上，然后每次你写消息到 Queue 的时候，都会自动和多个实例的 Queue 进行消息同步。这样设计，好处在于：任何一个机器宕机不影响其他机器的使用。坏处在于：1. 性能开销太大：消息同步所有机器，导致网络带宽压力和消耗很重；2. 扩展性差：如果某个 Queue 负载很重，即便加机器，新增的机器也包含了这个 Queue 的所有数据，并没有办法线性扩展你的 Queue。
Kafka 基本架构是多个 broker 组成，每个 broker 是一个节点。创建一个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据，这就是天然的分布式消息队列。就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。
Kafka 0.8 以前，是没有 HA 机制的，任何一个 broker 宕机了，它的 partition 就没法写也没法读了，没有什么高可用性可言。
Kafka 0.8 以后，提供了 HA 机制，就是 replica 副本机制。每个 partition 的数据都会同步到其他机器上，形成自己的多个 replica 副本。然后所有 replica 会选举一个 leader 出来，生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上数据即可。Kafka 会均匀的将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。
要保证消息不被重复消费，其实就是要保证消息消费时的幂等性。幂等性：无论你重复请求多少次，得到的结果都是一样的。例如：一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。
那么如何保证幂等性呢？
数据库的唯一键约束也可以保证不会重复插入多条，因为重复插入多条只会报错，不会导致数据库中出现脏数据；
如果是写 redis，就没有问题，因为 set 操作是天然幂等性的。


拆分多个 Queue，每个 Queue一个 Consumer，就是多一些 Queue 而已，确实是麻烦点；或者就一个 Queue 但是对应一个 Consumer，然后这个 Consumer 内部用内存队列做排队，然后分发给底层不同的 Worker 来处理。
写 N 个内存 Queue，具有相同 key 的数据都到同一个内存 Queue；然后对于 N 个线程，每个线程分别消费一个内存 Queue 即可，这样就能保证顺序性。
具体可以看这里：https://www.jianshu.com/p/5f4b3a520719
一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：
新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量；
然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue；
接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据；
等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。
具体可以看这里：https://www.jianshu.com/p/5f4b3a520719
假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 Queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。这时的问题就不是数据会大量积压在 MQ 里，而是大量的数据会直接搞丢。这个情况下，就不是说要增加 Consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。
我们可以采取一个方案，就是批量重导。就是大量积压的时候，直接丢弃数据了，然后等过了高峰期以后开始写程序，将丢失的那批数据一点一点的查出来，然后重新灌入 MQ 里面去，把丢的数据给补回来。
RabbitMQ 中重要的角色有：生产者、消费者和代理。
消费者：消息的接收方，用于处理数据和确认消息；
代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。
ConnectionFactory（连接管理器）：应用程序与 rabbit 之间建立连接的管理器，程序代码中使用；
Channel（信道）：消息推送使用的通道；
Exchange（交换器）：用于接受、分配消息；
Queue（队列）：用于存储生产者的消息；
RoutingKey（路由键）：用于把生成者的数据分配到交换器上；
BindingKey（绑定键）：用于把交换器的消息绑定到队列上。
RabbitMQ 有三种广播模式：fanout、direct、topic。
direct：通过 routingKey 和 exchange 中的 bindingKey 决定的那个唯一的 queue 可以接收消息；
topic：所有符合 routingKey 所 bind 的 queue 可以接收消息。
Kafka 不能脱离 zookeeper 单独使用，因为 Kafka 使用 zookeeper 管理和协调 Kafka 的节点服务器。
Kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。
所谓分区策略就是决定生产者将消息发送到哪个分区的算法。
轮询策略：默认的分区策略，非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上；
随机策略：实现随机策略版的 partition 方法；
按消息键保序策略：也称 Key-Ordering 策略，可以保证同一个 Key 的所有消息都进入到相同的分区里，由于每个分区下的消息处理是有顺序的，所以称之为消息键保序策略；
自定义分区策略：在编写生产者程序时，你可以编写一个具体的类实现org.apache.kafka.clients.producer.Partitioner 接口。这个接口也很简单，只定义了两个方法：partition() 和 close()，通常只用实现 partition() 方法即可。同时还需要设置 partitioner.class 参数为你自己实现类的全限定类名
消息队列面试题",
如何判断一个数是否在40亿个整数中？,"题目：我有40亿个整数，再给一个新的整数，我需要判断新的整数是否在40亿个整数中，你会怎么做？











【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。


小史忙拉着吕老师问，为什么我说分8次加载数据，面试官会说太慢了呢？
吕老师：哈哈，从磁盘加载数据是磁盘io操作，是非常慢的，你每次都要加载这么大的数据，还要8次，我估计你找一个数的时间可以达到分钟甚至小时级了。

小史：那如果是你，你会怎么办呢？
吕老师：其实面试官已经提示得比较明显了，他说给你一批机器，就是暗示你可以用分布式算法。你把数据分散在8台机器上，然后来一个新的数据，8台机器一起找，最后再汇总结果就行了。

小史：这样的话能快多少？
吕老师：这样应该能达到秒级。小史，你可以自己分析分析。
小史：我想想……哦，这样做的话，因为每台机器都可以一次性把数据读入内存，在比较的时候不用来回加载数据了，所以可以节省加载数据的开销！这真是个好办法。
【更好方案】
吕老师：其实这并不是最好方法，我这还有一种毫秒级的方法，想不想知道啊？
小史：当然想啊，快教教我。

小史：哦，对哦，这样我就申请40亿个位就好了，新的数转换成一个位，然后判断一下这个位是0还是1就行了。
吕老师：小史啊，考虑问题要考虑清楚啊，如果是40亿个位，那么这40亿个位哪些是0，哪些是1呢？来了一个新的数，怎么判断是否在40亿个位之中？

小史：我想想，对啊，40亿个位，40亿个数，那么每个位都是1，这。。。
吕老师：其实你可以想想，32位int的范围，总共就是2的32次方，大概42亿多点。所以你可以申请2的32次方个位。
小史：意思是我把整个整数范围都覆盖了，哦，对哦。这样一来，就可以做了，1代表第一个位，2代表第二个位，2的32次方代表最后一个位。40亿个数中，存在的数就在相应的位置1，其他位就是0。

吕老师：没错，那来了一个新的数呢？
小史：新的数就去找相应的位，比如来了一个1234，就找一下第1234位，如果是1就存在，是0就不存在啦。
吕老师：没错，那么这样的话，需要多大内存呢？
小史：我想想啊，2的32次方个位，相当于2的29次方个字节，哇，才500MB，真是节省了不少内存呢。

小史：这么厉害的算法，你是怎么想到的？

吕老师：其实这是一种非常有名的大数据算法，叫位图法，英文名叫bitmap。顾名思义，就是用位来表示状态，从而节省空间。明天正好我有一节课，就讲位图法，你可以来听一听。
【吕老师的课】
第二天，吕老师开始上课，他一开始就抛出了小史遇到的面试题。
吕老师：同学们，这道题是BAT公司的一道面试题，大家有什么思路吗？
话音刚落，蛋哥就站起来回答。蛋哥是吕老师最得意的门生，以思维活跃著称。

蛋哥：我觉得可以这样。首先，32位int的范围是42亿，40亿整数中肯定有一些是连续的，我们可以先对数据进行一个外部排序，然后用一个初始的数和一个长度构成一个数据结构，来表示一段连续的数，举个例子。
如果数据是1 2 3 4 6 7……这种的，那么可以用(1,4)和(6,2)来表示，这样一来，连续的数都变成了2个数表示。
来了一个新数之后，就用二分法进行查找了。
这样一来，最差情况就是2亿多的断点，也就是2亿多的结构体，每个结构体8个字节，大概16亿字节，1.6GB，在内存中可以放下。

吕老师：嗯，非常好，不仅给出了方案，还能主动分析空间和可行性。
小史听完后深感佩服，问题的解决方法绝对不止一种，只要肯动脑筋，即使没有学过bitmap算法，也能有别的方法来解决问题。
【课后】
下课后，小史又找到吕老师。


吕老师：但是你的理解能力还是很强的，很多东西一听就懂，这可不是谁都能做到的。
算法面试
面试现场",
如何实现可以获取最小值的栈？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT。

今天他又去BAT中的一家面试了。
简单的自我介绍后，面试官给了小史一个问题。

题目：我现在需要实现一个栈，这个栈除了可以进行普通的push、pop操作以外，还可以进行getMin的操作，getMin方法被调用后，会返回当前栈的最小值，你会怎么做呢？你可以假设栈里面存的都是int整数。


























【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。





【异常情况处理】

吕老师：面试官已经提出了你的异常处理有点问题，当栈内为空的时候，你返回-1，但是如果用户push过-1，那么你返回-1的时候，是用户push进来的值，还是栈为空，就不得而知了。



小史咬咬牙：那就再定义一个类，里面包括一个int的data和一个boolean的isSuccess，正常情况下isSuccess是true，栈为空的话，isSuccess是false。这样就能区分开了吧？


小史突然一拍大腿：对哦，我可以用一个包装类Integer来定义返回值，如果是空，就代表栈为空就行了。它和int的区别就是它多了一个null，正好用来返回异常情况。

吕老师：嗯，越来越好，但是还是有点问题。你并没有站在使用者的角度考虑问题。使用你这个栈的人，在pop的时候，他并不知道可能返回null，如果他不做判断，后面的代码就可能抛出空指针了。




吕老师发来一个表情。




吕老师：没错，最关键的是，你显式抛出异常，如果使用者不捕获，那么编译就会报错，这样就把错误暴露在编译阶段，并且不需要和任何人商量所谓的特殊返回值了。


【算法优化】


吕老师一眼看穿了小史的心思。





小史想了想：明白了，我可以在push的时候判断一下，如果比最小值还大，就不加入辅助栈。pop的时候，如果不是最小值，辅助栈就不出栈。这样一来，辅助栈就不会有大量重复元素了。

小史：push的时候进行判断，如果数值比当前最小值大，就不动mins栈了，这样mins栈中不会保存大量冗余的最小值。pop的时候同样进行判断，只有pop出的数就是当前最小值的时候，才让mins出栈。



小史：如果push一个和最小值相等的元素，还是要入mins栈。不然当这个最小值pop出去的时候。data中还会有一个最小值元素，而mins中却已经没有最小值元素了。





小史：mins栈中改存最小值在data数组中的索引。这样一来，当push了与最小值相同元素的时候，就不需要动mins栈了。而pop的时候，pop出的元素的索引如果不是mins栈顶元素，mins也不出栈。同时，获取最小值的时候，需要拿到mins栈顶元素作为索引，再去data数组中找到相应的数作为最小值。


理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：


【小史的疑惑】
吃饭的时候，小史提出了心中埋藏已久的疑惑。


吕老师：数据结构和算法的设计是一个程序员的内功，工作时虽然用不到这么细，但是你在学习其他知识的底层原理的时候，到处都是数据结构和算法。



  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，这可以激励加速更新哦，也欢迎来留言催更，关注公众号「程序员内功修炼」，回复「读者」即可加入高质量读者群

算法面试
面试现场",
为什么要分稳定排序和非稳定排序？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他去了一家互联网小巨头公司面试了。
没想到面试并不像想象中的顺利。
【遇见吕老师】



【面试现场】







小史：原始数据，a2和a4的位置都是3。对于稳定排序来说，排序后的序列，a2一定还是在a4前面。但是对于非稳定排序来说，就不一定了，可能排完序之后，a4反而在a2的前面了。



题目：既然最后都是有序序列，为什么还要分稳定和非稳定的排序呢？

半分钟过去了。




【请教大神】



吕老师：笔试主要问是什么，而面试主要问为什么。


【吕老师的课】
吕老师一上课就把问题抛了出来。

话音刚落，蛋哥就站了起来。

蛋哥：咱们每次考试完成后，都会按照分数进行排序。分高的自然就是第一名。分数相同的同学怎么办呢？那就是按照上次的分数来分高低。上次分高的排在前面。

蛋哥：这个时候就应该用稳定排序，在上次排好序的序列上，再针对这次的分数进行排序。稳定排序的结果能保证这次相同分数的人，上次分高的在前面。

蛋哥：再比如我们班的同学，已经按照学号排好序了。现在要按照身高排序。如果是稳定排序排好之后，身高相同的同学，还是按照学号顺序的。

吕老师：没错，其实就是有两个排序关键字的时候，稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数。
小史听完后，觉得很惭愧，其实这些场景自己也遇到过，早该想到的。
【课后】
课后小史又找到吕老师。


吕老师：你看的东西很多，是你学到了很多知识。但是这些知识之间的关联，需要你进行深入思考才能得到的。找到知识之间的联系，找到知识和实际场景之间的联系，多想想为什么，才能做到融会贯通。
算法面试
面试现场",
如何找到字符串中的最长回文子串？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他又去一家互联网小巨头公司面试了。
【面试现场】







小史：只要先对比第一个字符和倒数第一个字符，再对比第二个字符和倒数第二个字符，以此类推。如果都相等，那就是回文串了。

题目：给你一个字符串，找出里面最长的回文子串。
例如
输入abcdcef，那么输出应该是cdc
输入adaelele，输出应该是elele





半分钟过去了。



小史：可以遍历整个字符串，把每个字符和字符间的空隙当作回文的中心，然后向两边扩展来找到最长回文串。
小史这次抢着分析时间和空间复杂度。



一分钟过去了。




【请教大神】
小史回到学校，把面试情况和吕老师说了一下。


吕老师：比如cabadabae用中心扩展的算法，我已经知道了第三位为中心的aba和第5位为中心的abadaba是回文，那么在判断第7位为中心的回文串的时候，有什么已知信息吗？


小史：已知第5位为中心的abadaba是回文，由回文的特性，就能够知道2-4位和6-8位对称，而又知道第3位为中心的aba是回文，所以2-4位是回文。这样的话，6-8位肯定是回文。





小史拿着笔在纸上画了半天，突然大叫一声。

小史：由于之前的计算已经知道了第5位为中心的abadaba是回文，而第4位为中心的a的回文长度是1，所以第6位为中心的回文长度只能是1，不用再去扩展判断了。





小史：以第7位为中心的回文串的计算，由之前分析已经知道最小长度是3了，但是还是需要进行扩展，因为第9位是什么根据之前的信息无法得知，需要扩展进行探索。


小史：而以第6位为中心的回文串的计算，并不需要进行探索了，因为根据之前第5位为回文中心串的信息和第4位为回文中心串的信息已经可以推断第6位为回文中心串的长度只能为1。










小史：当然可以。
1、首先，我们要记录下目前已知的回文串能够覆盖到的最右边的地方，就像案例中的第8位
2、同时，覆盖到最右边的回文串所对应的回文中心也要记录，就像案例中的第5位
3、以每一位为中心的回文串的长度也要记录，后面进行推断的时候能用到，就像案例中用到的以第3位为中心的回文和第4位为中心的回文
4、对于新的中心，我们判断它是否在右边界内，若在，就计算它相对右边界回文中心的对称位置，从而得到一些信息，同时，如果该中心需要进行扩展，则继续扩展就行。
【编码实现】


小史：回文的中心有可能是两个字符中间，这种情况没有考虑到啊。





小史：
1、先对字符串进行预处理，两个字符之间加上特殊符号#
2、然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整）
3、每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度
4、判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界
5、最后得到最长回文之后，去掉其中的特殊符号即可


理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
PlalindromeString.java
Main.java
运行结果：

【时间空间分析】










算法面试
面试现场",
如何在500w个单词中统计特定前缀的单词有多少个?,"如何在500w个单词中统计特定前缀的单词有多少个？

今天小史去了一家在线英语培训公司面试了。
简单的自我介绍后，面试官给了小史一个问题。

题目：我有500w个单词，你帮忙设计一个数据结构来进行存储，存好之后，我有两个需求。
1、来了一个新的单词，需要判断是否在这500w个单词中
2、来了一个单词前缀，给出500w个单词中有多少个单词是该前缀
小史这次没有不假思索就给出回答，他学会了深沉。


小史回忆起吕老师之前教他的 bitmap 算法。

小史心想：bitmap可以判断一个数是否在40亿个int32数中，其核心是每一个数映射成一个位，同时申请的bit位数覆盖了整个int32的值域。
小史在纸上算了半天，终于开口了。



小史：好的，我用bitmap来做第一问。我把每一个字符串映射成一个位。比如，a是第1位，b是第2位，z是第26位，aa是第27位，ab是第28位，以此类推。英文一共26个字母，我算了一下，6个字符长度的单词总共有26的6次方个，需要占26的6次方个位，大概300M









小史：建立数据结构的时候，排序需要花掉nlg(n)，排序时字符串比较花掉m，时间一共mnlg(n)。查找的话用二分，就是mlg(n)了。空间是mn。


一分钟过去了。




【请教大神】
回到学校，小史把面试情况和吕老师说了一下。

s

吕老师：你想想，a到z这26个字母中，可能只有a和i两个是单词，其他都不是，所以你的bitmap大量空间都被浪费了。这种情况你搞个hashset没准还更省一点。



【树形结构解难题】







小史：哦，这确实是节省了空间，如果要找单词interest，那么就找根节点了，如果是找单词interesting，那么就从根节点往下走，再把沿路的字母们都拼起来就行了。







（注：这里说的in不是单词，指的是in不是500w单词中的单词）
吕老师还没说完，小史就打断了他。








找单词interest：

找前缀为inter的所有单词：

遍历以前缀节点为根结点的一棵树，就能统计出前缀为inter的所有单词有多少个。
【字典树】












小史：节点中增加一个变量用于计数，在添加节点的时候，就把相应的计数+1



理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DictionaryTree.java
Main.java
运行结果
【字典树的应用】


小史：我想想啊，大量字符串的统计和查找应该就可以用字典树吧？字符串前缀的匹配也可以用，像咱们搜索常见的autoComplete控件是不是就可以用？




算法面试
面试现场",
如何在10亿数中找出前1000大的数？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

之前小史在BAT三家的面试中已经挂了两家，今天小史去了BAT中的最后一家面试了。
简单的自我介绍后，面试官给了小史一个问题。
【面试现场】

题目：如何在10亿数中找出前1000大的数？







小史：我可以用分治法，这有点类似快排中partition的操作。随机选一个数t，然后对整个数组进行partition，会得到两部分，前一部分的数都大于t，后一部分的数都小于t。


小史：如果说前一部分总数大于1000个，那就继续在前一部分进行partition寻找。如果前一部分的数小于1000个，那就在后一部分再进行partition，寻找剩下的数。





小史：首先，partition的过程，时间是o(n)。我们在进行第一次partition的时候需要花费n，第二次partition的时候，数据量减半了，所以只要花费n/2，同理第三次的时候只要花费n/4，以此类推。而n+n/2+n/4+…显然是小于2n的，所以这个方法的渐进时间只有o(n)

（注：这里的时间复杂度计算只是简化计算版，真正严谨的数学证明可以参考算法导论相关分析。）



半分钟过去了。







小史一时慌了神。

他回忆起了之前吕老师给他讲解bitmap时的一些细节。突然有了一个想法。




小史在纸上画了画。













理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
TopN.java
Main.java
运行结果：
（注：由于1000个数字符过多，超了微信文章限制，结果进行了省略，大家可以本地运行查看结果）
面试官看了一下。

小史熟练地介绍起了自己的项目，由于准备充分，小史聊起来游刃有余。面试官问的几个问题也进行了详细的解释。


小史走后，面试官在系统中写下了面试评语：

【遇见吕老师】
小史回到学校哼着歌走在校园的路上，正好碰到吕老师。


小史把面试情况和吕老师说了一下。


小史：感悟还挺深的。虽然平时做过topN的问题，知道分治法时间更少。但是碰到具体问题的时候还是要具体分析，这种大数据量的情况下反而用堆会更快。


算法面试
面试现场",
如何编程获得最多的年终红包奖？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天小史又去了一家互联网小巨头公司面试了。
【面试现场】












小史眉头一皱，发现事情并不简单。

题目：在数字矩阵中，从左上角到右下角，每次只能向右或向下，如何规划路径，能获得最大数字总和？
小史开始仔细分析问题，一时间竟想不到很好的方法。

小史心中反复默念题目，进行思考。

小史仔细回忆起了吕老师教他的华容道搜索算法。












【请教大神】
回到学校，小史把面试情况和吕老师说了一下。






吕老师：红色和蓝色两条路都能到达中间的100这个点，但是很明显，红色的路拿到的奖金更多。所以蓝色的路，后面不管再怎么走，都不可能拿到最大的奖金数了。


吕老师：假设蓝色路径再往后走出一条绿色路径是最大奖金，那么我把蓝色路径替换成红色路径，红色加绿色得到的奖金就比蓝色加绿色得到的多呀。


【记忆化搜索】







小史：哦，我明白了，这样我每搜到一个点，都可以和这个数比较，如果比它大，就更新这个数，继续搜，如果比它小，就不搜了，直接剪枝。





理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DeepFirstSearch.java
Main.java
运行结果
【记忆广搜】



吕老师：记忆深搜确实可以剪枝，但是假如有人刻意安排数字，把较小的数都安排在你先搜的路径上，那么你的计算量还是不会减少太多。


小史：还有这么坏的人呢？不过你这样一说我到想起来，深搜确实缺少一种“全局观”，可能第一条路搜完了，再来看第二条路，发现更好，结果第一条路全白搜了。





理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
BreadthFirstSearch.java
Main.java
运行结果
【动态规划】

吕老师：小史，代码写得不错，咱们再来看看广搜的过程，其实就是在搜索的过程中从左上到右下计算出了best(i,j)，所以为啥我们不能直接算出best(i,j)呢？






理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DynamicProgramming.java
Main.java
运行结果
【动态规划解析】






吕老师：状态的定义要满足几个点，第一，问题的答案是某种状态，或者可由状态进行推导。第二，当前状态可以由之前的状态推导而来。

【状态压缩】






小史：哦，我知道了，这道题，如果按照斜线方向来计算，只需要保留一条斜线的状态，就能计算出下一条斜线。所以之前的状态就不需要保留了。



理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DpCompressed.java
Main.java
运行结果




算法面试
面试现场",
如何编程解决朋友圈个数问题？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天小史去了一家社交小巨头公司面试了。
【面试现场】









面试官：举个例子，比如现在有5个宠物，分别是小猫1，小猫2，小猫3，小狗1，小狗2。再告诉你小猫1和小狗1是好朋友，小猫2和小狗1是好朋友，小猫3和小狗2是好朋友。这样它们之间就形成了2个朋友圈。










小史：先对宠物们编号，然后一对好友关系就用一个bitmap来存。判断两个bitmap之间是否有交集，只需要进行与操作。而融合的话只需要进行并操作。





小史在纸上画了半天进行思考。一分钟过去了。

小史：我好像知道了，可以在遍历好友关系的同时，把他们进行合并，我用双向链表来做。初始时，每个宠物都是一个单独的节点，而一对好友关系过来的时候，先判断两个节点是否在同一个链表中，如果不在，就把两个节点所在的链表头尾相连，形成一个新链表。



一分钟过去了。




【请教大神】
回到学校，小史把面试情况和吕老师说了一下。




















小史：这个我早就考虑到了，1和3是好朋友，并不是连接1和3，而是去找1的根和3的根，发现他们都是2，所以他们本来就在一个朋友圈，不需要相连。



【并查集】








小史：哦，对，堆也是一种树，但是它是二叉树，而且是完全二叉树，所以才能用数组存，并且用坐标的方式计算父亲孩子节点。


吕老师：今天的树同样可以用数组存，初始时刻数组中都是-1，当有两个节点需要合并时，只需要将其中一个数的根的值设为另一个数的根的下标就行。



小史在纸上划拉半天，终于有点明白了




理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了。
UnionFindSet.java
Main.java
运行结果
【基于树高度的合并优化】




吕老师：1和2是好朋友，2和3是好朋友，3和4是好朋友，4和5是好朋友







理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了。
UnionFindSetMergeOptimize.java
Main.java
运行结果
【路径压缩优化】








理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了。
UnionFindSetPathOptimize.java
Main.java
运行结果：
看着自己写的代码，小史还是忍不住赞叹。


算法面试
面试现场",
如何设计可自学习的五子棋AI？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他去了一家国内人工智能巨头公司面试了。
简单的自我介绍后，面试官开始发问了。

【面试现场】




题目：如何设计可自学习的五子棋AI？












【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。





【AlphaGO】









吕老师：一开始的AlphaGO是什么都不知道的，它是随机落子。但是它并不是random一个点，而是根据现场的情况和自身的算法，来落子，只是算法中的参数是随机的，所以落下的子也是随机的。







吕老师：这就要靠人去设计了，当然我们现在有一些比较成熟的神经网络模型，选好之后，所谓的训练啊，学习啊，其实都是在调节里面的参数。

【五子棋AI设计】

吕老师：首先我们来看你的算法，你会发现它的规则都是定死的，如果出现一种没有考虑到的情况，那么算法就不能进行堵截。



吕老师：哈哈，如果这样做的话，这种情况是无穷无尽的。而且五子棋的玩法比较简单，你还能设计出这样的规则，像围棋这种复杂的棋类，你可能没办法去设计这些规则了。




















小编注：关于这种算法的具体实现，由于篇幅较大就不在文章中具体展开了。想了解具体实现的朋友可以观看我在慕课网录制的免费视频教程：JS实现人机大战之五子棋（AI篇），地址：https://www.imooc.com/learn/644。
https://www.imooc.com/learn/644
【AI】






吕老师：小史，你看4个子的权重，你给10000，或者给50000，甚至给1个亿，对于其他值来说都是绝对高的值，所以最后效果应该是一样的。






吕老师：我们刚刚设计的这个五子棋算法，其实还是很简单，所以搜索空间并不大，如果是围棋这种复杂棋类，搜索空间将巨大无比，那就要采用非常先进的AI算法了，里面可能有成千上万个参数，训练起来计算量也是非常大，会有很多降维算法在里面，这些等你真正遇到，我再给你讲吧。


算法面试
面试现场",
为什么MySQL数据库要用B+树存储索引？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

话说两个多月前，小史通过了A厂的一面，两个多月后的今天，小史终于等到了A厂的二面。
简单的自我介绍后，面试官看了看小史的简历，开始发问了。

【面试现场】


小史：没问题，这个项目前端用的react+webpack，后端用的nginx+SpringBoot+Redis+MySql，前后端分离的，最后用docker进行容器化部署。主要模块有师生系统、课程系统、成绩系统、选课系统等。





这个项目的架构和说辞，小史早已背得溜溜的。

小史：底层mysql是存储，redis是缓存，dao层操作mysql，cache层操作redis，service层处理业务逻辑，rest api层为前端提供rest接口。前端这边用react进行模块化，webpack打包部署。网关nginx进行负载均衡。mysql、redis、nginx和springboot应用都放在docker里部署。














题目：为什么MySQL数据库要用B+树存储索引？
小史听到这个题目，陷入了回忆。
【前段时间的饭局】
话说吕老师给小史讲完人工智能的一些知识后，他们一起回家吃小史姐姐做的饭去了。


【饭后】


吕老师：面试的时候一定是往深了问，不精通的话容易吃亏。不过面试时一般都是根据项目来问，项目中用到的技术，一定要多看看原理，特别是能和数据结构和算法挂钩的那部分。



小史：树的话，无非就是前中后序遍历、二叉树、二叉搜索树、平衡二叉树，更高级一点的有红黑树、B树、B+树，还有之前你教我的字典树。
【红黑树】

一听到红黑树，小史头都大了，开始抱怨了起来。

小史：红黑树看过很多遍了，但是每次都记不住，它的规则实在是太多了，光定义就有四五条规则，还有插入删除的时候，需要调整树，复杂得很

吕老师：小史，问你红黑树，并不是让你背诵它的定义，或者让你手写一个红黑树，而是想问问你它为什么这样设计，它的使用场景有哪些。















【B树】

















吕老师：小史，你要知道，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。

两个月前，小史面试没考虑内存情况差点挂了，传送门
传送门






【B+树】







吕老师：这也是和业务场景相关的，你想想，数据库中select数据，不一定只选一条，很多时候会选多条，比如按照id排序后选10条。

小史：我明白了，如果是多条的话，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。


【回到现场】


小史：这和业务场景有关。如果只选一个数据，那确实是hash更快。但是数据库中经常会选择多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。

小史：而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。

HR和小史简单地聊了聊基本情况，这次面试就结束了。
小史走后，面试官在系统中写下了面试评语：

几天后，小史收到了A厂的offer。


亲爱的场粉们，面试现场的第一季到这里就全部结束了，感谢大家的支持，我们一起期待小史后面的故事。
算法面试
面试现场",
游戏中的敏感词过滤是如何实现的？,"小秋今天去面试了，面试官问了一个与敏感词过滤算法相关的问题，然而小秋对敏感词过滤算法一点也没听说过。于是，有了下下事情的发生…..
面试官：玩过王者荣耀吧？了解过敏感词过滤吗？，例如在游戏里，如果我们发送“你在干嘛？麻痹演员啊你？”，由于“麻痹”是一个敏感词，所以当你把聊天发出来之后，我们会用“**”来代表“麻痹”这次词，所以发送出来的聊天会变成这样：“你在干嘛？**演员啊你？”。
小秋：听说过啊，在各大社区也经常看到，例如评论一个问题等，一些粗话经常被过滤掉了。
面试官：嗯，如果我给你一段文字，以及给你一些需要过滤的敏感词，你会怎么来实现这个敏感词过滤的算法呢？例如我给你一段字符串“abcdefghi”,以及三个敏感词”de”, “bca”, “bcf”。
小秋：（敏感词过来算法？？不就是字符串匹配吗？）我可以通过字符串匹配算法，例如在字符串”abcdefghi”在查找是否存在字串“de”，如果找到了就把”de“用”**”代替。通过三次匹配之后，接变成这样了：“abc ** fghi”。
面试官：可以说说你采用哪种字符串匹配算法吗？
小秋：最简单的方法就是采用两个for循环保留求解了，不过每次匹配的都时间复杂度为O(n*m)，我可以采用 KMP 字符串匹配算法，这样时间复杂度是 O(m+n)。

  n 表示字符串的长度，m 表示每个敏感词的长度。

面试官：这是一个方法，对于敏感词过滤，你还有其他方法吗？
小秋：（其他方法？说实话，我也觉得不是采用这种 KMP 算法来匹配的了，可是，之前也没去了解过敏感词，这下要凉）对敏感词过来之前也没了解过，暂时没想到其他方法。
面试官：了解过 trie 树吗？
小秋：（嘿嘿，数据结构这方法，我得争气点）了解过，我还用代码实现过。
面试官：可以说说它的特点吗？
小秋：trie 树也称为字典树、单词查找树，最大的特点就是共享字符串的公共前缀来达到节省空间的目的了。例如，字符串 “abc”和”abd”构成的 trie 树如下：

trie 树的根节点不存任何数据，每整个个分支代表一个完整的字符串。像 abc 和 abd 有公共前缀 ab，所以我们可以共享节点 ab。如果再插入 abf，则变成这样：

如果我再插入 bc，则是这样（bc 和其他三个字符串没有公共前缀）

面试官：那如果再插入 “ab” 这个字符串呢？
小秋：差点说了，每个分支的内部可能也含有完整的字符串，所以我们可以对于那些是某个字符串结尾的节点做一个标记，例如 abc, abd,abf 都包含了字符串 ab,所以我们可以在节点 b 这里做一个标记。如下（我用红色作为标记）：

面试官：可以说说 trie 树有哪些应用吗？
小秋：trie 最大的特点就是利用了字符串的公共前缀，像我们有时候在百度、谷歌输入某个关键字的时候，它会给我们列举出很多相关的信息

这种就是通过 trie 树来实现的。
小秋：（嗯？ trie 又称为单词查找树，好像可以用 trie 来实现刚才的敏感词匹配？面试官无缘无故提 trie 树难道别有用意？）
面试官：刚才的敏感词过滤，其实也可以采用 trie 来实现，你知道怎么实现吗？
小秋：（果然，面试官真是个好人啊，直接提示了，要是还不知道怎么实现，那不真凉？）我想想……..我知道了，我可以这样来实现：
先把你给我的三个敏感词：”de”, “bca”, “bcf” 建立一颗 trie 树，如下：

接着我们可以采用三个指针来遍历，我直接用上面你给你例子来演示吧。
1、首先指针 p1 指向 root，指针 p2 和 p3 指向字符串第一个字符

2、然后从字符串的 a 开始，检测有没有以 a 作为前缀的敏感词，直接判断 p1 的孩子节点中是否有 a 这个节点就可以了，显然这里没有。接着把指针 p2 和 p3 向右移动一格。

3、然后从字符串 b 开始查找，看看是否有以 b 作为前缀的字符串，p1 的孩子节点中有 b，这时，我们把 p1 指向节点 b，p2 向右移动一格，不过，p3不动。

4、判断 p1 的孩子节点中是否存在 p2 指向的字符c，显然有。我们把 p1 指向节点 c，p2 向右移动一格，p3不动。

5、判断 p1 的孩子节点中是否存在 p2 指向的字符d，这里没有。这意味着，不存在以字符b作为前缀的敏感词。这时我们把p2和p3都移向字符c，p1 还是还原到最开始指向 root。

6、和前面的步骤一样，判断有没以 c 作为前缀的字符串，显然这里没有，所以把 p2 和 p3 移到字符 d。

7、然后从字符串 d 开始查找，看看是否有以 d 作为前缀的字符串，p1 的孩子节点中有 d，这时，我们把 p1 指向节点 d，p2 向右移动一格，不过，p3和刚才一样不动。（看到这里，我猜你已经懂了）

8、判断 p1 的孩子节点中是否存在 p2 指向的字符e，显然有。我们把 p1 指向节点 e，并且，这里e是最后一个节点了，查找结束，所以存在敏感词de，即 p3 和 p2 这个区间指向的就是敏感词了，把 p2 和 p3 指向的区间那些字符替换成 *。并且把 p2 和 p3 移向字符 f。如下：

9、接着还是重复同样的步骤，知道 p3 指向最后一个字符。
面试官：可以说说时间复杂度吗？
小秋：如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。

  这里我说明一下，在实际的应用中，构建 trie 树的时间复杂度我觉得可以忽略，因为 trie 树我们可以在一开始就构建了，以后可以无数次重复利用的了。而刚才的 kmp 算法时间复杂度是 t *(m+n)，不过kmp需要维护 next 数组比较费空间，而且在实际情况中,敏感词的数量 t 是比较大，而 n 反而比较小的吧。

10、如果让你来 构建 trie 树，你会用什么数据结构来实现？
小秋：我一般使用 Java，我会采用 HashMap 来实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。
面试官：嗯，回去等通知吧。
今天主要将了 trie 树以及 trie 树的一些应用，还要就是如何通过 trie 树来实现敏感词的过滤，至于代码的实现，我这里就不给出了，在实现的时候，为了防止这种”麻 痹”或者“麻￥痹”等，我们也要对特殊字符进行过滤等，有兴趣的可以去实现一波。
算法面试
面试现场",
如何只用2GB内存从20/40/80亿个整数中找到出现次数最多的数,"这几天小秋去面试了，不过最近小秋学习了不少和位算法相关文章，对于算法题还是有点信心的，，，，于是，发现了如下对话。
面试官：如果我给你 2GB 的内存，并且给你 20 亿个 int 型整数，让你来找出次数出现最多的数，你会怎么做？
小秋：（嗯？怎么感觉和之前的那道判断一个数是否出现在这 40 亿个整数中有点一样？可是，如果还是采用 bitmap 算法的话，好像无法统计一个数出现的次数，只能判断一个数是否存在），我可以采用哈希表来统计，把这个数作为 key，把这个数出现的次数作为 value，之后我再遍历哈希表哪个数出现最多的次数最多就可以了。
面试官：你可以算下你这个方法需要花费多少内存吗？
小秋：key 和 value 都是 int 型整数，一个 int 型占用 4B 的内存，所以哈希表的一条记录需要占用 8B，最坏的情况下，这 20 亿个数都是不同的数，大概会占用 16GB 的内存。
面试官:你的分析是对的，然而我给你的只有 2GB 内存。
小秋：（感觉这道题有点相似，不过不知为啥，没啥思路，这下凉凉），目前没有更好的方法。
面试官：按照你那个方法的话，最多只能记录大概 2 亿多条不同的记录，2 亿多条不同的记录，大概是 1.6GB 的内存。
小秋：（嗯？面试官说这话是在提示我？）我有点思路了，我可以把这 20 亿个数存放在不同的文件，然后再来筛选。
面试题：可以具体说说吗？
小秋：刚才你说，我的那个方法，最多只能记录大概 2 亿多条的不同记录，那么我可以把这 20 亿个数映射到不同的文件中去，例如，数值在 0 至 2亿之间的存放在文件1中，数值在2亿至4亿之间的存放在文件2中….，由于 int 型整数大概有 42 亿个不同的数，所以我可以把他们映射到 21 个文件中去，如图

显然，相同的数一定会在同一个文件中，我们这个时候就可以用我的那个方法，统计每个文件中出现次数最多的数，然后再从这些数中再次选出最多的数，就可以了。
面试官：嗯，这个方法确实不错，不过，如果我给的这 20 亿个数数值比较集中的话，例如都处于 1~20000000 之间，那么你都会把他们全部映射到同一个文件中，你有优化思路吗？
小秋：那我可以先把每个数先做哈希函数映射，根据哈希函数得到的哈希值，再把他们存放到对应的文件中，如果哈希函数设计到好的话，那么这些数就会分布的比较平均。（关于哈希函数的设计，我就不说了，我这只是提供一种思路）
面试官：那如果我把 20 亿个数加到 40 亿个数呢？
小秋：（这还不简单，映射到42个文件呗）那我可以加大文件的数量啊。
面试官：那如果我给的这 40 亿个数中数值都是一样的，那么你的哈希表中，某个 key 的 value 存放的数值就会是 40 亿，然而 int 的最大数值是 21 亿左右，那么就会出现溢出，你该怎么办？
小秋：（那我把 int 改为 long 不就得了，虽然会占用更多的内存，那我可以把文件分多几份呗，不过，这应该不是面试官想要的答案），我可以把 value 初始值赋值为 负21亿，这样，如果 value 的数值是 21 亿的话，就代表某个 key 出现了 42 亿次了。

这里说明下，文件还是 21 个就够了，因为 21 个文件就可以把每个文件的数值种类控制在 2亿种了，也就是说，哈希表存放的记录还是不会超过 2 亿中。

面试官：反应挺快哈，那我如果把 40 亿增加到 80 亿呢？
小秋：（我靠，这变本加厉啊）………我知道了，我可以一边遍历一遍判断啊，如果我在统计的过程中，发现某个 key 出现的次数超过了 40 亿次，那么，就不可能再有另外一个 key 出现的次数比它多了，那我直接把这个 key 返回就搞定了。
面试官：行，此次面试到此结束，回去等通知吧。
今天这篇文章主要讲了大数据处理相关的一些问题，后面可能还会给大家找一些类似，但处理方式不同的题勒.
算法面试
面试现场",
为什么需要三次握手？两次不行？,"PS：这个问的太多了，大家要先理解 =》背诵，防止突然忘了也能说个大概。这道题在问的时候，可深可浅，看面试官自己的掌握力度。
当面试官问你为什么需要有三次握手、三次握手的作用、讲讲三次三次握手的时候，我想很多人会这样回答：
首先很多人会先讲下握手的过程：
1、第一次握手：客户端给服务器发送一个 SYN 报文。
2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。
3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。
4、服务器收到 ACK 报文之后，三次握手建立完成。
作用是为了确认双方的接收与发送能力是否正常。

这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：
  第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
  第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
  第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。
这样回答其实也是可以的，但我觉得，这个过程的我们应该要描述的更详细一点，因为三次握手的过程中，双方是由很多状态的改变的，而这些状态，也是面试官可能会问的点。所以我觉得在回答三次握手的时候，我们应该要描述的详细一点，而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：
刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后
1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。
2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。
3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。
4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接

三次握手的作用
三次握手的作用也是有好多的，多记住几个，保证不亏。例如：
1、确认双方的接受能力、发送能力是否正常。
2、指定自己的初始化序列号，为后面的可靠传送做准备。
1、（ISN）是固定的吗
三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。
如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。
2、什么是半连接队列
服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

  这里在补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s,

很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。
为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。
而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。",
为什么需要四次挥手？三次不行？,"PS：这个问的太多了，大家要先理解 =》背诵，防止突然忘了也能说个大概。这道题在问的时候，可深可浅，看面试官自己的掌握力度。
四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的状态记好，我上次面试就被问了几个了，呵呵。我答错了，还以为自己答对了，当时还解释的头头是道，呵呵。
刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：
1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。（大白话：相当于客户端告诉服务端，我想断开链接了）
2、第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。（大白话：相当于，服务端告诉客户端，好的，我收到你的断开请求了）
3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

这里特别需要主要的就是TIME_WAIT这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。
至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。（下面的面试题会给出更加具体的答复）
这里我给出每个状态所包含的含义，有兴趣的可以看看。
下面是三次握手和四次挥手的图片",
TCP与UDP有哪些区别？各自应用场景？,"（1）TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。
（2）每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的；
（3）TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达；
（4）TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存；
（5）面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，但就受访的TCP可能只用了4个数据块久保收到的字节流交付给上层的应用程序，但字节流完全一样。
可靠传输有如下两个特点:
a.传输信道无差错,保证传输数据正确;
b.不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;
（1）首先，采用三次握手来建立TCP连接，四次挥手来释放TCP连接，从而保证建立的传输信道是可靠的。
（2）其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。
（3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。
（１）UDP是无连接的传输层协议；
（２）UDP使用尽最大努力交付，不保证可靠交付；
（３）UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界；
（４）UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率；
（５）UDP支持一对一　一对多　多对多的交互通信；
（６）UDP的首部开销小，只有８字节．
(1)TCP是可靠传输,UDP是不可靠传输;
(2)TCP面向连接,UDP无连接;
(3)TCP传输数据有序,UDP不保证数据的有序性;
(4)TCP不保存数据边界,UDP保留数据边界;
(5)TCP传输速度相对UDP较慢;
(6)TCP有流量控制和拥塞控制,UDP没有;
(７)TCP是重量级协议,UDP是轻量级协议;
(８)TCP首部较长２０字节,UDP首部较短８字节;
HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议
TCP应用场景：
效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
UDP应用场景：
效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）",
HTTP1.0，1.1，2.0 的版本区别,"HTTP/1.0
1996年5月，HTTP/1.0 版本发布，为了提高系统的效率，HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。
这种方式就好像我们打电话的时候，只能说一件事儿一样，说完之后就要挂断，想要说另外一件事儿的时候就要重新拨打电话。
HTTP/1.0中浏览器与服务器只保持短暂的连接，连接无法复用。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。
我们知道TCP连接的建立需要三次握手，是很耗费时间的一个过程。所以，HTTP/1.0版本的性能比较差。

  HTTP1.0 其实也可以强制开启长链接，例如接受Connection: keep-alive 这个字段，但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。

HTTP/1.1
为了解决HTTP/1.0存在的缺陷，HTTP/1.1于1999年诞生。相比较于HTTP/1.0来说，最主要的改进就是引入了持久连接。所谓的持久连接即TCP连接默认不关闭，可以被多个请求复用。
由于之前打一次电话只能说一件事儿，效率很低。后来人们提出一种想法，就是电话打完之后，先不直接挂断，而是持续一小段时间，这一小段时间内，如果还有事情沟通可以再次进行沟通。
客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。
HTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。

有了持久连接和管道，大大的提升了HTTP的效率。但是服务端还是顺序执行的，效率还有提升的空间。
HTTP/2
HTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新，主要基于 SPDY 协议。
HTTP/2 为了解决HTTP/1.1中仍然存在的效率问题，HTTP/2 采用了多路复用。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP/2进行了二进制分帧，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。
也就是说，老板可以同时下达多个命令，员工也可以收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。A请求的两部分响应在组合到一起发给老板。

而这个负责拆分、组装请求和二进制帧的一层就叫做二进制分帧层。
除此之外，还有一些其他的优化，比如做Header压缩、服务端推送等。
Header压缩就是压缩老板和员工之间的对话。
服务端推送就是员工事先把一些老板可能询问的事情提现发送到老板的手机（缓存）上。这样老板想要知道的时候就可以直接读取短信（缓存）了。
目前，主流的HTTP协议还是HTTP/1.1 和 HTTP/2。并且各大网站的HTTP/2的使用率也在逐年增加。",
POST和GET有哪些区别？各自应用场景？,"GET 用于获取资源，而 POST 用于传输实体主体。
GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。
因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。
安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。
GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
安全的方法除了 GET 之外还有：HEAD、OPTIONS。
不安全的方法除了 POST 之外还有 PUT、DELETE。
幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。
所有的安全方法也都是幂等的。
在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。
GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：
POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：
DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：
如果要对响应进行缓存，需要满足以下条件：
为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：

  XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。",
HTTP 哪些常用的状态码及使用场景？,"1xx：表示目前是协议的中间状态，还需要后续请求
2xx：表示请求成功
3xx：表示重定向状态，需要重新请求
4xx：表示请求报文错误
5xx：服务器端错误
101 切换请求协议，从 HTTP 切换到 WebSocket
200 请求成功，有响应体
301 永久重定向：会缓存
302 临时重定向：不会缓存
304 协商缓存命中
403 服务器禁止访问
404 资源未找到
400 请求错误
500 服务器端错误
503 服务器繁忙",
HTTP状态码301和302的区别，都有哪些用途？,"301重定向（301 Move Permanently），指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。301是HTTP协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的HTTP数据流中头信息（header）中包含状态码 301 ，表示该资源已经永久改变了位置。
301重定向是一种非常重要的”自动转向“技术，网址重定向最为可行的一种方法。
网页开发过程中，时常会遇到网站目录结构的调整，将页面转移到一个新地址；网页扩展名的改变，这些变化都会导致网页地址发生改变，此时用户收藏夹和搜索引擎数据库中的旧地址是一个错误的地址，访问之后会出现404页面，直接导致网站流量的损失。或者是我们需要多个域名跳转至同一个域名，例如本站主站点域名为 www.conimi.com ，而还有一个域名 www.nico.cc，由于对该域名设置了301重定向，当输入www.nico.cc 时，自动跳转至 www.conimi.com 。
有利于网站首选域的确定，对于同一资源页面多条路径的301重定向有助于URL权重的集中。例如 www.conimi.com和 conimi.com 是两个不同的域名，但是指向的内容完全相同，搜索引擎会对两个域名收录情况不同，这样导致网站权重和排名被分散；对conimi.com 做301重定向跳转至www.conimi.com 后，权重和排名集中到www.conimi.com，从而提升自然排名。
302重定向（302 Move Temporarily），指页面暂时性转移，表示资源或页面暂时转移到另一个位置，常被用作网址劫持，容易导致网站降权，严重时网站会被封掉，不推荐使用。
302重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。",
在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？,在 HTTP 中响应体的 Connection 字段指定为 keep-alive,
HTTP 如何实现长连接？在什么时候会超时？,"通过在头部（请求和响应头）设置 Connection: keep-alive，HTTP1.0协议支持，但是默认关闭，从HTTP1.1协议以后，连接默认都是长连接
1、HTTP 一般会有 httpd 守护进程，里面可以设置 keep-alive timeout，当 tcp 链接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间
2、TCP 的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置：当 TCP 链接之后，闲置了 tcp_keepalive_time，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 tcp_keepalive_probes，就会丢弃该链接。
（1）tcp_keepalive_intvl = 15
（2）tcp_keepalive_probes = 5
（3）tcp_keepalive_time = 1800
实际上 HTTP 没有长短链接，只有 TCP 有，TCP 长连接可以复用一个 TCP 链接来发起多次 HTTP 请求，这样可以减少资源消耗，比如一次请求 HTML，可能还需要请求后续的 JS/CSS/图片等",
TCP 如何保证有效传输及拥塞控制原理,"可靠体现在：有状态、可控制
所以上面能保证数据包的有效传输。
原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。
主要用三种方法：
对于拥塞控制来说，TCP 主要维护两个核心状态：

  在发送端使用拥塞窗口来控制发送窗口的大小。

然后采用一种比较保守的慢启动算法来慢慢适应这个网络，在开始传输的一段时间，发送端和接收端会首先通过三次握手建立连接，确定各自接收窗口大小，然后初始化双方的拥塞窗口，接着每经过一轮 RTT（收发时延），拥塞窗口大小翻倍，直到达到慢启动阈值。
然后开始进行拥塞避免，拥塞避免具体的做法就是之前每一轮 RTT，拥塞窗口翻倍，现在每一轮就加一个。
在 TCP 传输过程中，如果发生了丢包，接收端就会发送之前重复 ACK，比如 第 5 个包丢了，6、7 达到，然后接收端会为 5，6，7 都发送第四个包的 ACK，这个时候发送端受到了 3 个重复的 ACK，意识到丢包了，就会马上进行重传，而不用等到 RTO （超时重传的时间）
选择性重传：报文首部可选性中加入 SACK 属性，通过 left edge 和 right edge 标志那些包到了，然后重传没到的包
如果发送端收到了 3 个重复的 ACK，发现了丢包，觉得现在的网络状况已经进入拥塞状态了，那么就会进入快速恢复阶段：",
IP地址有哪些分类？,"A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。
B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。
C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。
D类地址(224~239)：以1110开头，保留位多播地址。
E类地址(240~255)：以1111开头，保留位今后使用",
GET请求中URL编码的意义,"我们知道，在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 避免歧义。看下面的例子，
针对“name1=value1&name2=value2”的例子，我们来谈一下数据从客户端到服务端的解析过程。首先，上述字符串在计算机中用ASCII吗表示为：
服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。
现在考虑这样一个问题，如果我们的参数值中就包含 = 或 & 这种特殊字符的时候该怎么办？比如，“name1=value1”，其中value1的值是“va&lu=e1”字符串，那么实际在传输过程中就会变成这样“name1=va&lu=e1”。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。
那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：“name1=va%26lu%3De1”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符",
什么是SQL 注入？举个例子？,"SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
1). SQL注入攻击的总体思路
　　(1). 寻找到SQL注入的位置
　　(2). 判断服务器类型和后台数据库类型
　　(3). 针对不同的服务器和数据库特点进行SQL注入攻击
2). SQL注入攻击实例
比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：
用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?
下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：
因此，当输入了上面的用户名和密码，上面的SQL语句变成：
分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个 -，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。
3). 应对方法
(1). 参数绑定
使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用 # 和$来获取参数值。
当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。
(2). 使用正则表达式过滤传入的参数",
谈一谈 XSS 攻击，举个例子？,"XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。
XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。
1). XSS攻击的危害
盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号
控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力
盗窃企业重要的具有商业价值的资料
非法转账
强制发送电子邮件
网站挂马
控制受害者机器向其它网站发起攻击
2). 原因解析
主要原因：过于信任客户端提交的数据！
解决办法：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。
进一步分析细节：客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮地展开攻击啦，因此我们绝不可以信任任何客户端提交的数据！！！
3). XSS 攻击分类
(1). 反射性XSS攻击 (非持久性XSS攻击)
漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS攻击包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)，例如，正常发送消息：
接收者将会接收信息并显示Hello,World；但是，非正常发送消息：
接收者接收消息显示的时候将会弹出警告窗口！
(2). 持久性XSS攻击 (留言板场景)
XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。
与非持久性XSS攻击相比，持久性XSS攻击危害性更大。从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。
例如，留言板表单中的表单域：
正常操作流程是：用户是提交相应留言信息 —— 将数据存储到数据库 —— 其他用户访问留言板，应用去数据并显示；而非正常操作流程是攻击者在value填写:
并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码。
4). 修复漏洞方针
漏洞产生的根本原因是 太相信用户提交的数据，对用户所提交的数据过滤不足所导致的，因此解决方案也应该从这个方面入手，具体方案包括：
将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了（如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击）；
表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。
对数据进行Html Encode 处理
过滤或移除特殊的Html标签，例如: < script >, < iframe > , < for <, > for>, ” for
过滤JavaScript 事件的标签，例如 “οnclick=”, “onfocus” 等等。
需要注意的是，在有些应用中是允许html标签出现的，甚至是javascript代码出现。因此，我们在过滤数据的时候需要仔细分析哪些数据是有特殊要求（例如输出需要html代码、javascript代码拼接、或者此表单直接允许使用等等），然后区别处理！",
讲一下网络五层模型，每一层的职责？,"天各一方的两台计算机是如何通信的呢？在成千上万的计算机中，为什么一台计算机能够准确着寻找到另外一台计算机，并且把数据发送给它呢？
可能很多人都听说过网络通信的 5 层模型，但是可能并不是很清楚为什么需要五层模型，五层模型负责的任务也有可能经常混淆。下面是网络通信的五层模型

说实话，五层模型的具体内容还是极其复杂的，不过今天这篇文章，我将用最简洁的模式，通过网络通信的五层模型来讲解一台计算机是如何找到另外一台计算机并且把数据发送给另一台计算机的，就算你没学过计算机网络，也能够听的懂。
一台计算机与另一台计算机要进行通信，第一件要做的事是什么？当然是要把这台计算机与另外的其他计算机连起来啊，这样，我们才能把数据传输过去。例如可以通过光纤啊，电缆啊，双绞线啊等介质把他们连接起来，然后才能进行通信。

也就是说，物理层负责把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号。
前面说了，物理层它只是单纯着负责把计算机连接起来，并且在计算机之间传输0，1这样的电信号。如果这些0，1组合的传送毫无规则的话，计算机是解读不了的。一大堆0，1谁知道是什么鬼啊。

因此，我们需要制定一套规则来进行0，1的传送。例如多少个电信号为一组啊，每一组信号应该如何标识才能让计算机读懂啊等等。
于是，有了以太网协议。
1. 以太网协议
以太网协议规定，一组电信号构成一个数据包，我们把这个数据包称之为帧。每一个桢由标头(Head)和数据(Data)两部分组成。

帧的大小一般为 64 – 1518 个字节。假如需要传送的数据很大的话，就分成多个桢来进行传送。
对于表头和数据这两个部分，他们存放的都是一些什么数据呢？我猜你眯着眼睛都能想到他们应该放什么数据。    毫无疑问，我们至少得知道这个桢是谁发送，发送给谁的等这些信息吧？所以标头部分主要是一些说明数据，例如发送者，接收者等信息。而数据部分则是这个数据包具体的，想给接守者的内容。
大家想一个问题，一个桢的长度是 64~1518 个字节，也就是说桢的长度不是固定的，那你觉得标头部分的字节长度是固定的吗？它当然是固定的啊，假如不是固定的，每个桢都是单独发的，那计算机怎么知道标头是几个字节，数据是几个字节呢。所以标头部分的字节是固定的，并且固定为18个字节。
把一台计算的的数据通过物理层和链路层发送给另一台计算机，究竟是谁发给谁的，计算机与计算机之间如何区分，，你总得给他们一个唯一的标识吧？
于是，MAC 地址出现了。
2. MAC 地址
连入网络的每一个计算机都会有网卡接口，每一个网卡都会有一个唯一的地址，这个地址就叫做 MAC 地址。计算机之间的数据传送，就是通过 MAC 地址来唯一寻找、传送的。

MAC地址 由 48 个二进制位所构成，在网卡生产时就被唯一标识了。
3. 广播与ARP协议
(1). 广播

如图，假如计算机 A 知道了计算机 B 的 MAC 地址，然后计算机 A 想要给计算机 B 传送数据，虽然计算机 A 知道了计算机 B 的 MAC 地址，可是它要怎么给它传送数据呢？计算机 A 不仅连着计算机 B，而且计算机 A 也还连着其他的计算机。    虽然计算机 A 知道计算机 B 的 MAC 地址，可是计算机 A 却不知道知道计算机 B 是分布在哪边路线上，为了解决这个问题，于是，有了广播的出现。
在同一个子网中，计算机 A 要向计算机 B 发送一个数据包，这个数据包会包含接收者的 MAC 地址。当发送时，计算机 A 是通过广播的方式发送的，这时同一个子网中的计算机 C, D 也会收到这个数据包的，然后收到这个数据包的计算机，会把数据包的 MAC 地址取出来，与自身的 MAC 地址对比，如果两者相同，则接受这个数据包，否则就丢弃这个数据包。这种发送方式我们称之为广播,就像我们平时在广场上通过广播的形式呼叫某个人一样，如果这个名字是你，你就理会一下，如果不是你，你就当作听不见。
(2). ARP 协议。
那么问题来了，计算机 A 是如何知道计算机 B 的 MAC 地址的呢？这个时候就得由 ARP 协议这个家伙来解决了，不过 ARP 协议会涉及到IP地址，我们下面才会扯到IP地址。因此我们先放着，就当作是有这么一个 ARP 协议，通过它我们可以知道子网中其他计算机的 MAC 地址。
上面我们有说到子网这个关键词，实际上我们所处的网络，是由无数个子网络构成的。广播的时候，也只有同一个子网里面的计算机能够收到。
假如没有子网这种划分的话，计算机 A 通过广播的方式发一个数据包给计算机 B , 其他所有计算机也都能收到这个数据包，然后进行对比再舍弃。世界上有那么多它计算机，每一台计算机都能收到其他所有计算机的数据包，那就不得了了。那还不得奔溃。  因此产生了子网这么一个东西。
那么问题来了，我们如何区分哪些 MAC 地址是属于同一个子网的呢？假如是同一个子网，那我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给网关，让网关进行转发。
为了解决这个问题，于是，有了 IP 协议。
1. IP协议
IP协议，它所定义的地址，我们称之为IP地址。IP协议有两种版本，一种是 IPv4,另一种是 IPv6。不过我们目前大多数用的还是 IPv4，我们现在也只讨论 IPv4 这个版本的协议。
这个 IP 地址由 32 位的二进制数组成，我们一般把它分成4段的十进制表示，地址范围为0.0.0.0~255.255.255.255。
每一台想要联网的计算机都会有一个IP地址。这个IP地址被分为两部分，前面一部分代表网络部分，后面一部分代表主机部分。并且网络部分和主机部分所占用的二进制位数是不固定的。
假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是处于同一个子网中。例如 192.168.43.1 和 192.168.43.2, 假如这两个 IP 地址的网络部分为 24 位，主机部分为 8 位。那么他们的网络部分都为 192.168.43，所以他们处于同一个子网中。
可是问题来了，你怎么知道网络部分是占几位，主机部分又是占几位呢？也就是说，单单从两台计算机的IP地址，我们是无法判断他们的是否处于同一个子网中的。
这就引申出了另一个关键词————子网掩码。子网掩码和IP地址一样也是 32 位二进制数，不过它的网络部分规定全部为 1，主机部分规定全部为 0.也就是说，假如上面那两个IP地址的网络部分为 24 位，主机部分为 8 位的话，那他们的子网掩码都为 11111111.11111111.11111111.00000000，即255.255.255.0。

那有了子网掩码，如何来判端IP地址是否处于同一个子网中呢。显然，知道了子网掩码，相当于我们知道了网络部分是几位，主机部分是几位。我们只需要把 IP 地址与它的子网掩码做与(and)运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表是同一个子网，否则不是同一个子网。
例如，192.168.43.1和192.168.43.2的子码掩码都为255.255.255.0，把IP与子码掩码相与，可以得到他们都为192.168.43.0，进而他们处于同一个子网中。
2. ARP协议
有了上面IP协议的知识，我们回来讲一下ARP协议。
有了两台计算机的IP地址与子网掩码，我们就可以判断出它们是否处于同一个子网之中了。
假如他们处于同一个子网之中，计算机A要给计算机B发送数据时。我们可以通过ARP协议来得到计算机B的MAC地址。
ARP协议也是通过广播的形式给同一个子网中的每台电脑发送一个数据包(当然，这个数据包会包含接收方的IP地址)。对方收到这个数据包之后，会取出IP地址与自身的对比，如果相同，则把自己的MAC地址回复给对方，否则就丢弃这个数据包。这样，计算机A就能知道计算机B的MAC地址了。

可能有人会问，知道了MAC地址之后，发送数据是通过广播的形式发送，询问对方的MAC地址也是通过广播的形式来发送，那其他计算机怎么知道你是要传送数据还是要询问MAC地址呢？其实在询问MAC地址的数据包中，在对方的MAC地址这一栏中，填的是一个特殊的MAC地址，其他计算机看到这个特殊的MAC地址之后，就能知道广播想干嘛了。
假如两台计算机的IP不是处于同一个子网之中，这个时候，我们就会把数据包发送给网关，然后让网关让我们进行转发传送
3. DNS服务器
这里再说一个问题，我们是如何知道对方计算机的IP地址的呢？这个问题可能有人会觉得很白痴，心想，当然是计算机的操作者来进行输入了。这没错，当我们想要访问某个网站的时候，我们可以输入IP来进行访问，但是我相信绝大多数人是输入一个网址域名的，例如访问百度是输入 www.baidu.com 这个域名。其实当我们输入这个域名时，会有一个叫做DNS服务器的家伙来帮我们解析这个域名，然后返回这个域名对应的IP给我们的。
因此，网络层的功能就是让我们在茫茫人海中，能够找到另一台计算机在哪里，是否属于同一个子网等。
通过物理层、数据链路层以及网络层的互相帮助，我们已经把数据成功从计算机A传送到计算机B了，可是，计算机B里面有各种各样的应用程序，计算机该如何知道这些数据是给谁的呢？
这个时候，端口(Port)这个家伙就上场了，也就是说，我们在从计算机A传数据给计算表B的时候，还得指定一个端口，以供特定的应用程序来接受处理。
也就是说，传输层的功能就是建立端口到端口的通信。相比网络层的功能是建立主机到主机的通信。
也就是说，只有有了IP和端口，我们才能进行准确着通信。这个时候可能有人会说，我输入IP地址的时候并没有指定一个端口啊。其实呢，对于有些传输协议，已经有设定了一些默认端口了。例如http的传输默认端口是80，这些端口信息也会包含在数据包里的。
传输层最常见的两大协议是 TCP 协议和 UDP 协议，其中 TCP 协议与 UDP 最大的不同就是 TCP 提供可靠的传输，而 UDP 提供的是不可靠传输。
终于说到应用层了，应用层这一层最接近我们用户了。
虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有html格式的，有mp4格式的，各种各样。你确定你能看的懂？
因此我们需要指定这些数据的格式规则，收到后才好解读渲染。例如我们最常见的 Http 数据包中，就会指定该数据包是 什么格式的文件了。
五层模型至此讲到这里。对于有些层讲的比较简洁，就随便概况了一下。因为如果我说的详细一点的话，篇幅肯定会特别特别长，我着已经是尽最大的努力以最简洁的方式来讲的了。如果你想详细去了解，可以去买计算机网络相应的资料，强烈推荐《计算机网络：自顶向下》这本书。希望我的讲解能让你对计算机之间数据的传输有个大概的了解。",
简单说下 HTTPS 和 HTTP 的区别,"Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：
1、端口不同：Http与Https使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
2、资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
3、开销：Https通信需要证书，而证书一般需要向认证机构购买；
　
Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。",
对称加密与非对称加密的区别,"对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。
而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。
由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。",
简单说下每一层对应的网络协议有哪些？,计算机五层网络体系中涉及的协议非常多，下面就常用的做了列举：,
ARP 协议的工作原理？,"网络层的 ARP 协议完成了 IP 地址与物理地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。
此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败",
TCP 的主要特点是什么？,"TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；
TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；
TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。",
UDP 的主要特点是什么？,"UDP 是无连接的；
UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
UDP 是面向报文的；
UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；
UDP 支持一对一、一对多、多对一和多对多的交互通信；
UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。",
TCP 和 UDP 分别对应的常见应用层协议有哪些？,"1. TCP 对应的应用层协议
FTP：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。
Telnet：它是一种用于远程登陆的协议，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。
SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。
POP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163 邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
HTTP：从 Web 服务器传输超文本到本地浏览器的传送协议。
2. UDP 对应的应用层协议
DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。
SNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。",
为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？,"1、为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。
2、 防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。",
保活计时器的作用？,"除时间等待计时器外，TCP 还有一个保活计时器（keepalive  timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。
服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。",
TCP 协议是如何保证可靠传输的？,"数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；
对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；
丢弃重复数据：对于重复数据，能够丢弃重复数据；
应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。",
谈谈你对停止等待协议的理解？,停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到。,
谈谈你对 ARQ 协议的理解？,"自动重传请求 ARQ 协议
停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。
连续 ARQ 协议
连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。",
谈谈你对滑动窗口的了解？,"TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。
TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。",
谈下你对流量控制的理解？,TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。,
谈下你对 TCP 拥塞控制的理解？使用了哪些算法？,"拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。
拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。
为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。
TCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。
慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。
拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。
在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。
没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。
有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。",
什么是粘包？,"在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。
从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。
基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。
接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。",
TCP 黏包是怎么产生的？,"采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。
接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）",
怎么解决拆包和粘包？,"分包机制一般有两个通用的解决方法：
在包头首都添加数据包的长度。
如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。
tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。",
forward 和 redirect 的区别？,"Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。
直接转发方式（Forward）：客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。
间接转发方式（Redirect）：实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。
直接转发就相当于：“A 找 B 借钱，B 说没有，B 去找 C 借，借到借不到都会把消息传递给 A”；
间接转发就相当于：”A 找 B 借钱，B 说没有，让 A 去找 C 借”。",
HTTP 方法有哪些？,"客户端发送的 请求报文 第一行为请求行，包含了方法字段。
HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；
POST：传输实体主体
PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。
PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。
OPTIONS：查询指定的 URL 支持的方法；
CONNECT：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
TRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。
9.Delete：删除文件,与 PUT 功能相反，并且同样不带验证机制。",
在浏览器中输入 URL 地址到显示主页的过程？,"DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；
TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；
发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；
服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。
连接结束。",
DNS 的解析过程？,"主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。
本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。",
谈谈你对域名缓存的了解？,"为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。
由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。
不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。",
谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？,"在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。
而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。
Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。",
HTTPS 的工作过程？,"1、 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；
2、 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；
3、客户端收到网站的证书之后要做下面的事情：
如果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；
用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。
4、服务器接收到客户端传送来的信息，要做下面的事情：
5、如果计算法 hash 值一致，握手成功。",
HTTP 和 HTTPS 的区别？,"开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；
资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；
端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；
安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TLS+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全",
HTTPS 的优缺点？,"优点：
HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性；
HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
缺点：
HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；
HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；
SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；
HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。",
什么是数字签名？,"为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。
详细的可以看这篇文章：什么是数字签名？
什么是数字签名？",
什么是数字证书？,对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。,
计算机网络,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里：阅读指南（必看）
阅读指南（必看）",
Cookie 和 Session 有什么区别？,"1、由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车。
当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。
这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。
2、思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。
有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
3、Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。
所以，总结一下：
Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。",
OSI 的七层模型分别是？各自的功能是什么？,"帅地注：这道题考的太多了，很多人估计都是直接背的模型，我觉得这样是无法加分的，对于这道题，大家直接本系列的第一篇文章，看完你面试完全可以按照我文章说的回答。
当然，我这里也给你简洁版吧，你也不需要说的特别全，简单说一下+举例子就行了，举例子就是最好的证明：
物理层：负责把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号，比如通过一些电缆线传输比特流。
链路层：链路层涉及到的协议比较多，比如 Mac 地址啊，ARP 等，这一层主要就是负责数据的通信，使各节点之间可以通信，比如通过 MAC 地址唯一识别不同的节点，通过以太网协议定义数据包等。
网络层：网络层负责把一个数据从一个网络传递到另外一个网络，最大的功能就是进行路由决策，比如通过 IP，子网等概念，使数据更好着在不同的局域网中传递。
传输层：传输层的功能就是建立端口到端口的通信，刚才说的网络层的功能则是建立主机到主机的通信，比如通过网络层我们可以把信息从 A 主机传递到 B 主机，但是 B 主机有多个程序，我们具体要发给哪个程序，则是靠传输层的协议来识别，常见协议有 UDP 和 TCP。
应用层：虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有html格式的，有mp4格式的，各种各样，我们用户也看不懂，
因此我们需要指定这些数据的格式规则，收到后才好解读渲染。例如我们最常见的 Http 数据包中，就会指定该数据包是 什么格式的文件了。
当然，你可以说的更详细，只是想我这样差不多了，之后就等着面试官是否要继续提问吧。",
UDP 如何实现可靠传输？,"UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。
传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。
详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。
目前有如下开源程序利用udp实现了可靠的数据传输。分别为*RUDP、RTP、UDT*。
RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。
RTP为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。
应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。
RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。
基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。
顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。",
ICMP 有哪些应用？,"ICMP 主要有两个应用，一个是 Ping，一个是 Traceroute。
1. Ping
Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。
Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。
2. Traceroute
Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。
Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。",
如何编程解决华容道问题？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他就去一家外企面试了。
【面试前】
面试前，小史就收到了中英文的面试邀请。

去外企面试，最好要能够和面试官英语对话。小史除了复习算法之外，赶紧练起了口语。



【面试现场】



面试官给了小史一个问题。（题目已翻译成中文，请自行脑补英文现场）
题目：我有1到8八个数字，放在一个3×3的九宫格里面，那么会留下一个空格。

空格可以和上下左右的数字进行交换，你可以认为空格在移动。如果移动成

则游戏胜利。
你需要完成以下2件事情：
1、给出数据结构来描述这个过程。
2、给你一个初始状态，告诉我能不能胜利，并给出如何移动才能胜利。
这有点像咱们中国的华容道游戏。





小史把他能想到的都写了下来。






【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。



【迷宫问题】






小史：每个点都可以按照右下左上的方向来进行尝试，如果是墙壁，就换一个方向，如果可以走，就往前走到下一点，然后再接着尝试。直到到达终点为止。






吕老师随手又画了一个迷宫。









吕老师：小史，这块并不是往左走，而是回退，退回到上一步。如果我们正在往前搜索，当然不能走回头路。但是当前面没有路的时候，我们就需要返回来，找到之前有可能出现岔路口的地方，再去下一个方向进行搜索。



【华容道问题】







小史：吕老师，我明白了，空格在华容道中移动，就好像我在迷宫里走动一样，每次到一个新的状态，就有几个方向可以搜索，如果是之前碰到过的状态，那就不搜索。





【递归实现回溯】

小史：“回溯”的过程有点像栈的操作。往前走一步就像是入栈，到了死胡同，要往回退，就像是出栈。

吕老师：这个过程确实是栈的过程，但是直接用栈的话，对于你刚刚接触搜索算法，可能编码比较难。其实你可以用递归来实现这个搜索过程。










小史：我在走迷宫的时候，每走一步，就把这一步是往哪走的记录下来，但是碰到了死胡同，往回退的时候，我又把之前记录的步骤最后一步去掉。这样一来，达到终点的时候，我记下来的步骤就是一条从起点到终点的路径了。


小史：记录移动路径，其实就是在真正搜索之前，把方向记录下来，而搜索如果要返回了，则说明该次搜索已经结束，没有结果，应该把该记录去除。





【小史的努力】
吃完烤串，喝完小酒，小史和吕老师休闲地走在回学校的路上。


吕老师笑而不语。
回到宿舍，小史就打开了电脑，手在键盘上飞快地敲了起来。
理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
几个测试用例下来，小史眉头一皱，发现事情并不简单。

小史经过缜密的分析，找到了原因。

我可以判断一下，如果某条路走的步数超过100步，就不再走了，赶紧回退。
小史在search函数中增加了moveArr.size()<100的判断，得到了最终结果。

【深搜和广搜】
第二天，小史得意洋洋地拿着自己的代码去找吕老师秀起来。



小史：现在的算法，没办法保证得到的解法就是最优解，并且它很容易进入复杂的死胡同出不来，有点像一个死钻牛角尖的人。



吕老师：深度优先搜索，会在一个方向一直搜下去，直到这条路走不通，才会考虑第二个方向。

吕老师：广度优先搜索，是先搜索每一个可行方向的第一步，然后再接着搜索每一个可行方向的第二步。以此类推。




小史：这个算法似乎没有“回溯”的必要了，没办法再用递归了吧？而且分头搜索这个方式应该怎么实现呢？

吕老师：你可以将要搜索的初始状态加到一个队列里，然后每次从队列中取出一个状态，往可以前进的方向前进一步，然后再将该状态放到队列。利用队列先进先出的特点，就可以实现广搜的效果。







小史：每一步都记录上一步的状态和这次的方向。这样在达到最终胜利状态的时候，可以找到这个状态的上一步。而上一步又可以找到上上步，这不就是链表么？




理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
写完代码，小史赶紧运行看下最终结果：



一个问题一顿饭，吕老师不亏的。
【饭桌上的闲聊】








PS：这次这篇花费了两周时间以及小史两顿饭钱。如果你看到了这里，并且有所收获的话，可以动动手指转发一下哦，小史和吕老师都会感谢你。
面试现场",
面试现场简介（必读）,"大家好，我是帅地。
面试现场这个专题，重在开拓你的思维，帅地向你保证，每一道题看完，都能让你有所收获，每一篇文章要嘛是帅地自己写的，要嘛是通过别人授权获取的，授权获取的文章，质量绝对也是过关的。
面试现场部分文章来自于「互联网侦察」这个微信公众号，感谢号主的授权。
无论你是 想面试，还是想学习一些算法的思维，那么面试现场的文章，都值得你去仔细阅读。
帅地的愿景就是，把该文章的教程，打造成全网质量最高的编程学习网站，所以会尽最大努力去保证每篇文章的质量，也欢迎你提出意见。
1. 如何判断一个数是否在40亿个整数中？
1. 如何判断一个数是否在40亿个整数中？
2. 如何实现可以获取最小值的栈？
2. 如何实现可以获取最小值的栈？
3. 记一次 shopee 面试：最小栈的最优解
3. 记一次 shopee 面试：最小栈的最优解
4. 为什么要分稳定排序和非稳定排序？
4. 为什么要分稳定排序和非稳定排序？
5. 如何编程解决华容道问题？
5. 如何编程解决华容道问题？
6. 如何找到字符串中的最长回文子串？
6. 如何找到字符串中的最长回文子串？
7. 如何在500w个单词中统计特定前缀的单词有多少个?
7. 如何在500w个单词中统计特定前缀的单词有多少个?
8. 如何在10亿数中找出前1000大的数？
8. 如何在10亿数中找出前1000大的数？
9. 如何编程获得最多的年终红包奖？
9. 如何编程获得最多的年终红包奖？
10. 如何编程解决朋友圈个数问题？
10. 如何编程解决朋友圈个数问题？
11. 如何设计可自学习的五子棋AI？
11. 如何设计可自学习的五子棋AI？
12. 为什么MySQL数据库要用B+树存储索引？
12. 为什么MySQL数据库要用B+树存储索引？
13. 记一道字节跳动面试：变形的链表反转
13. 记一道字节跳动面试：变形的链表反转
14. 记一次手撕算法面试：字节跳动的面试官把我四连击了
14. 记一次手撕算法面试：字节跳动的面试官把我四连击了
15. 记一次阿里笔试：一行代码解决约瑟夫环问题的
15. 记一次阿里笔试：一行代码解决约瑟夫环问题的
16. 记一次阿里面试：面试挂在了 LRU 缓存算法设计上
16. 记一次阿里面试：面试挂在了 LRU 缓存算法设计上
17. 记一次网易笔试：前缀和的应用
17. 记一次网易笔试：前缀和的应用
18. 游戏中的敏感词过滤是如何实现的？
18. 游戏中的敏感词过滤是如何实现的？
19. 如何只用2GB内存从20/40/80亿个整数中找到出现次数最多的数
19. 如何只用2GB内存从20/40/80亿个整数中找到出现次数最多的数
面试现场",
每周打卡做的比较好的成员示例,"我说过，我弄这个计划，就是看看你们的学习速度，以及你们掌握的如何，我会根据你们的情况，给你们提供一些学习的东西，比如你遇到某个问题不大懂，写在计划里，我看到了，可能可以给你一些指点。
有些人同一起点，但是几个月后，这份计划将会看到你这几个月，究竟学了什么
而且我觉得，这种每周/每日记录，会成为一种习惯，哪天自己没学习 会怪怪滴，这可以自发监督自己学习。
反正最重要的就是，让我知道你们的学习状态，当然，还有另外一种作用，就是学员之间，互相鼓励。
这里我展示几个做的比较好的，或许你们可以参考一下哦，写的时候可以写一写感悟之类的，另外就是，很多人差不多同一届的，也可以交流交流
PS：前面编号不准确的话，因为有些人没打卡被移除，编号会发生变化
2. 2023届_xhyang
2. 2023届_xhyang
4. 2023届——Kobe Bryant
4. 2023届——Kobe Bryant
9. 23届-6
9. 23届-6
12. 22届_just wait
12. 22届_just wait
13. 2023届_心有萌虎
13. 2023届_心有萌虎
18. 2023届_wh
18. 2023届_wh
29. 2023届_无尽蔚蓝
29. 2023届_无尽蔚蓝
33. 2023届_孤独时代的罗永浩
33. 2023届_孤独时代的罗永浩
12. 2024届_忆霁昕
12. 2024届_忆霁昕
14. 24届_Spruce.Lau
14. 24届_Spruce.Lau
18. 25届_Lyy 卍4678卍
18. 25届_Lyy 卍4678卍
20. 2025届_秊
20. 2025届_秊
22. 2025届_Qiang
22. 2025届_Qiang
23. 2024届_幸福来敲门
23. 2024届_幸福来敲门
44. 2025届_星月之弦
44. 2025届_星月之弦
49. 24届_Tolkien
49. 24届_Tolkien",
Go面试题分类阅读指南(附答案),"大家好，我是帅地。
由于 Java 内容较多，为了方便大家复习，这里采取了分类阅读的方式
Go基础面试题阅读指南（必看）
Go基础面试题阅读指南（必看）
Go并发面试题阅读指南（必看）
Go并发面试题阅读指南（必看）
 Go Runtime面试题阅读指南（必看）
 Go Runtime面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
 Java面试题面试题阅读指南（必看）
 Java面试题面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
Python面试题分类阅读指南(附答案)
Python面试题分类阅读指南(附答案)
前端面试题分类阅读指南(附答案)
前端面试题分类阅读指南(附答案)",
MySQL 面试题阅读指南,"大家好，我是帅地。
对 MySQL 需要掌握哪些知识不清楚的，可以先看我写的学习路线：我的 MySQL 学习之路
我的 MySQL 学习之路
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 请说下你对 MySQL 架构的了解？
1. 请说下你对 MySQL 架构的了解？
2. 一条 SQL 语句在数据库框架中的执行流程？
2. 一条 SQL 语句在数据库框架中的执行流程？
3. 数据库的三范式是什么？
3. 数据库的三范式是什么？
4. char 和 varchar 的区别？
4. char 和 varchar 的区别？
5. varchar(10) 和 varchar(20) 的区别？
5. varchar(10) 和 varchar(20) 的区别？
6. 谈谈你对索引的理解？
6. 谈谈你对索引的理解？
7. 索引的底层使用的是什么数据结构？
7. 索引的底层使用的是什么数据结构？
8. 谈谈你对 B+ 树的理解？
8. 谈谈你对 B+ 树的理解？
9. 为什么 InnoDB 存储引擎选用 B+ 树而不是 B 树呢？
9. 为什么 InnoDB 存储引擎选用 B+ 树而不是 B 树呢？
10. 谈谈你对聚簇索引的理解？
10. 谈谈你对聚簇索引的理解？
11. 谈谈你对哈希索引的理解？
11. 谈谈你对哈希索引的理解？
12. 谈谈你对覆盖索引的认识？
12. 谈谈你对覆盖索引的认识？
13. 索引的分类？
13. 索引的分类？
14. 谈谈你对最左前缀原则的理解？
14. 谈谈你对最左前缀原则的理解？
15. 怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?
15. 怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?
16. 什么情况下索引会失效？即查询不走索引？
16. 什么情况下索引会失效？即查询不走索引？
17. 查询性能的优化方法？
17. 查询性能的优化方法？
18. InnoDB 和 MyISAM 的比较？
18. InnoDB 和 MyISAM 的比较？
19. 谈谈你对水平切分和垂直切分的理解？
19. 谈谈你对水平切分和垂直切分的理解？
20. 主从复制中涉及到哪三个线程？
20. 主从复制中涉及到哪三个线程？
21. 主从同步的延迟原因及解决办法？
21. 主从同步的延迟原因及解决办法？
22. 谈谈你对数据库读写分离的理解？
22. 谈谈你对数据库读写分离的理解？
23. 请你描述下事务的特性？
23. 请你描述下事务的特性？
24. 谈谈你对事务隔离级别的理解？
24. 谈谈你对事务隔离级别的理解？
25. 解释下什么叫脏读、不可重复读和幻读？
25. 解释下什么叫脏读、不可重复读和幻读？
26. MySQL 默认的隔离级别是什么？
26. MySQL 默认的隔离级别是什么？
27. 谈谈你对MVCC 的了解？
27. 谈谈你对MVCC 的了解？
28. 说一下 MySQL 的行锁和表锁？
28. 说一下 MySQL 的行锁和表锁？
29. InnoDB 存储引擎的锁的算法有哪些？
29. InnoDB 存储引擎的锁的算法有哪些？
30. MySQL 问题排查都有哪些手段？
30. MySQL 问题排查都有哪些手段？
31. MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？
31. MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？
32. MySQL的redo log，undo log，bin log都是干什么的
32. MySQL的redo log，undo log，bin log都是干什么的
33. SQL 与 MySQL 有什么区别
33. SQL 与 MySQL 有什么区别
34. 添加索引的原则
34. 添加索引的原则
35. 有哪些事务状态
35. 有哪些事务状态
36. 什么是死锁？如何解决死锁？
36. 什么是死锁？如何解决死锁？
37. 什么是乐观锁和悲观锁？如何实现？
37. 什么是乐观锁和悲观锁？如何实现？
38. 什么是超键？什么是主键？
38. 什么是超键？什么是主键？
39. UNION 与 UNION ALL 的区别
39. UNION 与 UNION ALL 的区别
40. DROP、DELETE 与 TRUNCATE 的区别
40. DROP、DELETE 与 TRUNCATE 的区别
41. 为什么要分库分表
41. 为什么要分库分表
42. 分库分表存在哪些问题
42. 分库分表存在哪些问题
43. MySQL 读写分离的实现方案
43. MySQL 读写分离的实现方案
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
 Java面试题面试题阅读指南（必看）
 Java面试题面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
面试题汇总",
SSM框架面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 使用 Spring 框架的好处是什么？
1. 使用 Spring 框架的好处是什么？
2. 解释下什么是 AOP？
2. 解释下什么是 AOP？
3. AOP 的代理有哪几种方式？
3. AOP 的代理有哪几种方式？
4. 怎么实现 JDK 动态代理？
4. 怎么实现 JDK 动态代理？
5. AOP 的基本概念：切面、连接点、切入点等？
5. AOP 的基本概念：切面、连接点、切入点等？
6. 通知类型（Advice）型（Advice）有哪些？
6. 通知类型（Advice）型（Advice）有哪些？
7. 谈谈你对 IOC 的理解？
7. 谈谈你对 IOC 的理解？
8. Bean 的生命周期？
8. Bean 的生命周期？
9. Bean 的作用域?
9. Bean 的作用域?
10. Spring 中的单例 Bean 的线程安全问题了解吗？
10. Spring 中的单例 Bean 的线程安全问题了解吗？
11. 谈谈你对 Spring 中的事物的理解？
11. 谈谈你对 Spring 中的事物的理解？
12. Spring 中的事务隔离级别？
12. Spring 中的事务隔离级别？
13. Spring 中的事物传播行为？
13. Spring 中的事物传播行为？
14. Spring 常用的注入方式有哪些？
14. Spring 常用的注入方式有哪些？
15. Spring 框架中用到了哪些设计模式？
15. Spring 框架中用到了哪些设计模式？
16. ApplicationContext 通常的实现有哪些?
16. ApplicationContext 通常的实现有哪些?
17. 谈谈你对 MVC 模式的理解？
17. 谈谈你对 MVC 模式的理解？
18. SpringMVC 的工作原理/执行流程？
18. SpringMVC 的工作原理/执行流程？
19. SpringMVC 的核心组件有哪些？
19. SpringMVC 的核心组件有哪些？
20. SpringMVC 常用的注解有哪些？
20. SpringMVC 常用的注解有哪些？
21. @RequestMapping 的作用是什么？
21. @RequestMapping 的作用是什么？
22. 如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？
22. 如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？
23. SpringMVC 的控制器是不是单例模式，如果是会有什么问题，怎么解决？
23. SpringMVC 的控制器是不是单例模式，如果是会有什么问题，怎么解决？
24. SpringMVC 怎么样设定重定向和转发的？
24. SpringMVC 怎么样设定重定向和转发的？
25. SpringMVC 里面拦截器是怎么写的？
25. SpringMVC 里面拦截器是怎么写的？
26. SpringMVC 和 Struts2 的区别有哪些?
26. SpringMVC 和 Struts2 的区别有哪些?
27. 谈谈你对 MyBatis 的理解？
27. 谈谈你对 MyBatis 的理解？
28. MyBaits 的优缺点有哪些？
28. MyBaits 的优缺点有哪些？
29. MyBatis 与 Hibernate 有哪些不同？
29. MyBatis 与 Hibernate 有哪些不同？
30. MyBatis 中 #{} 和 ${}的区别是什么？
30. MyBatis 中 #{} 和 ${}的区别是什么？
31. MyBatis 是如何进行分页的？分页插件的原理是什么？
31. MyBatis 是如何进行分页的？分页插件的原理是什么？
32. MyBatis 有几种分页方式？
32. MyBatis 有几种分页方式？
33. MyBatis 逻辑分页和物理分页的区别是什么？
33. MyBatis 逻辑分页和物理分页的区别是什么？
34. MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？
34. MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？
35. 说一下 MyBatis 的一级缓存和二级缓存？
35. 说一下 MyBatis 的一级缓存和二级缓存？
36. Mybatis 有哪些执行器（Executor）？
36. Mybatis 有哪些执行器（Executor）？
37. MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL的执行原理不？
37. MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL的执行原理不？
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
面试题汇总",
消息队列和Zookeeper面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 消息队列的基本作用？
1. 消息队列的基本作用？
2. 消息队列的优缺点有哪些？
2. 消息队列的优缺点有哪些？
3. 如何保证消息队列的高可用？
3. 如何保证消息队列的高可用？
4. 如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？
4. 如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？
5. 如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？
5. 如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？
6. 如何保证消息的顺序性？
6. 如何保证消息的顺序性？
7. 大量消息在 MQ 里长时间积压，该如何解决？
7. 大量消息在 MQ 里长时间积压，该如何解决？
8. MQ 中的消息过期失效了怎么办？
8. MQ 中的消息过期失效了怎么办？
9. RabbitMQ 有哪些重要的角色？
9. RabbitMQ 有哪些重要的角色？
10. RabbitMQ 有哪些重要的组件？
10. RabbitMQ 有哪些重要的组件？
11. RabbitMQ 有几种广播类型？
11. RabbitMQ 有几种广播类型？
12. Kafka 可以脱离 zookeeper 单独使用吗？为什么？
12. Kafka 可以脱离 zookeeper 单独使用吗？为什么？
13. Kafka 有几种数据保留的策略？
13. Kafka 有几种数据保留的策略？
14. Kafka 的分区策略有哪些？
14. Kafka 的分区策略有哪些？
15. 谈下你对 Zookeeper 的认识？
15. 谈下你对 Zookeeper 的认识？
16. Zookeeper 都有哪些功能？
16. Zookeeper 都有哪些功能？
17. 谈下你对 ZAB 协议的了解？
17. 谈下你对 ZAB 协议的了解？
18. Zookeeper 怎么保证主从节点的状态同步？
18. Zookeeper 怎么保证主从节点的状态同步？
19. Zookeeper 有几种部署模式？
19. Zookeeper 有几种部署模式？
20. 说一下 Zookeeper 的通知机制？
20. 说一下 Zookeeper 的通知机制？
21. 集群中为什么要有主节点？
21. 集群中为什么要有主节点？
22. 集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？
22. 集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？
23. 说一下两阶段提交和三阶段提交的过程？分别有什么问题？
23. 说一下两阶段提交和三阶段提交的过程？分别有什么问题？
24. Zookeeper 宕机如何处理？
24. Zookeeper 宕机如何处理？
25. 说下四种类型的数据节点 Znode？
25. 说下四种类型的数据节点 Znode？
26. Zookeeper 和 Dubbo 的关系？
26. Zookeeper 和 Dubbo 的关系？
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
面试题汇总",
面试题必知必会阅读指南,"大家好，我是帅地。
为了方便大家按需阅读，帅地花了很大的功夫，给大家提供了三种阅读方式，大家可以体验一下，然后按需选择。
注意：PC 端阅读哈，手机端暂时没有这种功能，推荐 PC 端阅读。
可能大部分面试题你都知道的了，少部分不知道想要查漏补缺的，可以阅读这种方式，入口就从网站主页进去，然后在「搞定面试」那里，点击直达
点击直达
这种的话，适合大部分面试题都想复习一篇的人，例如 Redis 的几十道面试题写在一篇文章里，点击直达
点击直达
PDF 目录啥的，都整理的明明白白的了，大家想要的可以在帅地的公众号「帅地玩编程」后台回复「010」，即可获取。
面试题的答案，部分来自于网上，部分来自于帅地，所以呢，不保证所有面试题的答案都是 100% 正确的，如果有问题，大家也可以在网站那里进行纠正，帅地会及时更新。
面试题汇总",
