问题,回答,所属分类
Java 中的 IO 流的分类？说出几个你熟悉的实现类？,"按功能来分：输入流（input）、输出流（output）。
按类型来分：字节流 和 字符流。
字节流：InputStream/OutputStream 是字节流的抽象类，这两个抽象类又派生了若干子类，不同的子类分别处理不同的操作类型。具体子类如下所示：

字符流：Reader/Writer 是字符的抽象类，这两个抽象类也派生了若干子类，不同的子类分别处理不同的操作类型。

JavaIO",
字节流和字符流有什么区别？,"字节流按 8 位传输，以字节为单位输入输出数据，字符流按 16 位传输，以字符为单位输入输出数据。
但是不管文件读写还是网络发送接收，信息的最小存储单元都是字节。
JavaIO",
BIO、NIO、AIO 有什么区别？,"BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。NIO  是一种同步非阻塞的 I/O 模型，在 Java1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。NIO 提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。
AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。
JavaIO",
Java IO,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里： Java基础面试题阅读指南
 Java基础面试题阅读指南
JavaIO",
JavaScript 中如何进行隐式类型转换,"首先要介绍ToPrimitive方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：
type的值为number或者string。
（1）当type为number时规则如下：
（2）当type为string时规则如下：
可以看出两者的主要区别在于调用toString和valueOf的先后顺序。默认情况下：
总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：
而 JavaScript 中的隐式类型转换主要发生在+、-、*、/以及= =、>、<这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用ToPrimitive转换成基本类型，再进行操作。
以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被ToPrimitive转换成基本类型，所以最终还是要应用基本类型转换规则）：
+操作符的两边有至少一个string类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。
NaN也是一个数字
操作符两边的值都尽量转成number：
如果两边都是字符串，则比较字母表顺序：
其他情况下，转换为数字再比较：
以上说的是基本类型的隐式转换，而对象会被ToPrimitive转换为基本类型再进行转换：
其对比过程如下：
又比如：
运算过程如下：

ㅤ普通",
JavaScript基础面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
是帅地。
1. JavaScript有哪些数据类型，它们的区别
1. JavaScript有哪些数据类型，它们的区别
2. 数据类型检测的方式有哪些
2. 数据类型检测的方式有哪些
3. 判断数组的方式有哪些
3. 判断数组的方式有哪些
4. null和undefined区别
4. null和undefined区别
5. typeof null 的结果是什么，为什么
5. typeof null 的结果是什么，为什么
6. intanceof 操作符的实现原理及实现
6. intanceof 操作符的实现原理及实现
7. 为什么0.1+0.2 !  0.3，如何让其相等
7. 为什么0.1+0.2 !  0.3，如何让其相等
8. 如何获取安全的 undefined 值
8. 如何获取安全的 undefined 值
9. typeof NaN 的结果是什么
9. typeof NaN 的结果是什么
10. isNaN 和 Number.isNaN 函数的区别
10. isNaN 和 Number.isNaN 函数的区别
11.  操作符的强制类型转换规则
11.  操作符的强制类型转换规则
12. 其他值到字符串的转换规则
12. 其他值到字符串的转换规则
13. 其他值到数字值的转换规则
13. 其他值到数字值的转换规则
14. 其他值到布尔类型的值的转换规则
14. 其他值到布尔类型的值的转换规则
15. || 和 && 操作符的返回值
15. || 和 && 操作符的返回值
16. Object.is() 与比较操作符 ===、==的区别
16. Object.is() 与比较操作符 ===、==的区别
17. 什么是 JavaScript 中的包装类型
17. 什么是 JavaScript 中的包装类型
18. JavaScript 中如何进行隐式类型转换
18. JavaScript 中如何进行隐式类型转换
19. + 操作符什么时候用于字符串的拼接
19. + 操作符什么时候用于字符串的拼接
20. 为什么会有BigInt的提案
20. 为什么会有BigInt的提案
21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别
21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别
22. let、const、var的区别
22. let、const、var的区别
23. const对象的属性可以修改吗
23. const对象的属性可以修改吗
24. 如果new一个箭头函数的会怎么样
24. 如果new一个箭头函数的会怎么样
25. 箭头函数与普通函数的区别
25. 箭头函数与普通函数的区别
26. 箭头函数的this指向哪里
26. 箭头函数的this指向哪里
27. 扩展运算符的作用及使用场景
27. 扩展运算符的作用及使用场景
28. Proxy 可以实现什么功能
28. Proxy 可以实现什么功能
29. 对对象与数组的解构的理解
29. 对对象与数组的解构的理解
30. 对 rest 参数的理解
30. 对 rest 参数的理解
31. ES6中模板语法与字符串处理
31. ES6中模板语法与字符串处理
32. new操作符的实现原理
32. new操作符的实现原理
33. map和Object的区别
33. map和Object的区别
34. map和weakMap的区别
34. map和weakMap的区别
35. JavaScript有哪些内置对象
35. JavaScript有哪些内置对象
36. 常用的正则表达式有哪些
36. 常用的正则表达式有哪些
37. 对JSON的理解
37. 对JSON的理解
38. JavaScript脚本延迟加载的方式有哪些
38. JavaScript脚本延迟加载的方式有哪些
39. JavaScript 类数组对象的定义
39. JavaScript 类数组对象的定义
40. 数组有哪些原生方法
40. 数组有哪些原生方法
41. Unicode、UTF-8、UTF-16、UTF-32的区别
41. Unicode、UTF-8、UTF-16、UTF-32的区别
42. 常见的位运算符有哪些 其计算规则是什么
42. 常见的位运算符有哪些 其计算规则是什么
43. 为什么函数的 arguments 参数是类数组而不是数组 如何遍历类数组
43. 为什么函数的 arguments 参数是类数组而不是数组 如何遍历类数组
44. 什么是 DOM 和 BOM
44. 什么是 DOM 和 BOM
45. 对类数组对象的理解，如何转化为数组
45. 对类数组对象的理解，如何转化为数组
46. escape、encodeURI、encodeURIComponent 的区别
46. escape、encodeURI、encodeURIComponent 的区别
47. 对AJAX的理解，实现一个AJAX请求
47. 对AJAX的理解，实现一个AJAX请求
48. JavaScript为什么要进行变量提升，它导致了什么问题
48. JavaScript为什么要进行变量提升，它导致了什么问题
49. 什么是尾调用，使用尾调用有什么好处
49. 什么是尾调用，使用尾调用有什么好处
50. ES6模块与CommonJS模块有什么异同
50. ES6模块与CommonJS模块有什么异同
51. 常见的DOM操作有哪些
51. 常见的DOM操作有哪些
52. use strict是什么意思 使用它区别是什么
52. use strict是什么意思 使用它区别是什么
53. 如何判断一个对象是否属于某个类
53. 如何判断一个对象是否属于某个类
54. 强类型语言和弱类型语言的区别
54. 强类型语言和弱类型语言的区别
55. 解释性语言和编译型语言的区别
55. 解释性语言和编译型语言的区别
56. for…in和for…of的区别
56. for…in和for…of的区别
57. 如何使用for…of遍历对象
57. 如何使用for…of遍历对象
58. ajax、axios、fetch的区别
58. ajax、axios、fetch的区别
59. 数组的遍历方法有哪些
59. 数组的遍历方法有哪些
60. forEach和map方法有什么区别
60. forEach和map方法有什么区别
61. 对原型、原型链的理解
61. 对原型、原型链的理解
62. 原型修改、重写
62. 原型修改、重写
63. 原型链指向
63. 原型链指向
64. 如何获得对象非原型链上的属性
64. 如何获得对象非原型链上的属性
65. 对闭包的理解
65. 对闭包的理解
66. 对作用域、作用域链的理解
66. 对作用域、作用域链的理解
67. 对this对象的理解
67. 对this对象的理解
68. call() 和 apply() 的区别
68. call() 和 apply() 的区别
69. 实现call、apply 及 bind 函数
69. 实现call、apply 及 bind 函数
70. 异步编程的实现方式
70. 异步编程的实现方式
71. Promise解决了什么问题
71. Promise解决了什么问题
72. Promise.all和Promise.race的区别的使用场景
72. Promise.all和Promise.race的区别的使用场景
73. 对象创建的方式有哪些
73. 对象创建的方式有哪些
74. 对象继承的方式有哪些
74. 对象继承的方式有哪些
75. 列出JS基本和非基本数据类型之间的一些区别
75. 列出JS基本和非基本数据类型之间的一些区别
76. module.exports 和 exports 之间有什么区别
76. module.exports 和 exports 之间有什么区别
77. js 执行机制、事件循环
77. js 执行机制、事件循环
78. promise.all
78. promise.all
79. 介绍一下rAF(requestAnimationFrame)
79. 介绍一下rAF(requestAnimationFrame)
80. javascript 的垃圾回收机制讲一下
80. javascript 的垃圾回收机制讲一下
81. 两种方式实现字符串反转函数
81. 两种方式实现字符串反转函数
82. 事件委托代理
82. 事件委托代理
83. 什么是跨域 跨域请求资源的方法有哪些
83. 什么是跨域 跨域请求资源的方法有哪些
84. 开发过程中遇到的内存泄露情况，如何解决的
84. 开发过程中遇到的内存泄露情况，如何解决的
JavaScrip面试题

ㅤ普通",
JavaScript有哪些数据类型，它们的区别,"JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。
其中 Symbol 和 BigInt 是ES6 中新增的数据类型：
这些数据可以分为原始数据类型和引用数据类型：
两种类型的区别在于存储位置的不同：
堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：
在操作系统中，内存被分为栈区和堆区：
JavaScrip面试题

ㅤ普通",
数据类型检测的方式有哪些,"（1）typeof
其中数组、对象、null都会被判断为object，其他判断都正确。
（2）instanceof
instanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。
可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。
（3） constructor
constructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：
（4）Object.prototype.toString.call()
Object.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型：
同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？
这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。
JavaScrip面试题

ㅤ普通",
判断数组的方式有哪些,"JavaScrip面试题

ㅤ普通",
null和undefined区别,"首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。
undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。
undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。
当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
JavaScrip面试题

ㅤ普通",
typeof null 的结果是什么，为什么,"typeof null 的结果是Object。
在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：
如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。
有两种特殊数据类型：
那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。
JavaScrip面试题

ㅤ普通",
intanceof 操作符的实现原理及实现,"instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
JavaScrip面试题

ㅤ普通",
为什么0.1+0.2 ! == 0.3，如何让其相等,"在开发过程中遇到类似这样的问题：
这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：
toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？
计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？
一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。
根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。
下面看一下双精度数是如何保存的：

对于0.1，它的二进制为：
转为科学计数法（科学计数法的结果就是浮点数）：
可以看出0.1的符号位为0，指数位为-4，小数位为：
那么问题又来了，指数位是负数，该如何保存呢？
IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定双精度数的偏移量为1023。
对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：1111111011.
所以，0.1表示为：
说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？
对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 =0.3
JavaScrip面试题

ㅤ普通",
如何获取安全的 undefined 值,"因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。
JavaScrip面试题

ㅤ普通",
typeof NaN 的结果是什么,"NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。
NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x= = =x 不成立）的值。而 NaN !== NaN 为 true。
JavaScrip面试题

ㅤ普通",
isNaN 和 Number.isNaN 函数的区别,"JavaScrip面试题

ㅤ普通",
== 操作符的强制类型转换规则,"对于 = = 来说，如果对比双方的类型不一样，就会进行类型转换。假如对比 x 和 y 是否相同，就会进行如下判断流程：
其流程图如下：

JavaScrip面试题

ㅤ普通",
其他值到字符串的转换规则,"JavaScrip面试题

ㅤ普通",
其他值到数字值的转换规则,"为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。
如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。
JavaScrip面试题

ㅤ普通",
其他值到布尔类型的值的转换规则,"以下这些是假值： • undefined • null • false • +0、-0 和 NaN • “”
假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。
JavaScrip面试题

ㅤ普通",
|| 和 && 操作符的返回值,"|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。
|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果
JavaScrip面试题

ㅤ普通",
Object.is() 与比较操作符 `===`、`==`的区别,"JavaScrip面试题

ㅤ普通",
什么是 JavaScript 中的包装类型,"在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：
在访问'abc'.length时，JavaScript 将'abc'在后台转换成String('abc')，然后再访问其length属性。
JavaScript也可以使用Object函数显式地将基本类型转换为包装类型：
也可以使用valueOf方法将包装类型倒转成基本类型：
看看如下代码会打印出什么：
答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行。
JavaScrip面试题

ㅤ普通",
`+` 操作符什么时候用于字符串的拼接,"根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。
简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。
那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。
JavaScrip面试题

ㅤ普通",
为什么会有BigInt的提案,"JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。
JavaScrip面试题

ㅤ普通",
object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别,"扩展运算符：
Object.assign():
可以看到，两者都是浅拷贝。
JavaScrip面试题

ㅤ普通",
let、const、var的区别,"（1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：
（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。
（3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。
（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。
（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。
（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。
JavaScrip面试题

ㅤ普通",
const对象的属性可以修改吗,"const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。
但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。
JavaScrip面试题

ㅤ普通",
如果new一个箭头函数的会怎么样,"箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。
new操作符的实现步骤如下：
所以，上面的第二、三步，箭头函数都是没有办法执行的。
JavaScrip面试题

ㅤ普通",
箭头函数与普通函数的区别,"（1）箭头函数比普通函数更加简洁
（2）箭头函数没有自己的this
箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。
（3）箭头函数继承来的this指向永远不会改变
对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。
（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向
（5）箭头函数不能作为构造函数使用
构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。
（6）箭头函数没有自己的arguments
箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。
（7）箭头函数没有prototype
（8）箭头函数不能用作Generator函数，不能使用yeild关键字
JavaScrip面试题

ㅤ普通",
箭头函数的this指向哪里,"箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于自己的this，它所谓的this是捕获其所在上下文的 this 值，作为自己的 this 值，并且由于没有属于自己的this，所以是不会被new调用的，这个所谓的this也不会被改变。
可以用Babel理解⼀下箭头函数:
转化后：
JavaScrip面试题

ㅤ普通",
扩展运算符的作用及使用场景,"（1）对象扩展运算符
对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。
上述方法实际上等价于:
Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。
同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。
利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。
需要注意：扩展运算符对对象实例的拷贝属于浅拷贝。
（2）数组扩展运算符
数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。
下面是数组的扩展运算符的应用：
要记住：扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。
如果想在数组内合并数组，可以这样：
需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
比较常见的应用是可以将某些数据结构转为数组：
用于替换es5中的Array.prototype.slice.call(arguments)写法。
JavaScrip面试题

ㅤ普通",
Proxy 可以实现什么功能,"在 Vue3.0 中通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。
Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。
target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。
下面来通过 Proxy 来实现一个数据响应式：
在上述代码中，通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。
当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。
JavaScrip面试题

ㅤ普通",
对对象与数组的解构的理解,"解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。 1）数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的：
要的数据的：
最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：

数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：
通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：

2）对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：
假如想要解构它的两个自有属性，可以这样：
这样就得到了 name 和 age 两个和 stu 平级的变量：

注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：
有时会遇到一些嵌套程度非常深的对象：
像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：
显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：
但是还有一种更标准的做法，可以用一行代码来解决这个问题：
可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。
JavaScrip面试题

ㅤ普通",
对 rest 参数的理解,"扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：
这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：
这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。
JavaScrip面试题

ㅤ普通",
ES6中模板语法与字符串处理,"ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：
仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：
字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：
基于第一点，可以在模板字符串里无障碍地直接写 html 代码：
基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：
除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：
（1）存在性判定：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf > -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。
（2）自动重复：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：
JavaScrip面试题

ㅤ普通",
new操作符的实现原理,"new操作符的执行过程：
（1）首先创建了一个新的空对象
（2）设置原型，将对象的原型设置为函数的 prototype 对象。
（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。
具体实现：
JavaScrip面试题

ㅤ普通",
map和Object的区别,"JavaScrip面试题

ㅤ普通",
map和weakMap的区别,"（1）Map map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。
实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：
Map数据结构有以下操作方法：
Map结构原生提供是三个遍历器生成函数和一个遍历方法
（2）WeakMap WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的。
该对象也有以下几种方法：
其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。
WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。
而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。
总结：
JavaScrip面试题

ㅤ普通",
JavaScript有哪些内置对象,"全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。
标准内置对象的分类：
（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量
（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等
（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等
（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date
（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp
（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array
（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet
（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等
（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等
（10）控制抽象对象 例如 Promise、Generator 等
（11）反射。例如 Reflect、Proxy
（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等
（13）WebAssembly
（14）其他。例如 arguments
总结： js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。
JavaScrip面试题

ㅤ普通",
常用的正则表达式有哪些,"JavaScrip面试题

ㅤ普通",
对JSON的理解,"JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。
在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。
因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。
在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，
JavaScrip面试题

ㅤ普通",
JavaScript脚本延迟加载的方式有哪些,"延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。
一般有以下几种方式：
JavaScrip面试题

ㅤ普通",
JavaScript 类数组对象的定义,"一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。
常见的类数组转换为数组的方法有这样几种：
（1）通过 call 调用数组的 slice 方法来实现转换
（2）通过 call 调用数组的 splice 方法来实现转换
（3）通过 apply 调用数组的 concat 方法来实现转换
（4）通过 Array.from 方法来实现转换
JavaScrip面试题

ㅤ普通",
数组有哪些原生方法,"JavaScrip面试题

ㅤ普通",
Unicode、UTF-8、UTF-16、UTF-32的区别,"（1）Unicode
在说Unicode之前需要先了解一下ASCII码：ASCII 码（American Standard Code for Information Interchange）称为美国标准信息交换码。
ASCII码可以表示的编码有限，要想表示其他语言的编码，还是要使用Unicode来表示，可以说Unicode是ASCII 的超集。
Unicode全称 Unicode Translation Format，又叫做统一码、万国码、单一码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。
Unicode的实现方式（也就是编码方式）有很多种，常见的是UTF-8、UTF-16、UTF-32和USC-2。
（2）UTF-8
UTF-8是使用最广泛的Unicode编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容ASCII码的128个字符。
注意： UTF-8 是一种编码方式，Unicode是一个字符集合。
UTF-8的编码规则：
来看一下具体的Unicode编号范围与对应的UTF-8二进制格式 ：
那该如何通过具体的Unicode编码，进行具体的UTF-8编码呢？步骤如下：
来看一个实际的例子： “马” 字的Unicode编码是：0x9A6C，整数编号是39532 （1）首选确定了该字符在第三个范围内，它的格式是 1110xxxx 10xxxxxx 10xxxxxx （2）39532对应的二进制数为1001 1010 0110 1100 （3）将二进制数填入X中，结果是：11101001 10101001 10101100
（3）UTF-16
1. 平面的概念
在了解UTF-16之前，先看一下平面的概念： Unicode编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放65536（216）个字符，这称为一个平面，目前总共有17 个平面。
最前面的一个平面称为基本平面，它的码点从0 — 216-1，写成16进制就是U+0000 — U+FFFF，那剩下的16个平面就是辅助平面，码点范围是 U+10000—U+10FFFF。
2. UTF-16 概念：
UTF-16也是Unicode编码集的一种编码形式，把Unicode字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。Unicode字符的码位需要1个或者2个16位长的码元来表示，因此UTF-16也是用变长字节表示的。
3. UTF-16 编码规则：
4. 编码识别
那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？
UTF-16 编码肯定也考虑到了这个问题，在基本平面内，从 U+D800 — U+DFFF 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。
辅助平面共有 220 个字符位，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 — U+DBFF，称为高位（H），后 10 位映射在 U+DC00 — U+DFFF，称为低位（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。
因此，当遇到两个字节时，发现它的码点在 U+D800 —U+DBFF之间，就可以知道，它后面的两个字节的码点应该在 U+DC00 — U+DFFF 之间，这四个字节必须放在一起进行解读。
5. 举例说明
以 “?” 字为例，它的 Unicode 码点为 0x21800，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：
（4） UTF-32
UTF-32 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。
比如“马” 字的Unicode编号是：U+9A6C，整数编号是39532，直接转化为二进制：1001 1010 0110 1100，这就是它的UTF-32编码。
（5）总结
Unicode、UTF-8、UTF-16、UTF-32有什么区别？
JavaScrip面试题

ㅤ普通",
常见的位运算符有哪些 其计算规则是什么,"现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。
常见的位运算有以下几种：
1. 按位与运算符（&）
定义： 参加运算的两个数据按二进制位进行“与”运算。 运算规则：
总结：两位同时为1，结果才为1，否则结果为0。 例如：3&5 即：
因此 3&5 的值为1。 注意：负数按补码形式参加按位与运算。
用途：
（1）判断奇偶
只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((i & 1) == 0)代替if (i % 2 == 0)来判断a是不是偶数。
（2）清零
如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。
2. 按位或运算符（|）
定义： 参加运算的两个对象按二进制位进行“或”运算。
运算规则：
总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：
因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。
3. 异或运算符（^）
定义： 参加运算的两个数据按二进制位进行“异或”运算。
运算规则：
总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：
因此，3^5的值为6。 异或运算的性质:
4. 取反运算符 (~)
定义： 参加运算的一个数据按二进制进行“取反”运算。
运算规则：
总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：
在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就直接取其补码，变为十进制：
因此，~6的值为-7。
5. 左移运算符（<<）
定义： 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a=1010 1110，a = a）**
定义： 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。
7. 原码、补码、反码
上面提到了补码、反码等知识，这里就补充一下。 计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。
（1）原码
原码就是一个数的二进制数。例如：10的原码为0000 1010
（2）反码
例如：-10
（3）补码
例如：-10
JavaScrip面试题

ㅤ普通",
为什么函数的 arguments 参数是类数组而不是数组 如何遍历类数组,"arguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组。
要遍历类数组，有三个方法：
（1）将数组的方法应用到类数组上，这时候就可以使用call和apply方法，如：
（2）使用Array.from方法将类数组转化成数组：‌
（3）使用展开运算符将类数组转化成数组
JavaScrip面试题

ㅤ普通",
什么是 DOM 和 BOM,"JavaScrip面试题

ㅤ普通",
对类数组对象的理解，如何转化为数组,"一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。
常见的类数组转换为数组的方法有这样几种：
JavaScrip面试题

ㅤ普通",
escape、encodeURI、encodeURIComponent 的区别,"JavaScrip面试题

ㅤ普通",
对AJAX的理解，实现一个AJAX请求,"AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。
创建AJAX请求的步骤：
使用Promise封装AJAX：
JavaScrip面试题

ㅤ普通",
JavaScript为什么要进行变量提升，它导致了什么问题,"变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。
造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。
首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。
，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。
那为什么会进行变量提升呢？主要有以下两个原因：
（1）提高性能 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。
在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。
（2）容错性更好
变量提升可以在一定程度上提高JS的容错性，看下面的代码：
如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。
虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。
总结：
变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：
在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。
由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。
JavaScrip面试题

ㅤ普通",
什么是尾调用，使用尾调用有什么好处,"尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。
JavaScrip面试题

ㅤ普通",
ES6模块与CommonJS模块有什么异同,"ES6 Module和CommonJS模块的区别：
ES6 Module和CommonJS模块的共同点：
JavaScrip面试题

ㅤ普通",
常见的DOM操作有哪些,"1）DOM 节点的获取
DOM 节点的获取的API及使用：
2）DOM 节点的创建
创建一个新节点，并把它添加到指定节点的后面。 已知的 HTML 结构如下：
要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：
3）DOM 节点的删除
删除指定的 DOM 节点， 已知的 HTML 结构如下：
需要删除 id 为 title 的元素，做法是：
或者通过子节点数组来完成删除：
4）修改 DOM 元素
修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。
将指定的两个 DOM 元素交换位置， 已知的 HTML 结构如下：
现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：
JavaScrip面试题

ㅤ普通",
use strict是什么意思 使用它区别是什么,"use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：
区别：
JavaScrip面试题

ㅤ普通",
如何判断一个对象是否属于某个类,"JavaScrip面试题

ㅤ普通",
强类型语言和弱类型语言的区别,"两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。
JavaScrip面试题

ㅤ普通",
解释性语言和编译型语言的区别,"（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下
（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：
两者主要区别在于： 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。
JavaScrip面试题

ㅤ普通",
for…in和for…of的区别,"for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下
总结： for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。
JavaScrip面试题

ㅤ普通",
如何使用for…of遍历对象,"for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。
如果需要遍历的对象是类数组对象，用Array.from转成数组即可。
如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。
JavaScrip面试题

ㅤ普通",
ajax、axios、fetch的区别,"（1）AJAX Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：
（2）Fetch fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。
fetch的优点：
fetch的缺点：
（3）Axios Axios 是一种基于Promise封装的HTTP客户端，其特点如下：
JavaScrip面试题

ㅤ普通",
数组的遍历方法有哪些,"JavaScrip面试题

ㅤ普通",
forEach和map方法有什么区别,"这方法都是用来遍历数组的，两者区别如下：
JavaScrip面试题

ㅤ普通",
对原型、原型链的理解,"在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。
当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。
特点： JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。

JavaScrip面试题

ㅤ普通",
原型修改、重写,"可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候p.constructor = = = Object ，而不是p.constructor = = = Person。要想成立，就要用constructor指回来：
JavaScrip面试题

ㅤ普通",
原型链指向,"JavaScrip面试题

ㅤ普通",
如何获得对象非原型链上的属性,"使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：
JavaScrip面试题

ㅤ普通",
对闭包的理解,"闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
闭包有两个常用的用途；
比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。
在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题
首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：
在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。
JavaScrip面试题

ㅤ普通",
对作用域、作用域链的理解,"1）全局作用域和函数作用域
（1）全局作用域
（2）函数作用域
2）块级作用域
作用域链： 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。
作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。
作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。
当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。
JavaScrip面试题

ㅤ普通",
对this对象的理解,"this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。
这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。
JavaScrip面试题

ㅤ普通",
call() 和 apply() 的区别,"它们的作用一模一样，区别仅在于传入参数的形式的不同。
JavaScrip面试题

ㅤ普通",
实现call、apply 及 bind 函数,"（1）call 函数的实现步骤：
（2）apply 函数的实现步骤：
（3）bind 函数的实现步骤：
JavaScrip面试题

ㅤ普通",
异步编程的实现方式,"JavaScript中的异步机制可以分为以下几种：
JavaScrip面试题

ㅤ普通",
Promise解决了什么问题,"在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：
上面的代码有如下缺点：
Promise出现之后，代码变成这样：
这样代码看起了就简洁了很多，解决了地狱回调的问题。
JavaScrip面试题

ㅤ普通",
Promise.all和Promise.race的区别的使用场景,"（1）Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。
Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。
需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。
（2）Promise.race
顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：
JavaScrip面试题

ㅤ普通",
对象创建的方式有哪些,"一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。
但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可
复用的对象创建方式，常见的有以下几种：
（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复
用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代
码，而没有建立起对象和类型间的关系。
（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属
性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对
象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，
所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，
造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么
每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。
（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构
造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复
用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有
办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个
对象，一个实例对引用类型值的改变会影响所有的实例。
（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和
原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型
对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使
用了两种不同的模式，所以对于代码的封装性不够好。
（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性
是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模
式进行了封装。
（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要
是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对
象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。
JavaScrip面试题

ㅤ普通",
对象继承的方式有哪些,"（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被
所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。
（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现
的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且
超类型原型定义的方法子类型也没有办法访问到。
（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数
的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上
面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构
造函数，造成了子类型的原型中多了很多不必要的属性。
（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向
函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类
型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型
链方式相同。
（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然
后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继
承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。
（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必
要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要
的属性。
JavaScrip面试题

ㅤ普通",
列出JS基本和非基本数据类型之间的一些区别,"1.目前JS中有6种基本数据类型: Undefined、Null、Boolean、Number、Symbol 和 String。还有1种复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。Object、Array和Function则属于引用类型。
2.基本数据类型是不可变的，而非基本数据类型是可变的。
3.基本数据类型是不可变的，因为它们一旦创建就无法更改，但非基本数据类型刚可更改，意味着一旦创建了对象，就可以更改它。
4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型并具有相同的值，那么它们是严格相等的。
5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。
JavaScrip面试题

ㅤ普通",
module.exports 和 exports 之间有什么区别,"module和exports是Node.js给每个js文件内置的两个对象。可以通过console.log(module)和console.log(exports)打印出来。如果你在main.js中写入下面两行，然后运行$ node main.js:
从打印咱们可以看出，module.exports和exports一开始都是一个空对象{}，实际上，这两个对象指向同一块内存。这也就是说module.exports和exports是等价的（有个前提：不去改变它们指向的内存地址）。
例如：exports.age = 18和module.export.age = 18，这两种写法是一致的（都相当于给最初的空对象{}添加了一个属性，通过require得到的就是{age: 18}）。
JavaScrip面试题

ㅤ普通",
js 执行机制、事件循环,"JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript 语言的设计者意识到这个问题，将所有任务分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous），在所有同步任务执行完之前，任何的异步任务是不会执行的。
当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：

导图要表达的内容用文字来表述的话：
同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的 Event Loop(事件循环)。
我们不禁要问了，那怎么知道主线程执行栈为空啊？js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。换一张图片也许更好理解主线程的执行过程：

上图用文字表述就是：主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。只要主线程空了，就会去读取”任务队列”，这就是 JavaScript 的运行机制。
说完 JS 主线程的执行机制，下面说说经常被问到的 JS 异步中 宏任务（macrotasks）、微任务（microtasks）执行顺序。JS 异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入 Event Queue，然后再执行微任务，将微任务放入 Event Queue，但是，这两个 Queue 不是一个 Queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的 Queue 拿宏任务的回调函数。如下图：

JavaScrip面试题

ㅤ普通",
promise.all,"Promise.all()方法将多个Promise实例包装成一个Promise对象（p），接受一个数组（p1,p2,p3）作为参数，数组中不一定需要都是Promise对象，但是一定具有Iterator接口，如果不是的话，就会调用Promise.resolve将其转化为Promise对象之后再进行处理。
使用Promise.all()生成的Promise对象（p）的状态是由数组中的Promise对象（p1,p2,p3）决定的。
JavaScrip面试题

ㅤ普通",
介绍一下rAF(requestAnimationFrame),"专门用来做动画，不卡顿，用法和setTimeout一样。对 rAF 的阐述MDN 资料
定时器一直是 js 动画的核心技术，但它们不够精准，因为定时器时间参数是指将执行代码放入 UI 线程队列中等待的时间，如果前面有其他任务队列执行时间过长，则会导致动画延迟，效果不精确等问题。
所以处理动画循环的关键是知道延迟多长时间合适：时间要足够短，才能让动画看起来比较柔滑平顺，避免多余性能损耗；时间要足够长，才能让浏览器准备好变化渲染。这个时候 rAF 就出现了，采用系统时间间隔(大多浏览器刷新频率是 60Hz，相当于 1000ms/60≈16.6ms)，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制。并且 rAF 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成。
JavaScrip面试题

ㅤ普通",
javascript 的垃圾回收机制讲一下,"定义：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。
像 C 这样的编程语言，具有低级内存管理原语，如 malloc()和 free()。开发人员使用这些原语显式地对操作系统的内存进行分配和释放。
而 JavaScript 在创建对象(对象、字符串等)时会为它们分配内存，不再使用对时会“自动”释放内存，这个过程称为垃圾收集。
内存生命周期中的每一个阶段:
分配内存 —  内存是由操作系统分配的，它允许您的程序使用它。在低级语言(例如 C 语言)中，这是一个开发人员需要自己处理的显式执行的操作。然而，在高级语言中，系统会自动为你分配内在。
使用内存 — 这是程序实际使用之前分配的内存，在代码中使用分配的变量时，就会发生读和写操作。
释放内存 — 释放所有不再使用的内存,使之成为自由内存,并可以被重利用。与分配内存操作一样,这一操作在低级语言中也是需要显式地执行。
四种常见的内存泄漏：全局变量，未清除的定时器，闭包，以及 dom 的引用
JavaScrip面试题

ㅤ普通",
两种方式实现字符串反转函数,"JavaScrip面试题

ㅤ普通",
事件委托代理,"在构建应用程序时，有时需要将事件绑定到页面上的按钮、文本或图像，以便在用户与元素交互时执行某些操作。
如果我们以一个简单的待办事项列表为例，面试官可能会告诉你，当用户点击列表中的一个列表项时执行某些操作。他们希望你用 JavaScript 实现这个功能，假设有如下 HTML 代码:
你可能想要做如下操作来将事件绑定到元素:
虽然这在技术上是可行的，但问题是要将事件分别绑定到每个项。这对于目前 4 个元素来说，没什么大问题，但是如果在待办事项列表中添加了 10,000 项(他们可能有很多事情要做)怎么办?然后，函数将创建 10,000 个独立的事件侦听器，并将每个事件监听器绑定到 DOM ，这样代码执行的效率非常低下。
在面试中，最好先问面试官用户可以输入的最大元素数量是多少。例如，如果它不超过 10，那么上面的代码就可以很好地工作。但是如果用户可以输入的条目数量没有限制，那么你应该使用一个更高效的解决方案。
如果你的应用程序最终可能有数百个事件侦听器，那么更有效的解决方案是将一个事件侦听器实际绑定到整个容器，然后在单击它时能够访问每个列表项， 这称为事件委托，它比附加单独的事件处理程序更有效。
下面是事件委托的代码:
JavaScrip面试题

ㅤ普通",
什么是跨域 跨域请求资源的方法有哪些,"1、什么是跨域？
由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况：
2、跨域请求资源的方法：
(1)、porxy代理
定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。
实现方法：通过nginx代理；
注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。
(2)、CORS 【Cross-Origin Resource Sharing】
定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。
使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：
(3)、jsonp
定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。
特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。
实例如下：
缺点：
1、这种方式无法发送post请求（这里）
2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。
JavaScrip面试题

ㅤ普通",
开发过程中遇到的内存泄露情况，如何解决的,"1、定义和用法：
内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。
2、内存泄露的几种情况:
(1)、当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。
实例如下:
解决方法如下：
(2)、由于是函数内定义函数，并且内部函数–事件回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。
实例如下：
解决方法如下：
JavaScrip面试题

ㅤ普通",
static 关键字的作用？,"（1）静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份；
（2）静态方法：静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字；
（3）静态语句块：静态语句块在类初始化时运行一次；
（4）静态内部类：非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法；
（5）初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。
初始化补充
存在继承的情况下，初始化顺序为：
父类（静态变量、静态语句块）
子类（静态变量、静态语句块）
父类（实例变量、普通语句块）
父类（构造函数）
子类（实例变量、普通语句块）
子类（构造函数）
Java关键字
Java面试题",
super 关键字的作用？,"（1）访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。
（2）访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。
（3）this 和 super 不能同时出现在一个构造函数里面，因为 this 必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
对于不想进行序列化的变量，使用 transient 关键字修饰。
transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化。当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。
Java关键字
Java面试题",
Java 中的反射是什么意思？有哪些应用场景？,"每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。
反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：
（1）Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；
（2）Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；
（3）Constructor ：可以用 Constructor 创建新的对象。
应用举例：工厂模式，使用反射机制，根据全限定类名获得某个类的 Class 实例。
Java反射
Java面试题",
反射的优缺点？,"优点：
运行期类型的判断，class.forName() 动态加载类，提高代码的灵活度；
缺点：
尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。
（1）性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
（2）安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
（3）内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如：访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。
Java反射",
Java 中的动态代理是什么？有哪些应用？,"动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新功能。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。
动态代理的应用：Spring 的 AOP 、加事务、加权限、加日志。
Java反射
Java面试题",
怎么实现动态代理？,"首先必须定义一个接口，还要有一个 InvocationHandler（将实现接口的类的对象传递给它）处理类。再有一个工具类 Proxy（习惯性将其称为代理类，因为调用它的 newInstance() 可以产生代理对象，其实它只是一个产生代理对象的工具类）。利用到 InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。
每一个动态代理类都必须要实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个 handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：
proxy: 指代我们所代理的那个真实对象
method: 指代的是我们所要调用真实对象的某个方法的 Method 对象
args: 指代的是调用真实对象某个方法时接受的参数
Proxy 类的作用是动态创建一个代理对象的类。它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法：
loader：一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载；
interfaces：一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了
handler：一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上。
通过 Proxy.newProxyInstance 创建的代理对象是在 Jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象。
Java反射
Java面试题",
Java泛型与反射,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里： Java基础面试题阅读指南
 Java基础面试题阅读指南
Java反射",
腾讯Java后端开发面经汇总,"本系列将提供腾讯Java后端岗位历年面经，所有面经都有候选人面试之后根据回忆整理而出，大家可以通过面经来复习以及看看腾讯面试难度。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 【腾讯】Java岗-春招实习-被捞三次(已拿offer)
1. 【腾讯】Java岗-春招实习-被捞三次(已拿offer)
2. 【腾讯】Java岗-暑假实习面经
2. 【腾讯】Java岗-暑假实习面经
3. 【腾讯】Java岗–腾讯地图把我捞了两次
3. 【腾讯】Java岗–腾讯地图把我捞了两次
4. 【腾讯】Java岗-微信支付三面凉经
4. 【腾讯】Java岗-微信支付三面凉经
5. 【腾讯】Java岗-IEG运营开发2面
5. 【腾讯】Java岗-IEG运营开发2面
6. 【腾讯】Java岗-拿到CSIG offer
6. 【腾讯】Java岗-拿到CSIG offer
7. 【腾讯】Java岗-腾讯云实习开发面经
7. 【腾讯】Java岗-腾讯云实习开发面经
8. 【腾讯】Java岗-一二轮面经(太艰难)
8. 【腾讯】Java岗-一二轮面经(太艰难)
9. 【腾讯】Java岗-CSIG实习面试（超详细）
9. 【腾讯】Java岗-CSIG实习面试（超详细）
10. 【腾讯】Java岗-非科班面试总结
10. 【腾讯】Java岗-非科班面试总结
Java后端
腾讯面试",
【腾讯】Java岗-春招实习-被捞三次(已拿offer),"腾讯是我实习投的最早的公司，提前批开始之后的第二周就投递了，但是先是被锁简历一周，然后快要被释放了，才被约了3天后面试，这个时候都3月22号了，所以我的腾讯提前批是从22号开始的。
废话不多说直接上面经。
3.22号一面
1、自我介绍
2、http协议状态码301和302的区别
3、time wait状态是什么意思
4、concurrenthashmap（说的是1.7，1.8发生了变化也要看一下）
5、JVM的垃圾回收
6、Mysql的优化：怎么优化sql、用过mysql的性能分析工具吗
7、反转数组
8、jdbc怎么使用的，什么是sql注入
9、一致哈希
10、抽象类和接口的区别
就2、3没答上，但是第3个问题我是没听清楚面试官说的啥，确实没听懂time wait这两词。
面完直接灰了。
一面（CDG，电面，突击面试）
面试官先和我说，我这边是cpp的技术栈，你确定你还要面下去吗？
1、TCP的四次挥手
2、Java中类变量和成员变量，类方法和成员方法
3、Java中的线程安全问题
4、select/epoll的区别
5、Java中变量存储的位置
6、mysql的查询优化，用explain查询是否用到了索引
7、算法题：
从100W个数中选出第1 3 5 7 9大的数字？选出第50W大的数字？
范围1~300的100W个数，51排在第几？
给你一个单词表，然后给你一个单词，判断是不是合法？（trie树或者hashset）
（当中穿插了一些cpp的问题，我是实在不会就没写了。这面的感觉很好，面试官直接和我说我这边是OK的。这一轮的面试官貌似感冒了，喉咙有点发炎，真是辛苦面试官了。）
二面（约了时间的视频面，90分钟）：
这一面的面试官感觉是老大，比较年长的那种，问问题也是从浅入深直到不会为止。
1、自我介绍一下
2、主要语言是Java是吧？对c++了解吗？c++和Java的区别你说说。
3、Java的内存模型。每个区域是用***嘛的？
4、Java的垃圾回收是怎样的？为什么新生代中内存的比例是8:1:1？为什么会有新生代老年代？新生代怎么变到老年代？你说的垃圾回收算法基于内存整理的是怎么整理的？你觉得可以怎么优化？
5、算法：
给你1,3,5,7，…,n不同面值的硬币（每种硬币数量不限），求组成面值M的最少的硬币个数。（这个算法问题其实挺迷的，题目是这样。我说应该是贪心，但是面试官说没这么简单，你再想想。）
算法
6、Linux常用的指令。（这里我真的不会，用的好少，被说你这是完全不会linux。大概这就是非科班基础的差距吧）
7、MySQL根据成绩表查成绩。
8、MySQL的锁机制。
9、MVCC机制的实现原理。
10、出题考查对索引失效的理解。（最左匹配原则）
面试官评价：对数据库方面掌握还可以，，你在你感兴趣的方面的深度是有了，学习态度也没问题，但是要注意学习的广度。
这里又有了小插曲，我感觉春招开始就很不顺，插曲不断。面完二面以后，面试官说我这边还有其他面试，大概一周之内会给你结果的。然后刚好在我面携程的那一天4.23号刚好一周，状态变成HR面了。本以为差不多了，结果两天后，经历了从HR面退回到初试，然后又跳到GM面的过山车式面试状态。
三面（约了时间的视频面交叉面，30分钟）:
今天的状态是真的差，下午赶着出门，上午面的。
1、自我介绍。
2、有实习过吗？有做过什么项目]？（面试官对我的CRUD完全不敢兴趣，这也正常）
3、数据库的隔离级别？（我真是脑子抽，这个问题都漏了一个，状态是真的差）
4、数据库的引擎？innodb和myisam的区别？
5、什么是聚簇索引和非聚簇索引？
6、数据库怎么加锁的？共享锁怎么加的？
7、select、epoll的区别？
8、给你一整块内存，其中每一页的大小是1K，你怎么加锁？
面的感觉很不好，果然一小时后变灰。
本来以为我的腾讯实习之旅到此结束了，没想到。我在6月底被捞起来了。
一面（电话面，HR约的时间6.19）：
1、自我介绍
2、数据库的隔离级别？
3、数据库的锁的机制？
4、MVCC在四种隔离级别下都有吗？undo日志什么时候会被删除？
5、一个事务中读取了A数据还未提交，另外一个事务处理了A数据，那么此时第一个事务读A会改变吗？
6、说一说HashMap、volatile、Java中的NIO。
7、进程和线程的区别。
8、Redis的跳表。
9、什么是一致性哈希？如果其中有服务器挂了，数据会丢失吗？
10、什么是分布式锁？分布式锁如何实现？
11、Redis一主多从的实现？如果主服务器挂了怎么办？能锁住吗？
12、事务的二段提交？
面试官：有后续会联系你。
二面（突击电话面6.21）：
1、tcp的三次握手和四次挥手。
2、tcp和udp的区别。
3、二叉树的后续遍历。讲怎么实现就好了。
4、从篮子里拿出100个苹果，每次只能拿1个或者2个，有多少种拿法？
5、01背包问题。
6、Linux的常见命令。
面试官：基础还行，就是Linux不行。（再次中刀。。。）
HR面（6.25）
常规问题。
历经磨难，从3月初投简历，到6月底才上岸，一共面了7次，真是漫长又煎熬。期间，就拿了广联达和哈啰的offer。但是最终还是坚持了下来，也感谢我的女票带给我的好运和一直以来的鼓励和陪伴，还有小伙伴们的帮助。
Java后端
腾讯面试",
【腾讯】Java岗-暑假实习面经,"项目
mysql存储引擎以及适用场景
hash b加树如何实现 hash冲突如何解决
tcp三次握手四次挥手 tcp包一次最多发送多少数据 知道哪些序列号 序列号seq的作用
TCP UDP的区别 什么是可靠交付
进程和线程的区别
c语言编译阶段过程 静态链接动态链接
垃圾回收机制 产生OOM的情况
一个算法:千万条数据的文本文档找出所有含有某个关键字的行号
总结
4月22号面的 我是真的菜 哭了 全程卖萌 最后说算法的时候乱说面试小哥都笑了 说 你这么一描述还挺简单的哈
Java后端
腾讯面试",
【腾讯】Java岗–腾讯地图把我捞了两次,"学历：985菜鸡渣硕
已面：腾讯，阿里，蘑菇街，浅橙科技，腾讯，小米，哈啰出行，小红书
offer：小米，浅橙科技，哈啰出行，腾讯
聊项目
算法：布隆过滤器，查重
锁机制，mysql的锁机制，java的锁机制，发生死锁的情况，怎么解决
java发生死锁怎么查看死锁发生在什么地方
jvm相关
hashmap和高并发concurrenthashmap（天天问这个。。）
其他都忘了。。
聊项目
手撕算法：给了很多点，求距离点最近的十个点，删除不符合距离的异常点（答的不好，反正效率不是最优）
挂了，又被捞起面试
算法：10G的文件中查找中位数，不允许排序
爬虫项目拿出来怼了一波
spring架构，bean的数据结构，ioc，aop
hashmap随便说了点，jvm随便说了点，面试官应该不是做java的
spring事务处理，mysql事务处理，有什么联系
mysql事务处理原理
mysql索引有哪些，怎么用，不同引擎的索引
java怎么用mysql行锁
聊项目
有啥兴趣爱好
研究生期间上过哪些课程
高可用了解多少
以后的理想，打算做什么
有什么问题吗
聊了下部门的情况
以后的职业规划
学习经历
学习的东西对广告部门有什么帮助（spark）
location可以选择在那些地方
对未来的展望
平常喜欢做哪些学习
hr很好，聊得很开心
Java后端
腾讯面试",
【腾讯】Java岗-微信支付三面凉经,"稀里糊涂没有对面试难度做了解就投了微信支付
流程还是很快的，总体而言虎头蛇尾，给大家分享一下。
未笔试的情况下来的初试 ，开局给了三道题 一小时内写完
1、爬楼梯，斐波拉契数列
2、中等难度的常规回溯
3、LRU缓存类实现
之后一小时面试：
1、自我介绍+科研项目介绍
记录下还有印象的问题如下：
2、full gc怎么触发
3、了解哪些设计模式，问的比较细，面试官形容一个场景，你讲这是啥模式
比如更新迭代的系统用什么模式 好像是适配器模式吧
然后讲一些你自己用过的或者了解的模式
……问了蛮多，比较考察基础，大部分是常规八股，所以印象不深……
面试官加了我微信，这个面试官对我比较满意
自我介绍+科研项目介绍 ×2
然后知道我没有开发经历和实习经历就开始了速问速答，就是一个半小时有那种口干舌燥的感觉了
问答：
1、纯函数是什么东西
2、Java集合部分
3、 比如Map和hashMap的区别 hashmap和table的区别 还有实现线程安全的方式和区别
操作系统
1、线程进程的区别
2、进程间通信
3、协程和进程
数据库
1、索引的原理、实现结构 为什么用B+树
2、展开后问的害蛮难答的，如何创建索引，每一列都设置为索引为什么不行，从哪几个方面考虑
jvm
讲一讲java内存模型
计网
1、http和https区别、3开头状态码
2、三次握手四次挥手
3、https的ssl连接如何建立，加密如何实现，公钥密钥有几对，怎么混合加密（由以前老的网页的非法弹窗为什么会出现引出的问题）
4、MD5算法是否可反编译
linux
1、查看系统日志文件
2、你用过的命令列举
算法：
问一个问题你得马上给出思路，面试官觉得ok直接过下一个
1、返回链表倒数第k个节点 （我说快慢指针，四个字说完刚要解释，他就说ok，那我们下一题）
2、排序算法常用哪些，各自的适用场景，然后他给出一个场景描述问你选用啥算法，为什么？
手撕代码：
啊 我好像有个大病 愣是想不出来 ……好像不太难
面试官的开场白是说我的一二面面评比较好，基础和代码考查表现得还好，他没必要继续考察，就聊
下我的项目
我讲了我的科研之后
面试官：……
追问我有没有开发经验和实习，为什么不去实习，在没项目没实习的情况下怎么加强自己的竞争力……
稍微聊了一会后
“那今天先就这样吧，我这边也没什么可以问的了” 光速挂
后续问了二面面试官，帮我去看了面评，主要原因就是缺乏项目经验orz
微信支付竞争激烈，很看重上手就能实操吧，投的朋友们可以考虑清楚，因为这个技术面不算初试，复试技术面就3-4轮了，加起来面试次数还是很多的。
Java后端
腾讯面经",
【腾讯】Java岗-IEG运营开发2面,"约的早上10点准时电话来了
1、自我介绍
（末流双211）
实习做的项目
2、jvm结构分区以及调优
（栈、堆、方法区、程序计数器，简单的-ea -Xmx2g -Xms2g -XX:MaxPermSize=1024m）
3、线程池的各个参数以及值，用了什么队列，拒绝策略
（核心线程数 50，最大 100，ArrayBlockingQueue 默认丢弃)
4、MQ用过哪些kafka,mafka，kafka处理流程，瓶颈
5、rpc框架用的thrift怎么通信的，配置
（客户端、服务端以及APPKEY）
6、elasticSearch结构以及语法 index和term
（索引，集群名称和IP地址配置）
7、前端ajax的闭包是什么
（没听说过- -）
8、zookeeper的结构以及功能，有什么问题
（类似于Linux的树结构，服务的注册发现，问题之前看过阿里为什么弃用 zookeeper具体忘了）
9、项目中有没用到微服务
（没有）
10、mybatis和hibernate相比
（轻量级，不需要反向生成，动态sql直接在接口上写注解sql语句，方便）
11、为什么选ssm框架
(主流，方便易用)
12、hystrix怎么熔断的，一些参数
（熔断时间，数量，百分比，超时重试，熔断返回默认值）
13、mafka对kafka的改进
（同机房优先，客户端和zookeeper解耦加入一层）
14、如何做到服务治理，就是动态的修改运行的项目的参数
（mcc把值记录到zk中，在平台上配的时候会通知服务修改参数的值并改变缓存的值）
15、项目运行的服务器多少个
（55个，多个端口提供不同的服务）
实习这里的留任offer和腾讯怎么考虑
这里是IEG部门写java的
还要实习多久- -！
最后说放新我们不会放弃优秀的人才 （ – -我这么弱鸡，感谢某大场实习经历）
听说有4面，4面手撕代码？
Java后端
腾讯面经
腾讯面试",
【腾讯】Java岗-腾讯云实习开发面经,"面的CSIG下面的腾讯云，技术栈是Java，不过几乎不咋问Java。
1、算法题六七道，都是剑指offer难度
2、 半小时项目介绍 & 问答
3、分布式相关：rpc原理、微服务架构
4、海量 数据问题：套路题
5、计网：传输层、网络层（必须要非常熟，ping的原理，tcp的三次握手、四次挥手、拥塞控制。UDP的不可靠、一对一、一对多）
6、操作系统：虚拟内存、段式、页式、进程调度算法
7、数据一致性： 分布式数据一致性、缓存数据一致性
8、Java相关：线程池、HashMap、CopyOnWriteArrayList
9、Redis相关：复制原理、持久化原理
10、杂谈：最近看什么书，实习地点。
1、算法题：最长不重复字串
2、半小时钟项目介绍 & 问答
3、操作系统：Linux的namespace（不会）、进程线程、线程通信方式、进程通信方式
4、计算机网络：传输层和网络层，因为我项目做了链路层，也讲了一下。
5、Java相关： 线程池
6、数据库相关： 一条连表查询语句。数据库索引原理
7、海量数据问题： 套路题
8、杂谈：介绍了部门业务
1、应该是大老板面试了，问的都很哲学：技术背景、学习方法、项目介绍
2、 问了一些简单技术问题。主要考察逻辑表达和整体的素质。
3、杂谈：介绍了部门业务
1、家庭情况
2、面腾讯原因，还有面其他公司么
3、兴趣爱好
4、业务介绍
5、口头offer
Java后端
腾讯面经
腾讯面试",
【腾讯】Java岗-一二轮面经(太艰难),"从2019年2月中旬到4月初，持续了一个半月的暑期实习应聘暂时告一段落，昨天接到了鹅厂的offer
call，今早收到了offer邮件。感谢牛客网这个平台和所有伙伴们，为我提供了很多有用的面经作为准备面
试的资料，所以我也希望能够把我的面试经验分享出来，供大家参考，一定程度上帮助大家。
3.15：腾讯校招官网简历投递（无内推）
3.18：1）收到邮件预约一轮技术面试；2）系统面试状态变为‘初试’
3.20：1）一轮技术面试（50分钟）；2）系统面试状态变为‘复试’；3）收到邮件预约二轮技术面试
3.22：1）二轮技术面试（50分钟）；2）系统面试状态变为‘HR面试’
3.25：1）HR面试（20分钟）；2）系统面试状态变为‘已完成’
4.8：收到offer call及offer邮件
可以看出我的三轮面试环节是在一周之内完成的，且每次面试完当天系统状态就会更新（初试->复试->HR
面试->已完成），非常高效而紧凑。由于我在美国读书，所以每次都是到了预约好的时间，面试官加微
信，语音进行面试。
但是等待offer的过程是非常煎熬的，足足两周，每个事业群或者组应该都是统一报批的，所以时间会不太
一致，希望大家在完成所有面试环节以后，有耐心地等待offer。期间可以找鹅厂的同学帮着查一下内部状
态，因为外部状态到‘已完成’就结束了，但是内部状态会有（待报批->报批中->已录用）。
1、 自我介绍（约两分钟）
2、项目经历
根据不同的组，面试的知识侧重点可能不同。但是根据之前其他公司面试的经验，我觉得鹅厂的面试官对
于项目经历是很重视的，问得很细致，也会跟你探讨一些功能的技术实现，从而评估你的项目难易程（两
个项目大约25分钟）。所以我建议同学们在面试之前复习简历上的两段项目经历，能够做到清晰有逻辑地
表述项目的功能、整体架构、技术实现。我的两段项目经历是关于数据和网站开发的，在讲完项目以后，
面试官的问题分别如下：
1）数据项目：
•项目难点在于哪里
• 用到的Python库都有什么
• 组内分工，自己负责的部分是什么
• 项目周期
2）Web编程项目：
• 是否用了SpringMVC框架
• 用的哪一个HTTP版本
• 列举HTTP Header中的字段
• 一个网站如何判断用户访问是来自于PC端还是移动端
• 如果用户量大的话，什么扩展机制可以支持网站的正常运行
• 聊天室功能中，服务器端是否有采用数据推送的方法
• 服务器宕机的处理机制
3. 技术基础
1）Hadoop：
• Hadoop的HDFS架构及内部机制
• 如果NameNode宕机了，还可否继续运行？
2）数据库：
• MySQL引擎有了解吗
• InnoDB索引底层数据结构
• B+树实现索引的原理、优点
3）计算机网络：
• 网络安全方面的协议是否了解（HTTPS SSL的加密机制）
• TCP和UDP的区别
• TCP运输层和网络层的职能
• TCP拥塞控制机制
• TCP/IP中路由是哪一层实现的，路由的原理是什么？
4）Java基础：
• HashMap的原理，是否为线程安全的？
• 线程安全的HashMap实现方法（ConcurrentHashMap）
• Java同步/异步IO
• Java多态及背后的实现机制
5）算法：
给定一个无序数组，查找中位数
4、个人情况
• 实习时间
• 实习地点是否有要求
• 个人爱好
• 是否愿意学习新的编程语言
5、反问环节
最后面试官会问你有没有什么想要问他的，强烈建议大家在此时问一下事业群及部门的名称、业务，这样
利于第二轮面试，比如根据不同业务有侧重地去复习二面。另外，面试你的组是因为你的简历某种程度上
跟该组业务有契合之处，才发起面试，所以一定是你通过全部面试后要进入工作的组。
1、自我介绍（约两分钟）
2、项目经历
同样问的很细致，比第一轮还要细，所以再次强调对自己项目足够了解的重要性。由于学生做的项目多数
是不会投入实际使用的， 对并发控制、项目处理等不太考虑，面试官很容易问道当有大数据量或者大
量访问的时候，怎样提高系统性能，保障系统的正常使用。
3、技术问题
第二轮面试官问的题目很开放，没有像一面中技术基础问题，反而是协议或者系统设计方面的题目。具体问题如下：
• 如果让你自己设计一套网络层的传输协议，都需要考虑哪些方面，为什么要这样设计？（不要一直说TCP的东西，面试官说TCP也有TCP的缺点）
• 以大型网站为例，你认为如果想设计一个稳定、高效的后台，都需要有哪些部分以及各部分的要点？
• 从用户在浏览器中输入一个url并点击回车，到浏览器界面出现内容，都发生了什么？
4、反问环节（同上）
5、四、HR面试（20分钟）
主要聊一聊学业状况、实习时间、家庭环境、未来工作打算等，不必紧张，表述清晰、大方就好。
找实习的两个月是比较辛苦和煎熬的，尤其是和课内的繁重任务同时进行，真的很有焦灼感，我在腾讯上
岸之前也面过其他公司，都因为准备不充分挂掉了，所以我觉得这是一个必经的过程。我每次面试完会进
行回忆和总结，找找各个公司面试中高频出现的问题和自己这次没有答上的问题，查缺补漏。如果时间紧
张，建议大家可以按照网上的面试经验复习，多看一些帖子（CSDN、简书、知乎都是不错的答案来
源），根据问题总结答案。
最后，希望大家稳住心态，不要轻言放弃，offer肯定会来滴！！！
Java后端
腾讯面经
腾讯面试",
【腾讯】Java岗-CSIG实习面试（超详细）,"1、自我介绍
2、说项目，项目问的比较深，我说到算法（正态分布），问到正态分布的细节
3、HashMap原理
4、Hash碰撞的解决方法
我说了两个：拉链法，开放定址法（需要看看原理）
5、StringBuilder和StringBuffer的区别
我说到了String常量，字符串操作中最慢，之后就是StringBuilder和StringBuffer的线程安全性
6、StringBuilder和StringBuffer使用单线程执行，有区别吗？
看过Java并发编程艺术应该有提及偏向锁的说法，说到这点面试官就okok了，恭喜答到点子了
7、CurrentHashMap原理
CurrentHashMap的原理解析的越清晰越好，双数组+链表的结构
8、synchronized静态方法和实例所属方法的区别
静态方法:当前类class对象作为锁 实例方法:当前对象作为锁
9、说说Lock
10、说说ReentrantLock是基于哪个类的？说说队列同步器
基于队列同步器AbstractQueueSychronier ，在说队列同步器时，我提到了两大点：队列同步器维护一个
同步队列，是双向链表，同时也维护一个同步状态state；还说到它的方法分类：独占式锁和分享式锁
说说独占式锁的实现：我说到了最重要的一点就是加入同步队列的时结点需要自旋查看它的前一个结点是
否获取锁，如果获取的话，它应该尝试获取锁（tryAcquire），面试官OKOK，所以这里的点在于自旋！！！
11、说说list下的ArrayList和LinkedList的区别
主要说ArrayList基于数组，LinkedList基于链表，LinkedList插入删除更快；ArrayList查询更快即可
12、讲讲线程，线程池
我提到了Excutor线程池，着重强调使用过FixedThredPool和ScheduledThreadPool没有提
CachedThreadPool因为它的maximumPool是Integer.MAX_VALUE值，创建线程太多会导致cpu飙升和资
源耗尽OOM
13、说说线程池创建时的参数
corePool核心线程数，maximum最大线程数，时间，以及阻塞队列
（ArrayBlockingQueue,LinkedBlockingQueue,SynchronousQueue,DelayQueue等）
14、线程池处理task的流程
提交实现Runnable或者Callable接口的task，调用submit或者execute方法，先检查核心线程数是否已经
饱满，如果没有的话，创建新的线程执行任务，否则加入阻塞队列；判断阻塞队列是否饱满，如果饱满，
检查最大线程数是否饱满，如果饱满，交给饱和策略（Abort拒绝并报异常默认方式，用发送任务的当前
线程执行，删除阻塞队列最后一个任务将当前任务加入阻塞队列，直接抛弃）
15、讲讲TCP和UDP的区别
TCP三次握手，更加可靠
16、TCP三次握手和四次挥手过程
读者自行百度，最好理解记忆
17.四次挥手的状态
读者自行百度，最好理解记忆，我个人觉得这一快在面试中经常会被问到，尤其是状态迁移，比如
time_wait的时间为什么2msl之长（两个原因）？或者说time_wait大量出现的原因（socket忙于读写或者
程序忘了没有close）？如何避免这种问题？（两种解决方案：基于socket调用close；基于TCP连接的参数
设置，连接超时设置或者按照一定的频率监控连接是否活动，没有活动就关闭连接）
18、TCP最后一次ACK包没有送到就开始传输数据包，会发生什么？
服务端不会接受数据包，并且会返回给客户端RST包，也就是异常包
19.、HTTP1.0和 HTTP1.1的区别
HTTP1.0默认短连接，可以长连接，但是需要设置header connection：keepAlive
HTTP1.1默认长连接
20、HTTP1.0， HTTP1.1和 HTTP2.0的区别
HTTP2.0支持二进制传输数据，更加安全快捷，而 HTTP1.0， HTTP1.1支持文本
HTTP2.0实现多路复用，更加快捷
HTTP2.0压缩header
HTTP2.0支持服务“主动”给客户端缓存发送数据
21、HTTPS的改变？
在 HTTP协议基础上加入了安全协议ssl，读者自行百度了解原理，很重要！！！
22、数据库引擎有哪些？说说他们的区别
说到InnoDB和MyISAM，主要区别是InnoDB支持事务！！！，MyISAM不支持！！！以及MyISAM只支持表锁，InnoDB不仅支持表锁还支持行锁！！！
23、索引的底层
这个我答得不好，因为底层我不是很熟悉，我之后百度了一下，索引其实就是一个树形数据结构，一个B+ Tree，索引作树节点，查询快，但是insert和delete会破坏树的结构
24、Linux命令你熟悉哪些？
我说到Java性能调优用到的命令以及问题定位的命令
25、TOP命令的详解，swap了解吗？真正内存包括缓存和***吗？
读者自行百度，本人在这答得不是很好
26、用过网络编程吧？用过，说说select和epoll的原理和区别
个人觉得这一块需要读者着重看一下，因为很多公司的分布式是使用Netty或者其他NIO，AIO通信的，其中的重点技术也就是在这个select和epoll中，它关系到内核与用户态的交流机制！！！！面试官会okok，兄弟
27、永久代会变吗？
其实这个问题把我问懵了，我当时以为在问永久代的回收机制，结果面试官提醒说到动态加载类，然后就开始加载类的知识点
28、GC策略说说
整体使用的分代回收算法，年轻代使用copy算法，年老代使用标记管理算法，都可以避免产生碎片
29、JVM内存模型
堆，栈，本地方法栈，方法区，程序计数器
30、年老代还有内存，但是程序显示OOM什么原因？
在这我想到JVM一般给大对象比如数组分配内存时会在老年代中分配，这时候会产生OOM
31、还有一个问题忘了没提到：HashMap put操作的最差情况解决方案
我说了最差情况会变成一个二叉TreeMap，查询变快。读者自行百度解析原理，也是常考点，在开发中很重要
32、说说TreeMap的实现原理
基于红黑树，红黑树是平衡二叉树，关于平衡二叉树需要读者耐心解决，这一个知识点可能会问到很多处，比如数据库索引使用就是红黑树，红黑树查询快，但是更改操作会打乱树的结构，有左旋右旋处理法，读者自行百度
33、还有什么问题？
1、自我介绍
2、使用过哪些集合框架？说说HashMap，为什么HashMap无序？为什么不安全？
HashMap是根据对象的hashcode再散列定位数组角标的，所以无序，TreeMap有序
HashMap没有加锁
3、海量数据]存进HashMap性能会变差吗？
我的答案是不会变差，因为HashMap会扩容，查询时间复杂度本来就是O(1)，无论数据量多大，在理论情
况下，不会变差。之后我说了时间复杂度低的原因：先对对象hashcode进行在散列定位到具体的数组角标
中，之后使用equals查看链表是否有相同的key，如果有，直接返回。貌似面试官说okok了解，应该是这
样，读者可以自行百度看看
4、HashMap解决hash碰撞的方案？
前一次面试已经提到了
5、HashMap的reHash过程
HashMap的reHash是在put对象时发生的，先插入到链表]头部，之后判断是否超出临界值（theshold = capacity * loadFactor），如果超出了，进行rehash，在此容量基础上*2，对对象再次hashcode再散列，重新定位数组角标
6、HashMap的rehash过程会发生安全问题吗？
会的，因为rehash过程发生在put操作中，put操作没有加锁，多线程操作的话会发生链表变成环状造成死循环的情况
7、HashTable安全，说说
HashTable每个方法都使用重量级锁synchronized
8、海量数据怎么查找敏感词？
这个问题我没有答好，我只是说到了semhash算法，但是这个算法只是打散句子的过程，面试官提醒使用二叉树树数据结构，但是我没有想明白，读者可以认真考虑一下这个问题
9、Redis的rehash过程
这道题我觉得很有含金量，之前度过Redis的源码，这一部分还是记得比较清楚。过程是：RedisServer结
构体中（Redis使用C语言完成）有一个Dictionary数组，默认容量大小是16， 每个 Dictionary结构体中有
三个Dict结构体指针，Dict其实就是一个KV结构，类似于HashMap，其中两个作为数据存储的库，一个作
为当前使用，一个作为备用rehash；另外一个Dict存储键的过期时间。Redis的rehash过程其实就是将上
述的16个Dictionary进行rehash，Redis内部支持一个周期循环运行的ctro函数，这个函数定期检查上述的
16个Dictionary是否需要rehash，如果有需要，ctro会完成Dictionary的rehash过程，周期结束后并且记
录当前循环到Dictionary数组中的哪一个角标，方便再次循环时从上一次循环停止的地方开始。
其中还有一点，Redis的rehash是延迟性的，每次put会将新元素加入到新的表中，每次查询时，首先会在
新的表中查找，如果没有，在旧的表中查找，查找到的话将这个元素插入到新的表中（这个过程也会涉及
到检查元素是否过期的问题）
10、Redis使用哪些数据结构？
支持字符串，list, sorted list, set, hash
11、Redis是多线程还是单线程的？
单线程！！！！Mem***使用多线程
12、说说TCP和UDP的区别
13、UDP传输数据的最大容量？为什么？
这道题我没答好，我记得是1024，原因我想到了socket的发送缓冲区大小，还有安全方面的考虑。但是面试官说答得有点偏
14、TCP三次握手和四次挥手
15、为什么四次挥手？？
记住TCP是全双工模式，直接说全双工，面试官OKOK
16、协议层有哪些？说说五层协议
OSI，TCP/IP，五层协议
17、ping命令是哪一层？
应用层，使用ICMP协议，没有使用TCP/IP
18、HTTP协议的过程
19、DNS域名解析原理
20、ARP协议原理
读者可以自行看看这些，知道ARP（地址解析协议）的原理
21、每次DNS域名解析都要请求DNS服务器，是不是很耗时？怎么解决
这道题我答得不好，我说到了缓存，但是不知道原因
22、Linux的命令你知道哪些？
23、top命令你注意哪个指标？
我一直围绕JVM那一块，比如PID，CPU利用率，Memory等，但是面试官其实想问你经常看磁盘吗？我说没有。。
24、性能调优看哪些命令？
CPU，Memory等，好像答非所问。。
25、说说你遇到最具特色的项目
26、LRU算法知道吗？自己设计怎么设计？
这道题是这次面试第二大最具难度的题，因为之前看过Redis源码，有提及LRU算法，它的作用就是淘汰不经常使用的元素，使用双向链表作为数据结构，插入时将元素插入到头部，查询时将元素也迁移到头部，这样一来，尾部剩余的元素就是相对使用不太频繁的元素。
自行设计面试官的要求是使用list，我就照猫画虎设计了，面试官OKOK
27、最后一道算法题：7升桶和3升桶，怎么打到2升水？
我的算法：先装满7升桶，然后7升桶向3升桶倒满，7升桶剩余4升，3升桶清空，7升桶再向3升桶倒满水，7升桶剩余1升，3升桶清空，7升桶把最后1升倒进3升桶，之后7升桶再装满水，给3升桶倒满，7升桶剩余5升，3升桶清空，7升桶给3升桶倒满，7升剩余2升，结果出来了
28、这种算法是不是太慢了，有没有快的方法？
我没想到。。
29、你还有什么问题吗？？
Java后端
腾讯面经
腾讯面试",
【腾讯】Java岗-非科班面试总结,"首先问到了项目的架构设计，然后扩展，如果自己项目需要满足10W QPS的需求，架构如何设计？
项目里面高并发下如何实现请求的过滤以及消峰？
集群环境下如何保证数据的一致性？
服务器集群以后如何做到数据的共享？
说一说一致性Hash吧？
问我MySQL主从复制会不会？回答不会。
那你自己设计一下MySQL的主从复制应该如何解决？画一下你的思路？
最后面试官告诉了我MySQL主从复制的原理。然后和他探讨了一下我对这个原理的疑惑。
当时是使用了Redis主从复制的思想来考虑的。
你这种解决办法是从结果来考虑，是不能从原因角度考虑？
说一下STL的Map？
我说我不会，然后讲了一下java的实现，画了一下数据结构图。
讲一下红黑树？
我说您直接看我博客吧，里面有对他的分析。
ali云用的linux什么版本？虚拟机的呢？
说一下常用的shell命令？
看过那些书？
选择出最好的三本？
学习过程？
为什么硕士不报计算机？
你项目里面的这些架构的设计是怎么学习的？
还有一些架构设计的问题忘了了。
面试开始（被吊打之旅开始，完完全全被吊打的没有还手之力）：
一轮面试官对你评价比较好啊，说你是自学Java的？说一下过程？
你懂不懂C++呢？说一些你会的就行。
-1的二进制码是多少？
说一说大小端？
描述一下客户端和服务端进行socket的系统的过程吧？
系统调用是怎样的？
如果服务端在listen以后sleep了，那么client的connect还能接收到么？
进程间通信说一下？
选择一种说一下实现原理？
那么管道和消息队列之间有什么区别么？
为什么有这个区别？
快排思路说一下？
手下一下，拍照片给我。
知道队列么？
手写一下用数组实现的循环队列吧，只需要两个方法入队以及出队？
在改进一下？
为什么使用这种写法？这样就会有一个空间没有利用。可以不可在改一下？
Java后端
腾讯面经
腾讯面试",
字节跳动Java开发面经汇总,"本系列将提供字节跳动Java后端岗位历年面经，所有面经都有候选人面试之后根据回忆整理而出，大家可以通过面经来复习以及看看字节跳动面试难度。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 【字节跳动】-Java岗-抖音直播后端
1. 【字节跳动】-Java岗-抖音直播后端
2. 【字节跳动】Java岗-双非实习四面（已OC）
2. 【字节跳动】Java岗-双非实习四面（已OC）
3. 【字节跳动】Java岗-商业变现后端实习
3. 【字节跳动】Java岗-商业变现后端实习
4. 【字节跳动】-Java岗-抖音直播（很有水准）
4. 【字节跳动】-Java岗-抖音直播（很有水准）
5. 【字节跳动】-Java岗-社招面经
5. 【字节跳动】-Java岗-社招面经
6. 【字节跳动】-Java岗-头条面经和面试经验分享
6. 【字节跳动】-Java岗-头条面经和面试经验分享
7. 【字节跳动】-Java岗-头条三面凉经
7. 【字节跳动】-Java岗-头条三面凉经
8. 【字节跳动】-Java岗-游戏服务器面经
8. 【字节跳动】-Java岗-游戏服务器面经
9. 【字节跳动】-Java岗-后台实习（已拿offer）
9. 【字节跳动】-Java岗-后台实习（已拿offer）
10. 【字节跳动】-Java岗-4技术 + 1HR面经 已offer
10. 【字节跳动】-Java岗-4技术 + 1HR面经 已offer
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】-Java岗-抖音直播后端,"首先面试官跟我说了一下他面试的时候，可能会记录下我的表现，提前跟我打了个招呼。
上来先是简单的自我介绍。
面试官说项目就先聊到这里。
Redis中的分布式你是怎么实现的？
先考一个智力题，有100只狼和1只羊，狼吃了羊就会变成羊，那么狼会不会去吃羊。
接下来是代码题，给定两个有序的数组，求出所有的元素中，第k小的。
最后就是反问。你投递的是抖音直播，关于直播这块有什么想问的吗？我感觉我回答的有些送命，我说的是我基本不怎么看直播…
然后面试官说：你稍微等会，一会二面来找你。
二面10分钟后就开始了。
先做个自我介绍。
技术方面你觉得自己掌握的比较好的方面有哪些？
java中有一个叫泛型，我有一个这样的例子（面试官手打的例子）
我想放入B，其中的AB这两个对象毫无关系。怎么写呢？事后想想不会是直接把泛型去掉吧？？
那假泛型有哪些坑？
java典型的垃圾回收是怎么做的？
有哪些可以作为GC Roots。
以一种体系化的方式，给我介绍一下垃圾回收。
垃圾回收会stop the world，这一步会发生在什么时候，以及如何避免？
为什么必须要stop the world？
标记复制的标记，是先去找gc root吗？那你想过这么一个问题吗，我做新生代垃圾回收的时候，我怎么去处理被老年代引用的对象。
回到stop the world，用户线程是怎么被停下来的？
什么样的点是safe point呢？为什么要选择这些点做safe point呢？
TCP在建立连接的时候是三次握手，而挥手是四次呢？
断开连接的时候有个状态是TIME-WAIT，为什么要有这个状态？这个状态的时间是多少呢？
算法：给定一棵二叉树，然后呢我们要把它就地按照中序遍历使它变成双向链表。
你有什么想要向我了解的吗？
今天字节的两位面试官真的是我秋招以来遇到的12位面试官中，最最nice的了，问的问题非常有水准，然后人也特别棒，跟这种面试官面试就完全能查出自己哪里不足，然后进行查漏补缺，给字节跳动点赞！
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】Java岗-双非实习四面（已OC）,"本人背景双非本科大三软件工程专业，目前收到字节offer，下面是我字节实习经历
4月1日投递简历 -> 4月5日安排简历评估->4月11日笔试（3/5）->4月15日约4月21日面试->4月26日oc+offer邮件
1.简单自我介绍
2.介绍项目（一个预警系统使用的springboot+vue）
3.nginx中有哪些负载均衡策略
4.如何去做负载均衡，有什么想法
5.https与http之间的区别
6.redis单线程为什么快
7.springboot与spring之间的区别
8.http2.0对1.1来讲有哪些改进
9.为什么使用docker部署
10.docker与虚拟机的区别
11.java中synchronized锁升级过程，可逆吗
12.hashmap底层数据结构，为什么引入红黑树，线程安全吗，多线程操作可能产生什么后果
13.https中的密钥交换过程，为什么使用非对称加密
14.url输入浏览器到服务端处理全过程
15.反问
16.一道算法题
原题：最长正确括号匹配长度
一面后面试官说等一下二面，三分钟后进行的二面
1.简单自我介绍
2.介绍项目
3.为什么使用视图，视图的优点与缺点
4.负载均衡算法具体实现说一下你的思路
5.mysql中的事务的四大特性详细说一下
6.一条sql语句在mysql中的执行流程，涉及到那些组件
7.分析器作用
8.如何查看一条select语句有没有走索引
9.常见索引底层数据结构
10.聚簇索引与非聚簇索引的区别
11.讲一下mvcc机制实现原理
12.mvcc是否可以解决幻读问题
13.mysql是怎么解决幻读问题的
14.b+树与b树的区别，为什么索引底层数据结构使用b+树
15.mysql主从复制原理
16.hash索引有什么弊端
17.redolog与binlog的区别和联系，如果数据库宕机日后恢复数据以哪个为标准（这块答的不是很好）
18.反问
19.一道sql题
找出课程平均成绩大于60的学生信息
20.算法题：字符串解析为ip地址 （牛客原题）
二面后十分钟继续三面
1.自我介绍
2.四道算法
2.1 链表奇偶顺序打印
2.2 多线程交替打印ab字符
2.3 接雨水
2.4 股票最大利润
（搞完我一度以为是被刷kpi了）
3.一道大数据题
如何从10亿个字符串中找出出现数量最多的top5(刚开始想的前缀树，面试官好像不太乐意，最初想了一个hash加分治最后比对)
4.问能实习多久
5.反问
4月22日通知三面通过约了23日四面（还是技术面 ?）
1.自我介绍
2.项目介绍
3.java中常见的锁
4.aqs底层实现
5.线程池有哪些类型，好处是什么
6.hashmap的put过程
7.乐观锁与悲观锁的区别和适用场景
8.concurrenthashmap如何实现线程安全的，是绝对安全的吗？
9.jdk1.8引入了哪些新特性
10.interface与abstracted区别，分别适用于什么场景
11.volatile关键字适用场景和内存语义
12.了解哪些设计模式
13.手写线程安全单例模式
14.反问
15.算法题
和为0的三元集集合（原题）
4月26日通知四面通过然后说了待遇问题就发offer了
以上是我字节实习的面经希望可以帮到你哦 ?
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】Java岗-商业变现后端实习,"1、自我介绍
2、算法题]：给定一个排列，求它的下一个排列，[1,2,3] -> [1,3,2] ；[3,2,1]->[1,2,3]
3、说一下netty的主要组件，有什么作用？
4、直接用nio有什么问题吗？selector的源码看过吗？说一下？
5、epoll说一下？平常写代码有直接用到epoll吗？
6、浏览器输入一个url到页面渲染的整个过程？越详细越好？
7、假设你dns获取到的是负载均衡的服务器ip，那么还会通过这个ip映射到应用服务器ip，如果这个过程中出现问题怎么办？
8、hashmap底层说一下？为什么每次扩容都是2倍？和hashtable的区别？hashtable底层数据结构？
9、jvm内存分布？如果现在有一个静态类，它的数据会存在哪？
10、CMS知道吗？频繁full gc怎么排查？
11、finally中的语句总会执行吗？什么情况下不会？
12、redis的几种数据结构都说一下？跳表说一下？
13、mysql索引知道哪些？然后写了几个sql，问能不能走索引？
14、3层的b+树大概能存多少数据？怎么计算的？
15、mysql的锁有哪些？平常有实际用过吗？怎么用的？
16、mysql主从复制知道吗？mysql分片知道吗？有实际应用吗？具体说一下？
17、我这边没什么问题了，你等下，马上会有另外一个面试官跟你沟通
一面完几分钟后，二面面试官就进来了
1、算法题：合并k个链表
2、你写的这个还能再优化吗？优先队列怎么实现的？说一下堆的插入和删除过程？
3、项目介绍
4、你这个项目中，数据库和缓存的读写策略？怎么保证一致性？
5、redis结点宕机了怎么办？某个哨兵节点宕机了怎么办？哨兵的数量对新主节点的选取有什么影响吗？
6、redis的持久化说一下？主从复制的过程说一下？
7、你的项目用到了netty的什么特性？
8、项目有碰到粘包和拆包的问题吗？怎么解决的？
9、群聊怎么实现的？消息怎么存储的？消息怎么推送的？如果这个群特别大，怎么去优化？
10、群聊和视频直播有什么不同的地方吗？
11、如果让你设计一个直播系统，你会怎么设计？弹幕怎么存储？
12、消息队列中积累大量消息没有被消费，你觉得是什么问题？你会怎么解决？
反问：
部门业务和技术栈
二面完之后过了几分钟，hr电话跟我说面试通过了，约了三面时间，并且加了一下微信
1、自我介绍
2、算法题：给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
3、SQL题：
4、介绍一下你做的项目，然后对其中一个项目进行扩展，从单机扩到分布式，会出现哪些问题，你会怎么解决？（10min）
5、CPU的调度方式
6、内存管理
7、linux命令知道哪些？
8、DNS的过程知道吗？ping的过程知道吗？
9、微服务了解吗？说一下你用过哪些组件？怎么用的？
10、消息队列了解吗？怎么保证消息能消费到且只被消费一次？
11、平常怎么学习的？看过哪些书？说一本印象最深刻的？有看过非技术的书吗？
12、我这边没问题了，你有什么想问我的？
反问：
对这次面试的评价和对我的建议
1、自我介绍
2、前面的面试有做过复盘吗？能具体说一说吗？
3、看你参加的比赛挺多的，也做过很多项目，那你是怎么去利用好自己的时间的呢？
4、你现阶段的个人规划可以说一下吗？
5、你觉得你大学到现在让你改变最大的一件事是什么，可以分享一下吗？
6、除了字节，还有其他公司的offer吗？如果字节这边给你发offer，你会怎么选择呢？
7、什么时候能来实习？能实习多久？
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】-Java岗-抖音直播（很有水准）,"面试的是一个小姐姐，面试体验很好，会根据回答抛出问题，过程还算顺利，没太多卡壳的地方
一面结束，问了面试官感觉面试下来感觉如何，说挺好的，就是有的地方遗忘了，希望后续补全一下知识点。
一面的大量背书直接导致我后续准备接着复习基础，而且一面没有问到计网和多线程，操作系统的知识，感觉之后面试可能是重点，就开始重点准备这一块。
这次的面试官起来就知道是一个大佬，后来问的一些问题也证明了我的猜想
反问环节：
问了没回答出来的编码问题，问之后需不需要去专门注意这一块的知识
又问了根据这次面试，觉得我那块是需要加强的
然后面试官给出了他的见解和建议，让我多思考
反问环节一结束我就大概知道自己凉凉，三四天准备的东西一个都没有问到，就算法最近恶补了一下刷到了，问的问题都是自己平时想都没有想过的，确实就还需要努力，二面直接让我认识到字节的面试难度，在一些小细节上也需要深挖，而且对于整体知识点的连接也尤为重要。
最后的最后还是继续努力，春招上岸自己满意的公司！！也感谢字节大大给的面试机会
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】-Java岗-社招面经,"1、一些Java基础知识。
2、倒排索引。
3、讲讲redis里面的哈希表？
4、happen-before的规则？
5、volatile修饰符，synchronize锁。
6、java单例模式的实现？
7、进程与线程的区别，多进程和多线程的区别？
8、HashMap原理，为什么用红黑树，红黑树的特点？
9、快排时间空间复杂度，最好最坏的情况，优化方案？
10、TCP的拥塞控制，具体过程是怎么样的？UDP有拥塞控制吗？如何解决？
11、讲讲了解的垃圾回收算法和回收器，什么时候执行STOP THE WORLD？
12、了解Go语言吗？
13、问项目相关的东西：负责哪个模块？有没有碰到什么问题？怎么解决的？
1、Kylin的项目架构。
2、Paxos和ZAB协议。
3、CAP理论，分区容错性的意义。
4、大表Join小表优化，如何处理数据倾斜？
5、讲一下最大堆和最小堆。
6、HDFS的读取、写入，容错处理。（源码）
7、MapReduce的过程。（第一版和第二版的）
8、MR shuffle，Spark shuffle。
9、namenode HA，脑裂，Yarn的调度机制。
10、Hive的内部表和外部表区别、数仓建模模型、数仓分层、雪花模型和星型模型。
11、了解ClickHouse吗？它与Kylin的区别？
1、LRU算法]实现。（伪代码）
2、链表倒数第K个数。（讲思路）
3、一堆螺丝和螺母用最短时间匹配。（代码实现）
4、求每天浏览页面的新用户。（Hive QL实现）
5、求抖音小视频每日点击量最高的10个。（Hash + 最小堆）
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】-Java岗-头条面经和面试经验分享,"从去年七月到现在，我从一个很菜的菜鸡变成了一个有offer的菜鸡。
今年春招拿了oppo 、vivo、拼多多、成都头条的offer，现在已经是心满意足了，打算上岸了。
首先废话不多说，最近刷牛客很多人因为简历筛选就挂了，这里附上我自己的简历。（至少头条、拼多多的简历筛选都过了）

一般来说，很多公司对了解分布式的人是很感兴趣的，只要你的简历上写了了解分布式，一般都会问到。其实我会的分布式知识也就几个：分布式锁、分布式事务、Dubbo、Zookeeper。这些里面只要了解一些基本都算是加分项。在刚学的时候，觉得分布式只是很难，其实静下心来学，也没有那么难。差不多一个月左右可以基本掌握。
分布式锁：使用数据库怎么实现？使用Redis怎么实现？使用Zookeeper怎么实现。各种实现有什么问题？比如锁泄露、可重入这些问题。这里就不一一讲解了，因为网上一搜分布式锁，讲的都很详细。
分布式事物：二段提交、TCC、本地消息表。这三种会出现各种的优缺点？这里看下博客也就基本都没问题
Dubbo：学习Dubbo主要看官方文档，官方文档写的非常好，里面从Dubbo的基础再到实现细节。个人感觉最好的模块是Dubbo中文网站的源码导读模块。

这里静下心来看，很容易看懂，把大致思路看懂了，面试基本没什么问题。
Zookeeper：Zookeeper其实了解起来很简单。买本书来看一下，几天就会。
上面这些东西都学得差不多了，分布式知识的基础也就起来了。后面的消息队列什么的我也还没学，就不多说。学会这些的好处上面已经说了，面试官对分布式知识很感兴趣，基本你写就会被问到。
然后是项目，针对项目而言，一般来说简历上写两个项目左右就够了，大多数面试官一般会让你挑一个最好的项目来说。所以多写无意义（当然是针对我这种做的项目不太好的人而言）。所以尽可能的优化你的某一个项目，多使用一些能吹的技术。就比如我的项目写了数据库主从同步，首先为什么要用主从？为什么要读写分离？什么时候读写分离好？Mysql主从原理？线程模型？……这些基本都要掌握。或者说线程池，线程池原理、操作流程、拒绝策略、为什么使用线程池（好处）、线程池种类（Fixed、Single、Cached….），这些不同种类的线程池具体怎么实现的？使用与什么场景？
基本上来说，面试官让你介绍项目的时候，主动权就在你这边，你需要将你项目使用的技术、优化点都说出来，然后引导面试官向某一个方向问问题。比如你提到了用了线程池，很多面试官也就会问你线程池的问题。
然后分享一下自己自我介绍的套路：一般来说，自我介绍先介绍名称、学校、专业，然后是自己做的方向（比如Java后端）。这些完了以后介绍自己学习的东西，比如java，从基本的语法到Jvm，java高并发（给面试官抛出一些可以问的东西），然后是框架、提一下项目…..
上面这些都挺套路的，套路完了，还是要看基本功。对于Java开发来说，JVM是一个必备知识点。JVM内存模型，哪些是线程私有的？虚拟机栈栈帧对应什么？虚拟机栈中局部变量表、操作数栈、动态链接等都有什么作用？这里提一下，动态链接是相对于静态解析而言的，静态解析也就是在类加载阶段有一个解析阶段，是将符号引用转化为直接引用，但是在这个阶段不一定能完全解析方法地址，也就是在不能判断方法执行版本时，比如重载的方法时，就需要靠动态链接来找到对应方法。或者说堆的结构，如何划分？Eden、To Survivor、From Survivor作用各是什么？GC时这些部分有什么功能？比如一个面试官让你介绍GC，首先应该介绍什么样的对象会被GC，这里就要介绍引用计数法和可达性分析法。然后是GC算法，各个算法优缺点，然后是垃圾收集器，一般来说主要了解CMS和G1，当然其它能了解最好也要了解。然后就是JVM调优，jvm参数、调优命令：jstat、jmap、jstack、jps等等。最好自己用一下。后面的至于类加载机制、双亲委派模型都可以通过《深入理解Java虚拟机》这本书了解。
然后是Java高并发，一般来说，很多时候面试官会让写单例模式，我自己写的一般都是volatile 双重检查加锁的形式。主要原因在于这里可以引入介绍volatile和synchronized。volatile保证有序性和可见性。有序性很简单，就是内存屏障，禁止指令重排序。可见性一般来说我会结合缓存一致性协议来说，MESI，具体深入对具体的处理器中的缓存条目进行操作，然后处理器和总线通信等等。这里可以参考《java多线程编程实战指南》，讲的很详细。然后是synchronized关键字的锁的实现，和Lock的区别，做出的优化：适应性自旋锁、偏向锁、轻量级锁，锁什么条件下回升级？这些说完，Lock的实现？AQS？可重入实现？读写锁实现？这些可以参考《java并发编程的艺术》这本书，讲的非常详细、基本从源码的角度来说。总之java并发可以问的问题很多，我个人主要就看了以上我提到的两本书，不会的地方上网查查就行。
再然后是java集合。一般来说集合主要了解ArrayList、LinkedList，它们之间的区别。HashMap、Maps.synchronizedMap、ConcurrentHashMap。针对于HashMap，需要了解1.8优化使用了红黑树和尾插法。然后是需要详细介绍put get resize三个操作，难点在resize，比如当前节点在新的数组会映射到哪一个位置？怎么判断？然后是ConcurrentHashMap使用的分段锁，继承可重入锁实现，1.8使用synchronized关键字 CAS操作实现。上面这些最好都读源码。Set的话一般都是参考Map来实现的，也就是只使用Map的key来存取值。
操作系统，进程线程、进程状态——用户态转内核态，为什么要转？虚拟内存？死锁？进程通信？
计网，TCP和UDP，主要了解三次握手四次挥手，为什么三次，为什么四次？为什么挥手后要等待2MSL才中断？TCP快速重传、滑动窗口、流量控制、拥塞控制、慢启动机制等。一般来说面试官应该对拥塞控制和流量控制更感兴趣。HTTP请求格式，请求行、请求头，请求方法？RESTFUL？请求状态码？HTTPS，对称加密和非对称加密？以非对称加密的方式传递对称加密的秘钥。
然后是Mysql，Mysql要求基本的增删改查语句都要会。然后一般来说Mysql的调优(怎样排查执行慢的sql)：慢查询日志、explain分析查看是否走索引，没有索引创建索引，有的话判断索引为什么失效？索引什么时候会失效？最左匹配原则、or条件两边有一边没有使用索引、字段类型隐式转换、like以%开头、表中数据较少导致全表比索引快，这些条件都会导致索引失效。索引的底层实现？介绍B 树？这里主要先介绍BST二叉搜索树，然后从磁盘I/O的角度介绍B树。然后介绍B 树所做的优化，即非叶子节点值存储key，这样这些节点可以存储更多key，也就降低树高度，减少I/O次数；叶子节点以链表形式连接，方便范围搜索。然后是聚簇索引和非聚簇索引。一般来说聚簇索引B 树的叶子节点存储的数据，非聚簇索引叶子节点存储指针，所以非聚簇索引要多一次I/O操作才能读取到数据。最后就是Mysql的主从，主从原理和机制。Mysql我看的书是《深入浅出Mysql》，上面索引讲的不多，还需要自己看博客。
Redis，redis只用一本书就够了，《Redis的设计与实现》。拓展问题有缓存穿透和缓存雪崩？怎么解决？缓存穿透可以使用布隆过滤器、缓存雪崩可以设置随机过期时间。
算法方面，了解数据结构以后就刷leetcode或者《剑指offer》吧。
我会的基本也就这些了。总的来说，我是从去年7月份开始从零开始学的，已经算是很晚了。现在牛客的你们所有人都应该比当时的我强吧。从开始学习，相继看了《Head First Java》、《Head First 设计模式》、《深入理解Jvm》、《Java EE互联网轻量级框架整合开发— —SSM框架》、《java多线程编程实战指南》、《java并发编程的艺术》、《数据结构与算法》、《Redis设计与实现》、《大型网站技术架构》、《剑指offer》、《ZooKeeper：分布式过程协同技术详解》、《深入浅出Mysql》等等。我认为学习技术不能单了解别人所说的就可以了，最主要是要问为什么。还有就是要沉下心来学习，不断的向前行。
给你一个已经排序的数组，找到一个元素第一次出现的位置，{1,2,3,3,3,3,4}，输出2
我：一直二分，考虑边界
HashMap
TCP介绍
我：可靠数据传输、三次握手、四次挥手、流量控制、拥塞控制…..
使用Zookeeper作为Dubbo注册中心时，Zookeeper结构是什么？（这个Dubbo官网有）
数据库索引及实现
我：介绍B 树
….
手写单例
你用了volatile，volatile介绍
我：有序性和可见性
Jvm内存模型
Dubbo介绍
我：从服务暴露到服务消费流程，中间提到了SPI机制以及自适应拓展机制
一致性Hash
我：值了解过Dubbo负载均衡里面的一致性hash，介绍了一遍（这里Dubbo源码]导读里也有）
二段提交
我：资源管理器、事物管理器，了解Mysql事物二段提交操作，prepare，commit，rollback
二段提交有什么问题
我：最主要的是单点问题
怎么解决？
我：心跳机制？各个资源管理器建立连接？
不对
我：第三方监控？类似于Redis里的哨兵？
对了
2T文件，有uid，uname。3T文件，有uid，utext。要求将两个文件uid相同的整合。
我：使用hash，将这些文件进行散列，相同uid会散列到相同文件，然后使用hashmap进行整合
那如果我的hash散列不均匀？全部散列到一个文件？
我：可以排序（面试完发现忘了再散列这种方法）
面试官有点失望，问下一个问题。（手撕）给你一个User，包含id，name，parentId。然后给你一个List，要求将它转换成一棵树的结构。只有一个跟节点，parentId=-1
我：（一开始完全不会）先写找到跟节点，然后找到这个根节点的子节点。找到子节点以后发现将这些子节点进行递归就建立起来了
一张表有ABC三个字段。现在要查BA，BC，B，问怎么建立索引？
我：最左匹配原则，BA，BC
……
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】-Java岗-头条三面凉经,"第一家撑到三面的公司，还是很开心的
1.算法题：求二叉树两节点的最长距离，搞了30分钟。。。
2.volatile修饰符的作用
答：volatile保证线程对该变量的可见性，根据JMM模型每个线程都有一块抽象私有的本地内存区域，该区域与主内存进行交互（当对volatile变量进行写的时候，会是其他线程的内存中存储该变量的值失效）
3.能不能写一个函数,由于指令重排序导致其输出的结果不是想要的
4.解释下 happen-before的规则
1.算法题：求前序遍历的递归，非递归算法
2.算法题：求一个数组中连续子数组的最大值，  如 【3,-4,1，2】，最大值为3，子数组为【1,2】
3.画出TCP的4次挥手过程，为什么需要四次，不能三次吗
答：当服务端接收到客户端的FIN数据报时，服务端可能还有需要发送的数据，因此FIN与ACK不能合并到一起发送。如果合并到一起发送，就不能确定服务器发送的数据，客户端是否接收到了。
4.解释下TIME_WAIT, 为什么取值为2MSL
答：2MSL刚好是数据报进行一个来回的时间，目的是为了确认服务端没有再次发送FIN；
5.如果服务端中存在大量的TIME_WAIT请分析下原因
答：发送在服务端主动断开连接，并发送ACK响应，进入TIME_WAIT状态，如果客户端一直在向客户端发送FIN包，服务器就会一直发送
6.说下操作系统中页面置换算法
答：先进先出，LRU,
7.说下LRU的实现思路
8.概率题：甲和乙投掷硬币，谁先投到正面谁就赢。先投的人赢的概率是多少          答案应该是2/3,通过一个等比数列可以算出
1.进程与线程的区别（这个不太清楚）
答：一个进程可以有多个线程，一个线程只能属于一个进程。进程的上下文切换的代价比较大：因为进程切换时，会导致高速缓冲区失效；线程上下文切换时，只需要替换程序计数器，还有线程私有内存区就行了。
2.进程切换还需要改变什么
答：进程还需要保存打开文件的状态描述符
3.线程进行替换时，哪些东西会变
4.了解过一些中间件吗，例如负载均衡，数据库，分布式
答：不太清楚
5.了解过b树与b+树的区别吗（我需要好好梳理一下）
答:b树的非叶子节点存储索引和数据，而b+树只在叶子节点存储
6.为什么b+树需要这么做
答与磁盘的IO读取有关，balala，不需要说到了b+树类似平衡树（感觉面试官开始怼了）
7.那么二叉平衡树也可以在非叶子节点存储索引，叶子节点存储数据。两者有什么不同
答:b+树叶子节点用了链表
8.那么二叉平衡树在叶子节点加链表。两者有什么不同
答:b+树是多叉树，这样可以减少树的深度
9.了解隔离性
答只知道有四种隔离
10.算法题： 将一个字符串改变其字符（假设需要将字符x变成y,则y也需要变成x），使其与另一个字符串相等
例子 字符串1： aabba -> 字符串2： eeffe //这里 字符串1a变成e,然后该字符串中如果存在e，也要把它变成a,这个返回ture
字符串1： asdf  -> 字符串2： asag        返回false
11.工程题：
给你一个大的Hash文件，对其进行快照，获得该时刻文件的快照。  要求在快照过程中，还可以将数据写入该文件中，或者修改该文件中的值。
答：建立一个缓冲区，把那些要改的数据和要更新的之前数据发到缓冲区里面（估计不对）
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】-Java岗-游戏服务器面经,"hashmap treemap concurrentHashMap
nohup
字符串 分割 split(String s, char splitchar, int index) s是待分割的字符串 ，char为 分隔符，index是第几个边界条件
| 管道符的作用 awk
Linux 环境变量 $Home 配置路径 etc/?，文件
GCRoot 哪些可以作为GCRoot
netty问题
Stream 流 Java8
红黑树与自平衡二叉树AVL的区别
hashmap ，hashcode &(length-1)
二维方格，从第一个到最后一个的多少路径 dp动态规划问题
redis zset 跳跃表问题 字典
levelDB事务问题
netty 序列化问题 从序列化开始- > response
netty 与 NIO的问题，优化问题
mysql 事务问题 可提交读 等等
levelDB原理问题
服务器架构
重复登录不同的world 问题
排行榜问题 zset
lambda表达式
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】-Java岗-后台实习（已拿offer）,"1.hashmap
2.为什么负载因子是0.75
3.spring ioc讲一下
4.有jvm调优过吗
算法
1.给出1-n，提供一个接口判断是不是bad，只要一个数是bad后面都是bad，一开始我以为是无序的，直接循环o(n),她说优化一下，我就觉得再优化就是logn了应该是二分,再仔细看了下题才发现是有序的
2.链表表示数，两个链表相加返回一个新链表
这个面试官超级好！！！他先自我介绍了一下不知道为什么就感觉超有被尊重，全程我说什么就一直点头让我觉得我说的好对hhh，算法有点毛病有点不会就很耐心地引导我
1.高并发的项目问啊问，但全程都是在探讨没有被为难(开心
2.另一个操作系统的项目问我进程是怎么调度的
3.垃圾回收算法
4.提到cms问我cms有几个步骤
5.cms会抛出con什么什么failure有什么解决方法， 我有点懵（小声），就扯了扯之前jvm调优用到的参数也就糊弄过去了，问我有个什么老年代的参数，是提前什么什么的阈值，我一想提前pre嘛，阈值thredhold，就说是pre什么thredhold具体有点不记得了，他说嗯差不多就是这个（我？？蒙对了）
6.动态代理实现的方式，我提到了aop里面的两种
7.线程池参数，流程
8.tcp三握四挥
9.为什么三次，我说可以避免打开错误的链接，避免迟到的ack到达以后打开两个连接，他说是怎么知道这个连接已经建立过了呢，我猜可能通过tcp头部的地址来确定的，也不知道对不对
(牛客的视频没法录音可能有些不记得了)
算法
1.删除链表中重复的节点，有点小问题改过来以后他说做的挺快那我们就再写一道（？？）
2.二叉树的最小高度（注意是最小，不是普通的那种）
1.手写一个blocking queue
2.拓扑排序,我直接把面试页面截在下面了,太久没接触图论了完全不会,面试官引到我往二叉树的三种遍历上想,我就觉得这又没有左右节点跟二叉树有什么关系,后来才慢慢明白过来是先递归输出子节点再输出自己的值,类似于后续遍历,写出来之后还忘了要保存这个节点有没有输出过(就是下面这个set忘了没写,会重复输出,面试官提醒了我才想起来)
3.左连接右连接的区别
4.平时刷题吗
5.考研吗,为什么
(问的问题很少可能因为做题做的比较久)
反问,emm其实我从来不问面试结果,这次心里太没底了就问还有下一面吗,他说还有hr面,(呼 松了一大口气
(居然只面了我六分钟)
1.平时怎么提升技术
2.实习时间
3.如果给了offer可以继续实习吗
4.还有什么问题
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
【字节跳动】-Java岗-4技术 + 1HR面经 已offer,"背景 本科双非一本，美硕。因为时差问题，每次只能进行一轮面试，三轮面下来用了一周多，不过每次面完
很快就有了结果，可以约下一次的面试。三面的时候到了约定的时间，面试官突然有急事，所以往后推了一
天。
面试官人非常nice，过程用讨论的形式，非常愉快。
1.自我介绍
2.聊简历
3.引入java
string为什么不可改变？
4.final修饰class 和 方法有什么作用
—class不能被继承
—方法不能重写
5.GC回收机制：描述， 算法等
6.SQL事物隔离级别，描述
7.索引（数据结构，除了hash B+）
—FullText， B-Tree， R-Tree
B+有什么特性？为啥数据都存放在后面？
—和Btree的区别，提高区间访问的性能。
Redis跳表
8.网络
输入一个网址，到界面出现，的过程。
http > tcp等等 过程描述（DNS等
9.tcp三次握手 四次挥手
10.udp有无状态
http有无状态
11.游戏是什么连接
–UDP
那如何保证可靠性？
12.算法： 有序有重复数组，给定target确定范围
1.聊简历（指定介绍了proj，所以简历上的最好都准备一下）
2.cookie和session区别
—session如何辨别是哪个用户
3.hashmap地址冲突如何解决？
hashmap是否线程安全？为什么
4.tcp四次挥手why？
5.索引结构列举
B+tree深度 与 存储数据的关系
手写SQL：还蛮简单的表结构，用了嵌套查询 和 一些关键字（distinct group by等）
6.算法：3sum
7.扫码登录是如何实现的（其实我不会，面试官说就想听听我会怎么想，所以不会的话也要把自己的思考过程讲出来哦）
—最后提问 我问了扫码登录的实现，答案是关于长连接等等
1.聊简历（聊了得有二十分钟
2.redis：是由项目中大量数据存储引入的redis，所以要熟知redis各种特性，有聊关于redis持久化，和redis性能方面
3.全文搜索有什么办法？（回答了fulltext，底层逻辑不清楚
4.思考题：64匹马，8个跑道，选跑最快的四匹马需要比赛多少次。
5.算法：k个一组反转链表。
1.聊聊疫情。。
2.聊聊以后工作打算
3.场景题：长文本，提取热点词语，数据量很大如何操作
4.内存和硬盘的区别。（很意外哈哈哈
5.概率：两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率
6.反问：问了部门的职能和工作内容
没有刷算法，面试官应该是部门的leader，聊了很多职业规划，也给出了很多建议很有帮助。
当天下午hr联系说四面通过了，需要再内部讨论一下决定 再给通知。
许愿正式offer
家加油，努力一起上岸！
Java后端
字节跳动面经
字节跳动面试

ㅤ普通",
解释下什么是面向对象？面向对象和面向过程的区别？,"面向对象是一种基于面向过程的编程思想，是向现实世界模型的自然延伸，这是一种“万物皆对象”的编程思想。由执行者变为指挥者，在现实生活中的任何物体都可以归为一类事物，而每一个个体都是一类事物的实例。面向对象的编程是以对象为中心，以消息为驱动。
区别:
（1）编程思路不同：面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。
（2）封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。
（3）面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势很明显
Java基础
Java面试题",
面向对象的三大特性？分别解释下？,"（1）封装：通常认为封装是把数据和操作数据的方法封装起来，对数据的访问只能通过已定义的接口。
（2）继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类/基类），得到继承信息的被称为子类（派生类）。
（3）多态：分为编译时多态（方法重载）和运行时多态（方法重写）。要实现多态需要做两件事：一是子类继承父类并重写父类中的方法，二是用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为。
几点补充
1）子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。因为在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象；
（2）子类可以拥有自己属性和方法；
（3）子类可以用自己的方式实现父类的方法。（重写）
Java基础
Java面试题",
JDK、JRE、JVM 三者之间的关系？,"JDK（Java Development Kit）：是 Java 开发工具包，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。
JRE（ Java Runtime Environment）：是 Java 的运行环境，包含 JVM 标准实现及 Java 核心类库。
JVM（Java Virtual Machine）：是 Java 虚拟机，是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。所有的 Java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行。
Java基础
Java面试题",
重载和重写的区别？,"（1）重载：编译时多态、同一个类中同名的方法具有不同的参数列表、不能根据返回类型进行区分【因为：函数调用时不能指定类型信息，编译器不知道你要调哪个函数】；
（2）重写（又名覆盖）：运行时多态、子类与父类之间、子类重写父类的方法具有相同的返回类型、更好的访问权限。
Java基础
Java面试题",
Java 中是否可以重写一个 private 或者 static 方法？,"Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。
Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用， 如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。

  静态方法补充：静态的方法可以被继承，但是不能重写。如果父类和子类中存在同样名称和参数的静态方法，那么该子类的方法会把原来继承过来的父类的方法隐藏，而不是重写。通俗的讲就是父类的方法和子类的方法是两个没有关系的方法，具体调用哪一个方法是看是哪个对象的引用；这种父子类方法也不在存在多态的性质。

Java基础
Java面试题",
构造方法有哪些特性？,"（1）名字与类名相同；
（2）没有返回值，但不能用 void 声明构造函数；
（3）成类的对象时自动执行，无需调用。
Java基础
Java面试题",
在 Java 中定义一个不做事且没有参数的构造方法有什么作用？,"Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。
因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是：在父类里加上一个不做事且没有参数的构造方法。
Java基础
Java面试题",
Java 中创建对象的几种方式？,"1、使用 new 关键字；
2、使用 Class 类的 newInstance 方法，该方法调用无参的构造器创建对象（反射）：Class.forName.newInstance()；
3、使用 clone() 方法；
4、反序列化，比如调用 ObjectInputStream 类的 readObject() 方法。
Java基础
Java面试题",
抽象类和接口有什么区别？,"1）抽象类中可以定义构造函数，接口不能定义构造函数；
（2）抽象类中可以有抽象方法和具体方法，而接口中只能有抽象方法（public abstract）；
（3）抽象类中的成员权限可以是 public、默认、protected（抽象类中抽象方法就是为了重写，所以不能被 private 修饰），而接口中的成员只可以是 public（方法默认：public abstrat、成员变量默认：public static final）；
（4）抽象类中可以包含静态方法，而接口中不可以包含静态方法；
JDK 8 中的改变：
1、在 JDK1.8中，允许在接口中包含带有具体实现的方法，使用 default 修饰，这类方法就是默认方法。
2、抽象类中可以包含静态方法，在 JDK1.8 之前接口中不能包含静态方法，JDK1.8 以后可以包含。之前不能包含是因为，接口不可以实现方法，只可以定义方法，所以不能使用静态方法（因为静态方法必须实现）。现在可以包含了，只能直接用接口调用静态方法。JDK1.8 仍然不可以包含静态代码块。
Java基础
Java面试题",
静态变量和实例变量的区别？,"静态变量：是被 static 修饰的变量，也称为类变量，它属于类，因此不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；静态变量可以实现让多个对象共享内存。
实例变量：属于某一实例，需要先创建对象，然后通过对象才能访问到它。
Java基础
Java面试题",
12、short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？,"对于 short s1 = 1; s1 = s1 + 1; 来说，在 s1 + 1 运算时会自动提升表达式的类型为 int ，那么将 int 型值赋值给 short 型变量，s1 会出现类型转换错误。
对于 short s1 = 1; s1 += 1; 来说，+= 是 Java 语言规定的运算符，Java 编译器会对它进行特殊处理，因此可以正确编译。
Java基础
Java面试题",
Integer 和 int 的区别？,"（1）int 是 Java 的八种基本数据类型之一，而 Integer 是 Java 为 int 类型提供的封装类；
（2）int 型变量的默认值是 0，Integer 变量的默认值是 null，这一点说明 Integer 可以区分出未赋值和值为 0 的区分；
（3）Integer 变量必须实例化后才可以使用，而 int 不需要。
Integer 和 int 的比较延伸：
1、由于 Integer 变量实际上是对一个 Integer 对象的引用，所以两个通过 new 生成的 Integer 变量永远是不相等的，因为其内存地址是不同的；
2、Integer 变量和 int 变量比较时，只要两个变量的值是相等的，则结果为 true。因为包装类 Integer 和基本数据类型 int 类型进行比较时，Java 会自动拆包装类为 int，然后进行比较，实际上就是两个 int 型变量在进行比较；
3、非 new 生成的 Integer 变量和 new Integer() 生成的变量进行比较时，结果为 false。因为非 new 生成的 Integer 变量指向的是 Java 常量池中的对象，而 new Integer() 生成的变量指向堆中新建的对象，两者在内存中的地址不同；
4、对于两个非 new 生成的 Integer 对象进行比较时，如果两个变量的值在区间 [-128, 127] 之间，则比较结果为 true，否则为 false。Java 在编译 Integer i = 100 时，会编译成 Integer i = Integer.valueOf(100)，而 Integer 类型的 valueOf 的源码如下所示：
从上面的代码中可以看出：Java 对于 [-128, 127] 之间的数会进行缓存，比如：Integer i = 127，会将 127 进行缓存，下次再写 Integer j = 127 的时候，就会直接从缓存中取出，而对于这个区间之外的数就需要 new 了。
Boolean：全部缓存
Byte：全部缓存（Byte 的数值范围是 -128～127）
Character：<= 127 缓存
Short：-128 — 127 缓存
Long：-128 — 127 缓存
Integer：-128 — 127 缓存
Float：没有缓存
Doulbe：没有缓存
Java基础
Java面试题",
装箱和拆箱的区别,"自动装箱是 Java 编译器在基本数据类型和对应得包装类之间做的一个转化。比如：把 int 转化成 Integer，double 转化成 Double 等等。反之就是自动拆箱。
原始类型：boolean、char、byte、short、int、long、float、double
封装类型：Boolean、Character、Byte、Short、Integer、Long、Float、Double
Java基础
Java面试题",
switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？,"在 switch(expr 1) 中，expr1 只能是一个整数表达式或者枚举常量。而整数表达式可以是 int 基本数据类型或者 Integer 包装类型。由于，byte、short、char 都可以隐式转换为 int，所以，这些类型以及这些类型的包装类型也都是可以的。而 long 和 String 类型都不符合 switch 的语法规定，并且不能被隐式的转换为 int 类型，所以，它们不能作用于 switch 语句中。不过，需要注意的是在 JDK1.7 版本之后 switch 就可以作用在 String 上了。
Java基础
Java面试题",
16、final、finally、finalize 的区别,"final：用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、被其修饰的类不可继承；
finally：异常处理语句结构的一部分，表示总是执行；
finallize：Object类的一个方法，在垃圾回收时会调用被回收对象的finalize
Java基础
Java面试题",
== 和 equals 的区别？,"= =：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。
equals 方法：用来比较两个对象的内容是否相等。注意：equals 方法不能用于比较基本数据类型的变量。如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址（很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等）。
Java基础
Java面试题",
两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？,"两个对象的 hashCode() 相同，equals() 不一定为 true。因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等【散列冲突】。
Java基础
Java面试题",
为什么重写 equals() 就一定要重写 hashCode() 方法？,"这个问题应该是有个前提，就是你需要用到 HashMap、HashSet 等 Java 集合，用不到哈希表的话，其实仅仅重写 equals() 方法也可以。而工作中的场景是常常用到 Java 集合，所以 Java 官方建议重写 equals() 就一定要重写 hashCode() 方法。
对于对象集合的判重，如果一个集合含有 10000 个对象实例，仅仅使用 equals() 方法的话，那么对于一个对象判重就需要比较 10000 次，随着集合规模的增大，时间开销是很大的。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的 hashCode 不相同，也不再需要调用 equals() 方法，从而大大减少了 equals() 比较次数。
所以从程序实现原理上来讲的话，既需要 equals() 方法，也需要 hashCode() 方法。那么既然重写了 equals()，那么也要重写 hashCode() 方法，以保证两者之间的配合关系。
hashCode（）与equals（）的相关规定：
1、如果两个对象相等，则 hashCode 一定也是相同的；
2、两个对象相等，对两个对象分别调用 equals 方法都返回 true；
3、两个对象有相同的 hashCode 值，它们也不一定是相等的；
4、因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖；
5、hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。
Java基础
Java面试题",
& 和 && 的区别？,"Java 中 && 和 & 都是表示与的逻辑运算符，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算结果才为 true，否则为 false。
&&：有短路功能，当第一个表达式的值为 false 的时候，则不再计算第二个表达式；
&：不管第一个表达式结果是否为 true，第二个都会执行。除此之外，& 还可以用作位运算符：当 & 两边的表达式不是 Boolean 类型的时候，& 表示按位操作。
Java基础
Java面试题",
Java 中的参数传递时传值呢？还是传引用？,"Java 的参数是以值传递的形式传入方法中，而不是引用传递。
当传递方法参数类型为基本数据类型（数字以及布尔值）时，一个方法是不可能修改一个基本数据类型的参数。
当传递方法参数类型为引用数据类型时，一个方法将修改一个引用数据类型的参数所指向对象的值。即使 Java 函数在传递引用数据类型时，也只是拷贝了引用的值罢了，之所以能修改引用数据是因为它们同时指向了一个对象，但这仍然是按值调用而不是引用调用。
Java基础
Java面试题",
Java 中的 Math.round(-1.5) 等于多少？,"等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。
两个二进制数异或结果是这两个二进制数差的绝对值。表达式如下：a^b = |a-b|。
两个二进制 a 与 b 异或，即 a 和 b 两个数按位进行运算。如果对应的位相同，则为 0（相当于对应的算术相减），如果不同即为 1（相当于对应的算术相加）。由于二进制每个位只有两种状态，要么是 0，要么是 1，则按位异或操作可表达为按位相减取值相对值，再按位累加。
Java基础
Java面试题",
如何实现对象的克隆？,"（1）实现 Cloneable 接口并重写 Object 类中的 clone() 方法；
（2）实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。
Java基础
Java面试题",
深克隆和浅克隆的区别？,"（1）浅克隆：拷贝对象和原始对象的引用类型引用同一个对象。浅克隆只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅克隆。
（2）深克隆：拷贝对象和原始对象的引用类型引用不同对象。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse() 和 JSON.stringify()，但是此方法无法复制函数类型）。
补充：
深克隆的实现就是在引用类型所在的类实现 Cloneable 接口，并使用 public 访问修饰符重写 clone 方法。
Java 中定义的 clone 没有深浅之分，都是统一的调用 Object 的 clone 方法。为什么会有深克隆的概念？是由于我们在实现的过程中刻意的嵌套了 clone 方法的调用。也就是说深克隆就是在需要克隆的对象类型的类中重新实现克隆方法 clone()。
Java基础
Java面试题",
什么是 Java 的序列化，如何实现 Java 的序列化？,"对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序。从字节流创建对象的相反的过程称为反序列化。而创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化。序列化是为了解决在对象流进行读写操作时所引发的问题。
序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，只是用于标注该对象是可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个 ObjectOutputStream 对象，接着使用 ObjectOutputStream 对象的 writeObject(Object obj) 方法可以将参数为 obj 的对象写出，要恢复的话则使用输入流。
Java基础
Java面试题",
什么情况下需要序列化？,"（1）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；
（2）当你想用套接字在网络上传送对象的时候；
（3）当你想通过 RMI 传输对象的时候。
Java基础
Java面试题",
Java基础,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里： Java基础面试题阅读指南
 Java基础面试题阅读指南
Java基础",
Java基础面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 解释下什么是面向对象？面向对象和面向过程的区别？
1. 解释下什么是面向对象？面向对象和面向过程的区别？
2. 面向对象的三大特性？分别解释下？
2. 面向对象的三大特性？分别解释下？
3. JDK、JRE、JVM 三者之间的关系？
3. JDK、JRE、JVM 三者之间的关系？
4. 重载和重写的区别？
4. 重载和重写的区别？
5. Java 中是否可以重写一个 private 或者 static 方法？
5. Java 中是否可以重写一个 private 或者 static 方法？
6. 构造方法有哪些特性？
6. 构造方法有哪些特性？
7. 在 Java 中定义一个不做事且没有参数的构造方法有什么作用？
7. 在 Java 中定义一个不做事且没有参数的构造方法有什么作用？
8. Java 中创建对象的几种方式？
8. Java 中创建对象的几种方式？
9. 抽象类和接口有什么区别？
9. 抽象类和接口有什么区别？
10. 静态变量和实例变量的区别？
10. 静态变量和实例变量的区别？
11. 12、short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？
11. 12、short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？
12. Integer 和 int 的区别？
12. Integer 和 int 的区别？
13. 装箱和拆箱的区别
13. 装箱和拆箱的区别
14. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？
14. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？
15. 16、final、finally、finalize 的区别
15. 16、final、finally、finalize 的区别
16.  和 equals 的区别？
16.  和 equals 的区别？
17. 两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？
17. 两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？
18. 为什么重写 equals() 就一定要重写 hashCode() 方法？
18. 为什么重写 equals() 就一定要重写 hashCode() 方法？
19. & 和 && 的区别？
19. & 和 && 的区别？
20. Java 中的参数传递时传值呢？还是传引用？
20. Java 中的参数传递时传值呢？还是传引用？
21. Java 中的 Math.round(-1.5) 等于多少？
21. Java 中的 Math.round(-1.5) 等于多少？
22. 如何实现对象的克隆？
22. 如何实现对象的克隆？
23. 深克隆和浅克隆的区别？
23. 深克隆和浅克隆的区别？
24. 什么是 Java 的序列化，如何实现 Java 的序列化？
24. 什么是 Java 的序列化，如何实现 Java 的序列化？
25. 什么情况下需要序列化？
25. 什么情况下需要序列化？
26. Java 的泛型是如何工作的 ? 什么是类型擦除 ?
26. Java 的泛型是如何工作的 ? 什么是类型擦除 ?
27. 什么是泛型中的限定通配符和非限定通配符 ?
27. 什么是泛型中的限定通配符和非限定通配符 ?
28. List< ? extends T > 和 List < ? super T > 之间有什么区别 ?
28. List< ? extends T > 和 List < ? super T > 之间有什么区别 ?
29. Java 中的反射是什么意思？有哪些应用场景？
29. Java 中的反射是什么意思？有哪些应用场景？
30. 反射的优缺点？
30. 反射的优缺点？
31. Java 中的动态代理是什么？有哪些应用？
31. Java 中的动态代理是什么？有哪些应用？
32. 怎么实现动态代理？
32. 怎么实现动态代理？
33. static 关键字的作用？
33. static 关键字的作用？
34. super 关键字的作用？
34. super 关键字的作用？
35. finally 块中的代码什么时候被执行？
35. finally 块中的代码什么时候被执行？
36. finally 是不是一定会被执行到？
36. finally 是不是一定会被执行到？
37. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
37. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
38. try-catch-finally 中那个部分可以省略？
38. try-catch-finally 中那个部分可以省略？
39. Error 和 Exception 的区别？
39. Error 和 Exception 的区别？
40. 运行时异常与受检异常有何异同？
40. 运行时异常与受检异常有何异同？
41. throw 和 throws 的区别？
41. throw 和 throws 的区别？
42. 常见的异常类有哪些？
42. 常见的异常类有哪些？
43. 主线程可以捕获到子线程的异常吗？
43. 主线程可以捕获到子线程的异常吗？
44. 字节和字符的区别？
44. 字节和字符的区别？
45. String 为什么要设计为不可变类？
45. String 为什么要设计为不可变类？
46. String、StringBuilder、StringBuffer 的区别？
46. String、StringBuilder、StringBuffer 的区别？
47. String 字符串修改实现的原理？
47. String 字符串修改实现的原理？
48. String str = “i” 与 String str = new String(“i”) 一样吗？
48. String str = “i” 与 String str = new String(“i”) 一样吗？
49. String 类的常用方法都有那些？
49. String 类的常用方法都有那些？
50. final 修饰 StringBuffer 后还可以 append 吗？
50. final 修饰 StringBuffer 后还可以 append 吗？
51. Java 中的 IO 流的分类？说出几个你熟悉的实现类？
51. Java 中的 IO 流的分类？说出几个你熟悉的实现类？
52. 字节流和字符流有什么区别？
52. 字节流和字符流有什么区别？
53. BIO、NIO、AIO 有什么区别？
53. BIO、NIO、AIO 有什么区别？
Java基础",
20万字Java开发面试手册出炉,"对于编程学习，很多人可能学了之后，不知道自己处于哪个阶段，也不到究竟要学到哪个程度，帅地觉得，验证自己学得如何最好的面试，就是尝试去面试，而面试无非就是问你一些面试题，所以呢，帅地整理了一整套 Java 后端面试题。
当然，不仅仅包含 Java 技术栈，还有计算机网络，操作系统，MySQL 等等，并且附带了详细的答案，无论是想面试还是想看看自己学得如何，都值得一看。
这里提供两种阅读方式：PDF 阅读 和在线阅读
给大家看一下目录

总共 20 万的字数，微信搜索关注「帅地玩编程」，回复「010」，即可获取最新版的 PDF 哦，扫码直达

另外，也提供了在线阅读的模式，也就是在帅地的个人网站阅读

直达链接：https://www.iamshuaidi.com
https://www.iamshuaidi.com
Java基础
Java字符串
Java异常
Java集合
SpringMVC面试题",
字节和字符的区别？,"字节是存储容量的基本单位；
字符是数字、字母、汉字以及其他语言的各种符号；
1 字节 = 8 个二进制单位，一个字符由一个字节或多个字节的二进制单位组成。
Java字符串",
String 为什么要设计为不可变类？,"在 Java 中将 String 设计成不可变的是综合考虑到各种因素的结果。主要的原因主要有以下三点：
（1）字符串常量池的需要：字符串常量池是 Java 堆内存中一个特殊的存储区域, 当创建一个 String 对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象；
（2）允许 String 对象缓存 HashCode：Java 中 String 对象的哈希码被频繁地使用, 比如在 HashMap 等容器中。字符串不变性保证了 hash 码的唯一性，因此可以放心地进行缓存。这也是一种性能优化手段，意味着不必每次都去计算新的哈希码；
（3）String 被许多的 Java 类(库)用来当做参数，例如：网络连接地址 URL、文件路径 path、还有反射机制所需要的 String 参数等, 假若 String 不是固定不变的，将会引起各种安全隐患。
Java字符串",
String、StringBuilder、StringBuffer 的区别？,"String：用于字符串操作，属于不可变类；【补充：String 不是基本数据类型，是引用类型，底层用 char 数组实现的】
StringBuilder：与 StringBuffer 类似，都是字符串缓冲区，但线程不安全；
StringBuffer：也用于字符串操作，不同之处是 StringBuffer 属于可变类，对方法加了同步锁，线程安全
StringBuffer的补充
说明：StringBuffer 中并不是所有方法都使用了 Synchronized 修饰来实现同步：
执行效率：StringBuilder > StringBuffer > String
Java字符串",
String 字符串修改实现的原理？,"当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuilder，其次调用 StringBuilder 的 append() 方法，最后调用 StringBuilder 的 toString() 方法把结果返回。
Java字符串
Java面试题",
String str = “i” 与 String str = new String(“i”) 一样吗？,"不一样，因为内存的分配方式不一样。String str = “i” 的方式，Java 虚拟机会将其分配到常量池中；而 String str = new String(“i”) 则会被分到堆内存中。
在执行 String  str1 = “abc” 的时候，JVM 会首先检查字符串常量池中是否已经存在该字符串对象，如果已经存在，那么就不会再创建了，直接返回该字符串在字符串常量池中的内存地址；如果该字符串还不存在字符串常量池中，那么就会在字符串常量池中创建该字符串对象，然后再返回。所以在执行 String  str2 = “abc” 的时候，因为字符串常量池中已经存在“abc”字符串对象了，就不会在字符串常量池中再次创建了，所以栈内存中 str1 和 str2 的内存地址都是指向 “abc” 在字符串常量池中的位置，所以 str1 = str2 的运行结果为 true。
而在执行 String  str3 = new  String(“abc”) 的时候，JVM 会首先检查字符串常量池中是否已经存在“abc”字符串，如果已经存在，则不会在字符串常量池中再创建了；如果不存在，则就会在字符串常量池中创建 “abc” 字符串对象，然后再到堆内存中再创建一份字符串对象，把字符串常量池中的 “abc” 字符串内容拷贝到内存中的字符串对象中，然后返回堆内存中该字符串的内存地址，即栈内存中存储的地址是堆内存中对象的内存地址。String  str4 = new  String(“abc”) 是在堆内存中又创建了一个对象，所以 str 3  str4 运行的结果是 false。str1、str2、str3、str4 在内存中的存储状况如下图所示：

Java字符串",
String 类的常用方法都有那些？,"indexOf()：返回指定字符的索引。
charAt()：返回指定索引处的字符。
replace()：字符串替换。
trim()：去除字符串两端空白。
split()：分割字符串，返回一个分割后的字符串数组。
getBytes()：返回字符串的 byte 类型数组。
length()：返回字符串长度。
toLowerCase()：将字符串转成小写字母。
toUpperCase()：将字符串转成大写字符。
substring()：截取字符串。
equals()：字符串比较。
Java字符串",
final 修饰 StringBuffer 后还可以 append 吗？,"可以。final 修饰的是一个引用变量，那么这个引用始终只能指向这个对象，但是这个对象内部的属性是可以变化的。

  官方文档解释：once a final variable has been assigned, it always contains the same value. If a final variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object.

Java字符串
Java面试题",
Java字符串,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里： Java基础面试题阅读指南
 Java基础面试题阅读指南
Java字符串",
阿里巴巴Java岗开发面经汇总,"本系列将提供阿里巴巴Java岗位历年面经，所有面经都有候选人面试之后根据回忆整理而出，大家可以通过面经来复习以及看看阿里巴巴面试难度。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 【阿里巴巴】Java岗-基础平台研发工程师面经
1. 【阿里巴巴】Java岗-基础平台研发工程师面经
2. 【阿里巴巴】Java岗-非科班水硕春招
2. 【阿里巴巴】Java岗-非科班水硕春招
3. 【阿里巴巴】Java岗-热乎乎的浙江扁鹊面经
3. 【阿里巴巴】Java岗-热乎乎的浙江扁鹊面经
4. 【阿里巴巴】Java岗-五面上岸阿里天猫
4. 【阿里巴巴】Java岗-五面上岸阿里天猫
5. 【阿里巴巴】Java岗-新零售凉经
5. 【阿里巴巴】Java岗-新零售凉经
6. 【阿里巴巴】Java岗-AE部门四面(已发意向书)
6. 【阿里巴巴】Java岗-AE部门四面(已发意向书)
7. 【阿里巴巴】Java岗-后端暑期实习3面+HR面
7. 【阿里巴巴】Java岗-后端暑期实习3面+HR面
8. 【阿里巴巴】Java岗-五面阿里，终拿P7 offer
8. 【阿里巴巴】Java岗-五面阿里，终拿P7 offer
9. 【阿里巴巴】Java岗-阿里云研发
9. 【阿里巴巴】Java岗-阿里云研发
10. 【阿里巴巴】Java岗-淘宝特价版实习
10. 【阿里巴巴】Java岗-淘宝特价版实习
Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-基础平台研发工程师面经,"面试官是当时发内推邮件到我们学校的人，为人比较和蔼，全程带着笑，然后上来先问了英语成绩，唔，我是那种雅思半途而废不想考的人了，不过他问的是四六级，我就说我六级480（当时觉得考过了就没继续了）。然后他就叫我英语自我介绍，人都懵了，看了半天面经也没看到这出啊，然后硬着头皮说了，再然后就是一系列针对简历的提问了，其实有一个问题我已经被问了无数次了，就是，你给我说说你这些项目里你觉得做的最好的吧，这个之前准备过了，我就一顿balabala说，然后他问道什么就答，因为我的项目大多是课程的项目，列在简历上的也都是偏算法的，所以没给到面试官一些问到我非常技术向的问题，然后我们就愉快的把简历给聊完了，再然后他看到我写熟悉java，问了一些并发的问题，问了volatile。这个刚好看过，不过回答的也比较凌乱吧，基本就是从缓存一致性说了一下。最后他说写一道题，给我20分钟，题目是

  ​    有一根10米长的绳子，需要裁剪后卖出。每次裁剪的位置只能是整数长度的位置，如：1米、5米的位置。不同长度的绳子对应的售卖价格不同，长度从1米到10米价格分别为：1，5，8，9，10，17，17，20，24，30。现在需要找到一种最优裁剪绳子的方法（可裁剪多次或0次），使得最后卖出的价格最高。请设计一个算法找到最优的裁剪方法，并算出最高的卖出价格。

这个想了一会，心想10米不就是1+9，2+8，…等的组合么，然后比如4+6，只要4是最优，6是最优，那4+6就是最优，所以是一道比较经典的动态规划了？
然后他给了我一个网页链接，是一个阿里内部的在线IDE，比较难用，也没有代码补全，而且也有点卡，比牛客网做的讲实话是要差一点的，然后我怕我写不完，我说我可以先说思路吗，他说，没事，你先写，你说完思路就没时间了。
然后我就硬着头皮磕，最后卡点时间到了，刚好写完，一运行，在线IDE报错了，看不懂（后来在自己电脑上运行了一下，是StackOverflow），然后他说没关系，我就给他说了下我的想法，然后就是正常你还有没有什么问题，没问题面试就结束了
二面也是同一个部门的，这个面试官就更和蔼了[捂脸]，上来先聊了半天学校。然后也是问简历，对着简历问，这里大家简历都不一样我就不一一说了，个人觉得只要你能把做的每件事情都说清楚就好了。他这次基本没问到什么面经上会出现的问题，问的比较独树一帜，比如说，你有没有想过你个这产品为什么不能推广。估计是大佬的视角不一样吧。然后这次面完比较直接，说给我安排交叉面。
三面是交叉面，不是一个部门的，但是估计也是大佬，然后这次是电话面试，比较猝不及防，我都准备好电脑了，谁知道他说直接在电话说，然后这个面试官就偏技术向一点了，上来就问Linux，然后又问我，你可以说说给我说说进程线程嘛，然后因为这个问题比较广，我直接一股脑，把所有能想到的都说了一边（感谢t老师，提前在课上说了很多这些东西），然后又问了一些杂七杂八的，但是我不太记得了，因为当时的确电话面会紧张很多，然后他问我为什么不读研，这是人生一大难题哇，我就不说我怎么回答的了，这种问题因人而异。最后面试结束的时候，我问了问他对我的评价，他说我觉得你还是懂得， 就是说的很乱（我也觉得)，大概是这样，当时面完感觉不是很好，因为这个面试官是电话面的，然后也不怎么爱说话，他一安静我就觉得我说的不好，我就又拼命补充，就越说越乱。
（今天HR面的时候，最后我问了问三面的评价，HR念给我评价的时候，我觉得我还是太担心了，三面面试官的评价还是不错的哈哈）
HR面的话，就偏聊天向了，总的来说这几次面试都比较和蔼，不特别硬核，面试官更多看你给他的感觉吧
Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-非科班水硕春招,"Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-热乎乎的浙江扁鹊面经,"投了一段时间了，还以为简历被刷了，没想到五一收假后立马来了个面试电话，lz 也没想太多就直接面了，面试官还是挺好的，不懂的还耐心引导和解释部分问题，这点挺好的，面试结果说是综合整体面试情况再决定是否有下一轮面试，多半是婉拒了吧，留下了没技术的泪水.jpg，下面是记录的面经分享给牛油们，希望对大家有所帮助。
Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-五面上岸阿里天猫,"打印101~200之间的所有素数并统计个数
给一个字符串pattern，和一个字符串，返回是否匹配 abba my ha ha my
时隔19天，终于接到三面的电话，心态爆炸，阿里的面试流程简直无理吐槽。
自我介绍
本科成绩
考研成绩
项目介绍
项目中难点
项目的深层长远考虑
为什么要来天猫实习
20分钟的面试，让我等了差不多20天，也不知道怎么准备，就这么稀里糊涂的面完了，也算了了一桩心事，剩下的听天由命吧。佛了
时隔13天，接到了面试官电话，直接面
了解一下项目
都做了什么
项目时部署在公网吗，然后就说网址面试官直接登录，用测试帐号看了一下
最后聊了聊具体模块设计和实现
HR面 4.24 18点左右
北京在下雨，吃饭的路上接到hr电话，很激动
聊聊本科和研究生学习方面
项目方面
意向以及工作城市选择
可以来杭州吗？（我在北京）
有什么问题问我吗？
我问：
可以告知面试评价和评级吗？
答：不要担心，能面到HR说明评级没问题。
大概什么时候有结果呢？
答：阿里每周五下午和晚上统一发放意向书，请注意关注。
感谢
感谢一起和我在实验室奋斗的同窗，大家互相鼓励才得以坚持下来，感谢牛客给我提供这个互联网求职平台，使得我可以接触到这么多优秀的牛友，大家一起分享知识一起加油。
希望大家的努力都不被辜负，也祝所有人都能在接下来收到满意的offer
Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-新零售凉经,"Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-AE部门四面(已发意向书),"（面试没有录音，仅凭回忆记录，可能不全，仅供参考）
问项目30分钟。
操作系统：
1、操作系统都有哪些内容啊？（答：进程管理、内存管理、文件管理）
2、进程通信的方式？每种方式的应用场景？进程如何保证并发的？讲一下信号量？什么是临界区？
3、操作系统怎么进行内存管理？每种方式有什么优缺点？
4、页式存储和段式存储分别应用在什么场景下？
计算机网络：
1、http为什么说是无状态的？
2、http和https的区别？（我正准备将https的连接流程呢，面试官直接打断，下一个问题）
3、TCP和UDP有了解吗，说一下区别？
数据结构：
1、说一下排序算法有哪些？
2、讲一下归并排序？归并排序是稳定的吗？（我忘记了，回答不稳定，最后面试官细心引导，我才想明白）
数据库：
1、说一下数据库有哪些索引？索引都用在什么情况下？
2、说一下B+树？为什么B+树比B树更加矮小，查询效率更高？
3、根据索引查询的过程是什么？
最后两道题：
1、写一段代码，实现三个线程，第一个线程打印1,2,3,4，第二个线程打印5,6,7,8，第三个线程打印9,10,11,12，
然后第一个线程再去打印13,14,15,16，一直打印下去。
2、手写观察者模式
一面结束三小时就给二面了！
让我有点震惊的是，没有问技术问题，总体来说就是聊天。
1、自我介绍一下？
2、研究生阶段主要的工作任务简单说一下
3、你觉得对你影响最大的一个朋友或同学是谁？能简单介绍一下哪些方面对你有影响吗？
4、你能分享一下你觉得你最有成就的一件事吗？
5、你在项目当中有没有遇到与其他人协作方面的问题？如何解决的？
6、你能说一下你对自己的职业规划吗？怎么看待架构师？
7、我们在实际开发中用到算法的地方并不是很多，那你觉得学习算法有必要吗？为什么？
（基本就这些问题，聊天聊了有40分钟，最后二十分钟面试官给我详细介绍了一下部门的业务和面临的挑战）
第三面是本部门的HR面
1、自我介绍
2、说一下你最近做的一个项目以及你的职责？
3、项目当中有碰到过的最大的挑战是什么？
4、当小组中出现意见分歧的话，你会怎么解决？
5、你觉得你的优势有哪些？自身还有哪些需要改进的地方？
6、你的择业标准是什么，会从哪些方面进行考量？
7、目前与阿里并行的有哪些企业？有没有给了offer的？会不会把阿里当做第一选择？
剩下的就是聊聊人生，说一下自己以后的职业规划什么的。
阿里Java后端四面(30分钟）
是其他部门的面试官来交叉面，这一轮主要侧重问的是项目
1、自我介绍
2、你在项目当中主要负责哪几部分？分布式是怎么提现的？
3、你觉得你负责的部分最大的技术挑战在哪里？你是怎么解决的？有没有备选方案？
4、你用到了单机redis来实现分布式锁，那如果并发请求太多，导致redis阻塞时间太长没有反应怎么办？
5、有没有看过小组里其他同学的代码，你们如何 定义接口以及做到代码规范的？
6、你对自己未来三年的职业规划是什么样的？
Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-后端暑期实习3面+HR面,"Timeline：
4.21自主投递
4.23笔试
5.10一面
5.12二面
5.13三面
5.18hr面
5.24意向书
自我介绍
学过哪些计算机课程？哪一门你觉得学得最好？
你linux学了哪些东西？课程的框架？会用的命令？
我现在在A机器上，想要远程连接B机器，命令是什么？
文件描述符有没有听过？软链接和硬链接？
怎么去看一个文本文件的内容？
讲一下之前做过的项目，以及一些细节的具体实现
看你得了不少奖项，选一个讲讲吧？讲的美模
平时怎么debug的？
都学了java相关的哪些东西？考几个简单问题
常用的数据结构有哪些？介绍一下
了解MySQL吗？
一道sql题
除了课堂外获取知识，还有其他的学习途径吗？
之前做项目的时候，有没有和他人出现分歧的情况？你怎么处理的？
如果来实习最希望收获什么？
反问
感觉和其他一面主要考察基础知识不太一样，主要着重在简历和项目上，还问了一些综合性问题
一面面试官很好，花了不少时间给我介绍部门情况，介绍工作情况，告诉我要学习些什么
自我介绍
为什么转专业？
之前实习的工作内容？
之前实习的过程中有没有遇到什么困难？
怎么想到要去做项目一？
介绍一下项目二？
java的重写和重载有什么区别？
同一个方法，参数相同返回值不同，可以重载吗？
介绍一下JVM内存模型
有哪些垃圾回收机制？
Java有哪些锁？
你学得最多的一门课是什么？
操作系统分为几个部分？
用过哪些linux命令？
怎么在文件夹中找到最大的文件？
分布式这一块有了解吗？
分布式中的cp原理？知道业界有哪些分布式框架吗？
讲一下你知道的设计模式？
看过哪些源码？
平常看哪些书？
后面几年的职业规划？
先来个自我介绍？
学了哪些计算机课程？
数据结构方面的课程成绩怎么样？
介绍一下红黑树以及它的应用场景
线上有日志是记录ip及其访问的，想要找出当天访问量最大的ip，怎么做?
做过 JSP， Serverlet相关的吗？
打开浏览器，输入taobao.com，之后访问网页，一直到浏览器把页面渲染出来，在这个过程中发生了什么？
你刚刚讲了OSI的七层模型，那它到达服务器的时候怎么达到这个应用？这么多的进程，怎么知道是哪一个？
Java的serverlet容器你了解吗?
你有做过一些实际的练习吗？或者项目？
学习主要通过哪些方法？除了看书?
有自己做一些笔记总结之类的吗？
什么时候决定走开发这个方向的?
在这个过程中你是怎么着手去学习和准备的？
你知道分布式的哪些地方？
谈一下对自己的认识以及你的优缺点？
反问
自我介绍，请重点讲讲在工程开发中的积累
为什么选择这个岗位？
请讲一讲在java这块的积累或者说项目经历？展开讲讲
问java基础知识
锁
数据库方面做过哪些内容？
在多线程的场景下如何实现数据库增删改查？
锁的具体源码？底层实现？
智力题：九个球，红黄蓝各三个，随机放在九个盒子里，排成一排。有两种操作，打开盒子查看颜色，交换两个盒子的位置。问最快的方法使得排成“红黄蓝红黄蓝”的顺序？
接下来的职业规划？
实习时间，其他面试情况等
HR面问技术问题我是没想到的，着实有点措手不及，之前看HR面的面经都没有这样的问题，所以还是不要一味依赖面经，面试问的问题还是与个人的情况有关系的。
春招结束啦，一路下来感谢牛客上的各种分享，祝大家offer多多！
Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-五面阿里，终拿P7 offer,"有了这个共识后，我和面试官开始了第一轮电话面试。第一轮面试的时间是某天上午九点，电话面试，面试官简单的了解了一下我之前做的业务，接下来就问了我一些 Java 的基础知识，我面试后做了一下总结和记录，贴出来给大家看下：
哪些场景下，子类需要重写 equals 方法和 hashCode 方法？
描述下 HashMap get 方法的主要执行逻辑和流程；
Java 异常，什么是 checked Exception 和 unchecked Exception，举几个具体的例子；是否研究过 Spring Boot 中的异常；
ConcurrentHashMap 的特性和实现原理；
什么是分库分表，以及分库分表的具体方法和使用场景；
数据库事务的 ACID；
对于数据库基础知识，读者可以找任意一本相关入门级的数据库图书学习即可。
高级开发除了以上要求还要熟悉 高可用 MySQL 、 主从同步 、 读写分离 、 分表分库 等技术，这些技术的细节一定要清楚，它们是你成为技术专家或者高级架构的必备知识。我们在实际面试时，在讨论高可用服务服务方案时，很多面试者也会和我们讨论到这些技术，但是不少面试者只知道这些技术的大致思想，细节往往说不清楚，细节不会就意味着你的高可用方案无法落地，企业需要可以落地的方案。
这些技术我首推 《高性能 MySQL》这本书，这本书高级开发者一定要通读的 ，另外还有 2 本非常好的图书也推荐一下：一本是《 MySQL 排错指南 》，读完这本书以后，你会对整个“数据库世界”充满了清晰的认识；另外一本是《 数据库索引设计与优化 》，这本书读起来非常舒服，尤其是对于喜欢算法和数据结构的同学来说。
什么是分布式锁以及其实现原理和使用场景；
幂等性问题。
这里需要说一下，上面的面试题其实都很基础，尤其是涉及到 Java 本身的如果你是从事 Java 开发的，但是只局限于应付公司的业务代码，从来没有主动去研读一下 jdk 的一些常用类库，无论从应付面试来说，还是就你的 Java 技术栈的提高乃至技术职业生涯都是不好的，希望从事 Java 开发的读者要意识到这一点。
网络上有很多类似于 Java 面试高频知识点总结的帖子和课程，我个人觉得这些课程你可以用它作为大纲，但是千万不能只达到这些大纲要求的深度，作为 Java 开发者，jdk 的源码，尤其是常用的 Java 类的源码还是建议认真阅读一下。
第一轮技术面试结束后，我就问面试官是否通过了。面试官告诉我通过了，然后我问他下一轮的的面试会安排在什么时候。我当时告诉他希望他们尽快安排，已经有其他的公司在催我入职了（期间我已经拿到了字节的 offer）。面试官说去沟通一下。
于是当天下午大概一两点左右，一面面试官问我晚上是否有时间，给我安排第二轮技术面试，于是约了当天晚上七点。
第二轮技术面试是主管面试。原来约了晚上七点，我到了之后一面的面试官接待了我，并告知我他们主管临时有点急事，能不能把时间改到九点，或者再约。我当时想既然都来了那就等等吧，就不单独再约时间了。于是在这之前和一面的面试官又聊了一下，一面的面试官人很 nice，我们聊了很多东西。他和我说了一下后面面试的一些注意事项，告诉我二面面试官的一些情况，建议我在和他谈之前的项目时说清楚业务特点和技术重难点，并给出合理的解决方案，否则很可能被 pass 掉。最后又和我讲了一下阿里的薪酬结构和期权的一些事情，以及 HR 面试和其他公司的 HR 面试不太一样，要我认证严肃对待阿里的 HR 面试。
大约到了晚上九点，二面面试官终于来了。先和我介绍了一下他们所做的东西，最后给我出了一个场景题，让我根据他提出的场景设计一套系统，要交代清楚一共有几个子系统，如何保证高性能和高可用。在和面试官讨论中我给出了自己的设计方案，当然开始的答案并不完美，后来面试官不断给我提出新的问题，以考察我的设计能力。正常的面试结束后，面试官就我之前的项目聊了一下自己的看法。
聊了大概一个多小时后，结束了面试，我离开时，发现外面的沙发上还有一个人等待面试，汗，竞争压力真大。
第二天早上，我通过一面面试官帮我打听二面面试结果，大概中午的时候，二面面试官加我微信说面试通过了，但是三面面试官，也就是他们大部门的 leader 在深圳出差，问我是否方便视频面试，我说可以，于是就约定了第二天晚上七点的视频面试。
前一天三面的面试官给我打了个电话，然后加了我微信。第二天晚上七点，面试官准时微信视频我，打开后发现是一个胡子没刮的中年大叔，”大叔”在阳台上坐在笔记本电脑前面，然后面试就正式开始了。先让我做个自我介绍，然后就和我聊起之前的项目，在我介绍项目的过程中，时而问一些 Java 细节的东西，如多线程同步用了哪些对象，如何编码的，时而问一下框架或者架构方面的，例如如何做热备、是否使用了分布式服务，分布式服务中多个服务之间数据如何保持一致，系统的支持的最大 QPS，缓存问题、数据库的压力问题等等。
三面的技术面试并不容易，一般来说，不同公司因为业务形态，采用的技术方案不尽相同，但是不少面试官并不认同面试者公司所采用的技术方案，所以需要面试者详细的、认真的给出合理的解释，如果你对你负责的系统背后的技术方案从没进行认真的思考和反思，很容易被面试官几次连续追问弄的措手不及，或者落入面试官设置的技术圈套中。
这类面试我给读者的建议是，无论你是公司某个项目的负责人，还是你只是参与某个项目只负责其中一部分，不仅要想办法了解整个系统的结构设计，多反思你现在的结构设计，还要对关键的细节核心也要非常熟悉，把你所在的项目的一些关键细节搞清楚，千万不要只局限于自己的”一亩三分地”。
第二天早上，一面的面试官告诉我第三轮技术面试已经通过了，接下来就是 HR 面试了，但是阿里的 HR 面试与一般的人事面试不太一样，HR 在阿里有点像军团的”政委”，同时告诉我，阿里的薪资待遇现金部分不会给太多，更多的是期权，而且这些期权公司内部是明码标价的，在离职时公司会以制定的价格去回购。
当天，一个自称阿里的 HR 主管的女性给我打电话，与我约了下一轮的人事面试，具体日期记不得了，是后面几天的某个上午 10 点。
那天的 10 点，对方如约打来电话。在我以往的经历中，我觉得既然前面技术面试过了，到了 HR 面试时应该是简单的了解一下面试者的情况，然后就开始谈薪资了。然而事实并不是这样，这个 HR 先让我做了一下自我介绍，然后让我描述一下每段工作经历分别做了什么、每段工作经历时长和离职原因，还问了我诸如我工作中最受挫的事情以及最大的挑战的事情是什么，以及我的一些思想观念和价值观念。唉，感觉真的就像”政审”。聊了快一个多小时，我的心一直是绷着的，额头都出汗了。那天我的媳妇也在旁边旁听，我面试了一个多小时，她跟着紧张了一个多小时。
面试最后，同样的惯例，这个 HR 问我有什么想问的，我当时脑子一发热，问了一句套话：您觉得在 IT 公司，HR 应该扮演什么样的角色？唉，就是这个问题差点，让我”万劫不复”了。这个 HR 显然很老道，并没有直接回答我的问题，而是反问我怎么看待 HR 工作职责的，我当时说，人力资源部门应该为职能部门做好后勤工作。面试官听我这么说，立刻表示反对，开始给我说阿里的 HR 如何如何，作用如何如何，接着我就脑袋嗡嗡的又听了她说了一会儿。最终我们结束了这次的面试。
面试过程中，其实我一直以为会和我谈薪资待遇，然后从开始到结束并没有谈到，因为不确定我是否过了这个面试， 也没有去问。
第二天早上，我再次接到这个 HR 的电话，告知我所有的面试都通过了，接下来和我谈下薪资待遇。经过他们的综合考察和评定，给我的职级是 P7（技术专家），给我价值 80 W的期权，分三年拿完，第一年给 25%，第二年再给 25%，第三年给 50%，但是现金部分最多只能给到 32k（月薪），保底薪资是 14 薪。于是我问她，我少要点期权，月薪能否加一点，她说做不到；然后我又问她每股期权如果离职公司的回收价格是明确的吗？她也说不明确。于是，我又和她说，我说你这个薪资水平和我上上家的待遇差不多。她也不接我我的话茬，说这是公司的规定，况且你来阿里也不是为了钱。我竟然无言以对。后来，我就说我拿了某独角兽公司的 offer，人家年薪都给到了七十多万，你这比人家低的太多了，她又说，这家公司给的薪水本来就比市场平均水平要高很多。
谈到这里，我其实已经没多少耐心继续谈下去了。我朝思暮想，诚惶诚恐想进的阿里，给出的待遇竟然如此。唉。大家出来工作，不是为了钱，为了啥？而且整个面试的过程也是比较磨人的，最终给出的薪资水平毫无诚意。此时，我实在不想继续谈下去了，于是我对她说，要不这样吧，我考虑一天，明天这个时候给你打电话告诉你结果，她说可以，并说第二天会打给我。
最终结果
综合考虑下来，最终我还是决定放弃阿里的 offer。第二天当那个 HR 打来电话时，我直接开门见山的说，我选择放弃这个 offer，她听了之后说了一句尊重我的选择，然后简单的寒暄了几句就挂了电话。
总结
我这个人，非科班出身，我深知有一份大厂工作经验的重要性。所以自毕业以来，一直想着有一天能去 BAT 其中之一工作，然而造化弄人，总因为这样那样的原因，一直未能得偿所愿。在 2019 年整整一年，创业付出大量时间和心血之后，决心还是告别小公司，再去大厂历练一下。于是经过认真的准备，先后面试了腾讯、饿了么、阿里蚂蚁金服、字节跳动等大厂，其中尤为亲睐阿里的工作机会，当然由于早些年面试大厂受挫，心里存在一点的恐惧心理，但这次之后再也不存在任何恐惧之心了，说白了，也不过如此而已。
当然，我这里并不是说阿里不好，阿里是一家伟大的公司，给我们的生活带来了很多的益处。但是有些事情，如同两个人的结合一样，勉强不来的。一家企业在发展的过程中总会存在很多问题，如果你能忍受这些问题，你可以选择她，如果你容忍不了，你可以不选择她。感谢帮助我那么多的阿里一面面试官。
我把这段经历写出来分享给大家，并不是想说明我有多强，是希望给想面试阿里的同学一点启发和帮助。入职大厂不仅需要技术实力，还需要一点点运气和策略。
Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-阿里云研发,"1.自我介绍
2.实习的项目，抛了一系列的提高性能的问题，针对项目提问（实习项目略隐私，不列出来了）
3.发的论文，论文用到的算法
4.你认为算法与业务之间有什么样的关系
5.浏览器输入URL发生了什么，讲出所有知道的内容
算法题
6.非递归遍历二叉树
7.查找数组的中间元素
8.问问题
1.自我介绍
2.Java的并发方式
3.synchronized和lock的区别
4.Java内存模型及GC算法
5.你理解的线程安全
6.Java源码中的HashMap、HashTable、ArrayList及LinkedList
7.解决Hash冲突的方法及Java8对链地址法有何优化
8.加载器双亲委派模型及破坏
9.死锁的原因及预防
10.操作系统的内存管理机制
11.进程和线程的区别
12.TCP和UDP区别
13.TCP如何保证可靠性，拥塞控制如何实现
14.用过哪些数据库，支持事务的数据库的四个特性，数据库的四个隔离级别
15.讲下跳表怎么实现的
16.哈夫曼编码是怎么回事
1.自我介绍
2.实习的项目
3.依然是：输入URL浏览器发生了什么
4.DNS解析的域名，你直接去ping，能成功吗，它是一个web server吗
5.说说长连接是怎么回事，使用长连接有什么影响
6.个人的职业规划
7.除了项目之外，有了解过其他的开源技术吗
8.NginX如何做负载均衡
9.常见的负载均衡算法有哪些
10.一致性哈希的一致性是什么意思
11.一致性哈希是如何做哈希的
12.自己最常用的数据结构是什么
13.讲讲算法及数据结构在实习项目中的用处
14.常见的排序算法及其复杂度
15.讲讲O(nlogn）复杂度的算法在实际工程中的用处
16.问问题
1.自我介绍
2.实习学到了什么
3.自己的职业规划
4.评价一下腾讯的技术氛围
5.实习中有没有什么不足，现在弥补了吗
6.对阿里技术氛围有什么样的理解，用过哪些阿里的开源库
7.给你一千万创业，你怎么分配资金，自己承担什么样的角色（CEO?CTO?COO?）
8.蚂蚁金服最后待offer给你转推荐，你清楚原因吗（岗位不符合预期）
9.加上之前的面试和蚂蚁的面试，你面试与自己预期相比表现怎么样
10.期待的工作地点
11.问问题
Java开发岗
阿里巴巴面试

ㅤ普通",
【阿里巴巴】Java岗-淘宝特价版实习,"1.简单介绍下自己的学习情况，怎么学习的，有哪些技巧吗，课余时间怎么安排的
3.说说的自己的项目（开始聊项目）
3.说下对java继承、封装、多态的理解
4.谈到了设计模式，说下常见的设计模式
5.工厂模式详细介绍一下
6.java中常见的集合类
7.ArrayList和LinkedList的区别
8.如果要保证线程安全该怎么做
9.说一下hashmap和concurrenthashmap
10.java中还有那些线程安全的集合
11.hashtable和concurrenthashmap哪个效率高
12.了解多线程吗?怎么实现，有没有用到代理模式？
13.了解线程池吗？
14.简单说下jvm和jmm
15.你知道的数据结构有哪些
16.说下你对红黑树了解哪些
17.你了解过那些中间件呢（redis和RabbitMQ）
18.分别是做什么的呢
19.假设此时有大量无效请求，redis中找不到，直接去查数据库，导致数据库负载上升，该怎么办
20.然后开始聊项目，聊学习，聊在学校的经历
二面是p9面，感觉一面更重基础，二面明显有深度
1.我看你的项目有用到了算法，用的什么算法，怎么用的呢
2.有发表过论文吗？哪个期刊？第几作者
3.论文具体是哪块呢？你们做了什么改进
4.简单说说你对神经网络的理解
5.你现在用那个版本的jdk（答8和15）
6.你了解过这两个版本的jdk有什么区别吗
7.mysql数据库引擎有哪些？之间又有什么区别
8.可以说下数据库范式吗？
9.回表了解过吗？
10.索引为什么快？所以i你的数据结构（答B+，随之又问还有吗？）
11.如果让你给B+树下一个定义，你怎么下？
12.说一下数据库隔离级别
13.说一下脏读和幻读
14.可以简单说一下http吗
15.http1.0和http2.0的区别
16.concurrenthashmap说一下，它是如何保证线程安全的？
17.是如何保证线程安全的？
18.简单说下多线程和线程池
19.我看你学习还可以，平时怎么规划呢
20.身为一个本科生，是如何进入到研究生的实验室的？
21.考研吗？为什么不考？
接到消息二面已过。希望能够拿到实习的offer吧
Java开发岗
阿里巴巴面试

ㅤ普通",
美团Java岗开发面经汇总,"本系列将提供美团Java岗位历年面经，所有面经都有候选人面试之后根据回忆整理而出，大家可以通过面经来复习以及看看美团面试难度。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 【美团】Java岗-四面美团，收割 offer
1. 【美团】Java岗-四面美团，收割 offer
2. 【美团】Java岗-外卖配送事业部实习面经
2. 【美团】Java岗-外卖配送事业部实习面经
3. 【美团】Java岗-一份美团外卖的隔夜烤面筋
3. 【美团】Java岗-一份美团外卖的隔夜烤面筋
4. 【美团】Java岗-优选后端开发一，二面+HR面
4. 【美团】Java岗-优选后端开发一，二面+HR面
5. 【美团】Java岗-点评社招凉筋
5. 【美团】Java岗-点评社招凉筋
Java开发岗
美团面试

ㅤ普通",
【美团】Java岗-四面美团，收割 offer,"美团我是在拉勾网上投的简历，之前也投过一次，简历都没通过删选，后来让学姐帮我改了一下简历，重新投另一个部门，获得了面试机会。
10月23日中午HR打电话过来预约了下午4点半面试，说会在线写代码，让我准备好网络环境。结果5点半还没打电话过来，被放鸽子。与hr重新沟通过后，确定下周一下午再面，可是跟hr沟通预约这一套貌似在美团并没有什么用。
晚7点，因为想到下周一才面试，我刚准备出去打个羽毛球，北京的电话就来了。面试官各种抱歉，说开会拖延了。
1、自我介绍
说了很多遍了，很流畅捡重点介绍完。
2、问我数据结构算法好不好
挺好的（其实心还是有点虚，不过最近刷了很多题也只能壮着胆子充胖子了）
3、找到单链表的三等分点，如果单链表是有环的呢
用快慢指针，一个走一步，一个走三步。如果有环，先判断环在哪，找最后一个节点，然后用之前的无环的做法
4、讲一下项目的架构
我重点讲了MVC
5、说一下你熟悉的设计模式
我重点讲了单例、工厂方法、***
5、有没有配置过服务器啥啥啥
这个我真不知道，都没听过呢，只能诚实说没有，毕竟都没法扯。
一面挺匆忙的，我估计面试官刚开完会还没吃饭呢。他说让我等，可能再找一个同事面我，可能就直接告诉我结果了。从一面面试官的声音和口吻，我判断他一定是个部门老大，问的设计偏多，后面hr告诉我他就是我要去的部门的老大。哈哈。
美团技术二面60分钟，详细问答
面完一面正准备出去打羽毛球，北京的电话又来了。（注定这周五参加不了球队活动了！）
跟一面比起来，二面面试官的声音听起来就像是搞技术开发的，果不其然，一个小时的纯技术电话面试！面的特别全面！
1、Spring：有没有用过Spring，Spring IOC、AOP机制与实现，Spring MVC
其实我挺不想被问到Spring的细节的，框架这些我都没有复习不太记得了。所以我对面试官说Spring里面的一些比较重要的机制我理解的还不错，然后我用一个实际的例子把我对IOC、AOP理解讲了一下，他听了说对，理解的不错（难得遇到一个边面试边能给反馈的面试官，好开心）
Spring MVC其实我用过，我就对面试官讲了我的项目中用到的Servlet，jsp和javabean实现的MVC，以及MVC各个模块职责以及每个模块是怎么联系到一起的，最后我补充了一句我想SpringMVC的思想其实跟这个是一样的（他说对的，嘿嘿有反馈真好）
2、多线程：怎么实现线程安全，各个实现方法有什么区别，volatile关键字的使用，可重入锁的理解，Synchronized是不是可重入锁
这里我就主要讲了Synchronized关键字，还有并发包下面的一些锁，以及各自的优缺点和区别。volatile关键字我主要从可见性、原子性和禁止JVM指令重排序三个方面讲的，再讲了一下我在多线程的单例模式double-check中用到volatile关键字禁止JVM指令重排优化。
3、集合： HashMap底层实现，怎么实现HashMap线程安全
我讲了一下HashMap底层是数组加单链表实现，Node内部类，add的过程，Hash冲突解决办法，扩容，三种集合视图。HashMap线程安全的实现方式主要讲了HashTable、ConcurrentHashMap以及Collections中的静态方法SynchronizedMap可以对HashMap进行封装。以及这三种方式的区别，效率表现。
4、JVM内存管理，GC算法，HotSpot里面的垃圾回收器、类加载
JVM内存主要分为五个区，哪些是线程共享的，哪些是线程独享的，每个区存放什么。GC方面：怎么判断哪些对象需要被GC，GC的方法，Minor GC与Full GC。HotSpot GC算法以及7种垃圾回收期，主要讲了CMS和G1收集器。类加载：类加载的过程，Bootstrap classloader-ExtClassloader-AppClassloader，父类委托机制。
5、进程和线程的区别
从调度、并发性、拥有的资源和系统开销四个方面回答的。
6、HTTP有没有状态，我说无状态，怎么解决HTTP无状态 怎么解决HTTP无状态其实就是怎么进行会话跟踪，有四种方法：URL重写、隐藏表单域、Cookie、Session。
7、Java IO，NIO，Java中有没有实现异步IO
Java IO实现的是同步阻塞，它是怎么实现同步阻塞的。我拿了read()方法举例来讲的。NIO实现的是同步非阻塞，我详细讲了一下Selector中的select()方***询说明它是如何实现多路复用IO的。然后对比了一下他们的效率。面试官可能看我对这一块比较了解，又继续问我Java中有没有实现异步IO，我感觉好像没有，但面试官说有，让我想想，其实这里我并不清楚啦，所以我就对面试官讲了一下我对Unix中异步IO模型的理解，然后说至于Java里面有没有我真的不太清楚。（他居然笑了！说你理解是对的，Java里面有没有不重要！哈哈）
8、前端会不会，Ajax是什么，Ajax实现原理
前端我只是会用一些js而已，用过jquery框架，问我Ajax全称是啥，我猜是异步的js和xml。Ajax实现原理其实我也不懂，我就只简单讲了一下它通过XMLHttpRequest对象进行异步查询，Ajax引擎在客户端运行，减少了服务器工作量。
9、让我设计一个线程池
因为我简历中有写到我对多线程、并发这一块理解比较好。所以他老问这方面的题。这个问题因为我之前看过ThreadPoolExecutor的源代码，所以我就仿照那个类的设计思路来想的，详细讲了一下核心池、创建线程可以用工厂方法模式来进行设计、线程池状态、阻塞队列、拒绝策略这几个方面。设计的还算比较周全。
10、讲几个设计模式，哪些地方用到了，为什么要用
单例模式，jdk中的getRuntime()；工厂方法模式，ThreadPoolExcutor用到ThreadFactory；观察者模式：java.util包下面的Observable和Observer。最后主要讲了一下工厂方法模式的使用场景。
11、Mysql优化、索引的实现
我从数据库设计优化和查询优化两方面讲的。索引B+树实现，InnoDB和MyISAM主键索引的实现区别，一个聚集一个非聚集。
12、事务的隔离级别
四种隔离级别，可能会出现哪些异常，mysql中默认级别。
13、有没有用过Hibernate、mybatis、git
这个简单讲一下就好，分别是干什么的
14、Linux
我说这个本科学过，但是很久没用，命令忘光了。他说没事，考你几个简单的：cd、ls、dir（真的是简单的）
15、算法题
从10万个数中找最小的10个，时间复杂度分析（最大堆，考虑内存）
从一个有正有负数组中找连续子数组的最大和，时间复杂度分析（动态规划）
满二叉树第i层有多少个节点，n层的满二叉树共有多少个节点
终于到我提问环节了
1、你们是什么部门（他说是核心部门，大数据研发）
2、我对高并发和负载均衡挺有兴趣的，但是我平时在学校也没有这个环境让我在这方面有所体验，那你建议我目前可以怎么学呢（他说这确实是不太好学，只能看些理论和别人的博客，以后工作中才能慢慢学）
3、中间件具体是做什么的，是解决高并发和负载均衡吗（他说差不多是的，然后他说我们这个部门不是中间件，是大数据部门啊，我说恩我知道）
最后没啥问题了，他让我保持电话畅通。
这一面面完，口干舌燥，我一度怀疑他可能不知道我是在应聘实习生的岗位。有太多要总结的了，放在总结的地方一起讲吧。
面试官说是他是另外一个部门的，需要进行交叉面试。
1、MySql优化
2、说下项目做了些什么，架构之类的
3、在collabedit上在线写代码，题目很简单是编程之美上的原题，一个有序的整数数组，输出两个数，使它们的和为某个给定的值。之前做过很快写好，然后给他讲思路。他继续问如果数组无序怎么办，先排序。
4、两个文件，每个文件中都有若干个url，找出两个文件中相同的url（用HashMap）
这一面挺简单的，只是增加之前面试没有过的在线写代码环节，collabedit后来我才了解，像***一些互联网公司远程面试都会用这个在线编辑器写代码，就是文本文档写，没有提示，不能编译运行，跟白板写一样。平时练练手就好。
三面面试官说他那就是终面，说我过了等hr联系我。万万没想到半小时后的hr面居然也是技术。
1、自我介绍，都四面了还自我介绍？！我还以为是单纯的hr面，所以介绍的都是我的性格和生活方面的，结果并不是。
2、问项目，问的特别特别细，技术细节，还有遇到什么问题，怎么解决的，做项目有没有人带，怎么跟别人沟通的。
3、数据库优化，如果数据库一个表特别大怎么办 数据库优化我就讲了之前讲过很多遍的点，他问一个表特别大怎么办：大表分小表，怎么实现：使用分区表
4、问研究生的科研题目，为什么选这个题，看了一些什么论文（细到问我那些论文是发表在什么期刊上的，作者是哪所学校的），为什么要选这个算法，怎么优化的，实验结果怎么跟别人作对比的，为什么比别人的算法好（一个个问题不断砸过来，我猜我说的那些专业名词他应该不太懂，只是判断一下是不是我做的而已。。）
5、确定实习时间 这一面确实让我感到有压迫感，项目是本科做的，挺久了，一些技术细节上也没太总结，所以问细了我只能连想带编，嘿嘿。科研方面倒还好，上个学期都在弄这个，一些算法的实现和改进、对比都还记得比较清楚，回答的挺流畅的，可能这真的就是技术型的hr面吧。
最后，思考两个问题
你觉得美团的面经难度怎么样，可以答出多少？
美团之前陷入裁员的风潮，你看好美团的发展吗？
欢迎下方留言写出你的观点。
Java开发岗
美团面试

ㅤ普通",
【美团】Java岗-外卖配送事业部实习面经,"实习岗位我自己选的机器学习，因为自己论文主要做的是运筹优化的，所以简历的研究方向是运筹优化，因此面试的主要内容也就是跟优化相关的内容。
本人 论文CCF B 两篇 一篇 EI，目前一篇CCF A的论文在投
面试官就是我的实习上级主管
1.自我介绍
2.PSO跟SA的区别、PSO跟DE的区别 （我有一篇跟PSO有关的CCF B的论文）
3.代码
[4,5,6,1,2,3 ] 找到两段有序数列的分割点，先说了个顺序查找 O(N) 然后说了个二分查找 O（logN）并实现
聊天： 为啥不读博、家那里的、实习时间
1.自我介绍，论文，项目
2.java Map有哪些实现，hashmap 复杂度 最坏情况。
3.如何防止优化过程陷入局部最优？
我拿tabu search 以及 ACO with Tabu 为例解释了下防止陷入局部最优的思想，平衡两个E， exploration and exploitation
4.为外卖配送系统建模，说一下这个VRP模型的特点
多目标、多约束（capacity、time window ..）
5.代码 实现Math.sqrt（）
二分法
牛顿迭代法
其实可以当做一个优化问题来做，泰勒展开的一阶或者二阶逼近真实值
等了挺久的 以为都凉了呢
早晨9点刚过就接到了面试官的电话，说问题不复杂，我就在走廊电话面了起来
1.没有自我介绍，直接就问了点论文的算法，讲解了一边自己论文提出的techniques
2.实习时间
3.最近在做的事情
这个问题就体现出平时刷论文的重要性了，把最近follow的一些顶刊论文介绍一下，把自己的理解以及想法大胆说出来很重要。
当天午休，HR小姐姐就打电话过来确认时间和报酬了。
Java开发岗
美团面试

ㅤ普通",
【美团】Java岗-一份美团外卖的隔夜烤面筋,"lz 还是从 3 月份投递的美团，早就以为人招满了，没抱希望了，没想到昨天下午突然接到了一个山东的电话，当时正在给手机贴膜，吓得我都贴歪了，暴风哭泣.jpg，然后就约了一个半小时后开始面试，这次面试主要是根据简历来发问的，面试体验也挺好的，面试官会说清楚问题的条件之类的，然后根据你的回答来继续发问（真祸从口出），每当我回答完后，面试官总喜欢说了解了解，跟滴滴的面试官有的一拼，仿佛有种被摸透了的感觉(摊手.jpg),下面是我记录的面经，分享一下。
自我介绍
介绍下头条资讯网站的数据库表的设计，这个网站一共有几张表？
image 字段存的是一张图片吗？你这个上传的图片放在另外一个位置？
comment_count 字段是指对文章评论人数的统计是吗？它是放在评论表里面吗？
评论功能是只支持罗列型的评论是吧？比如说用户 A 给某一条新闻评论，然后支持用户 B 能对 A 的评论进行回复吗？
比如说 news 表有建索引吗？或者说项目中有用到索引吗？
简单说一下对索引的理解，或者说为什么数据库要有索引
了解 MySQL 中有哪些常用的索引引擎吗？
了解 Innodb 和 MyISAM 的差别吗？
除开使用 B+ 树实现的索引，还了解其他数据结构实现的索引吗？
详细说一下哈希索引和 B+ 树索引的区别
哈希索引不支持范围查询，对吧？
项目中封装用户信息的目的是什么？
项目中的拦截器是用的 Spring 的一个特性吗？
这里是需要认证用户相关的合法性是吗？
这个拦截器其实是一个 Spring AOP 思想的应用，简单介绍下 Spring AOP
Spring 已经用一些 Controller 支持了业务逻辑，为什么还要有 AOP 的存在？
为什么用 ThreadLocal 类来封装用户信息，不能用一些简单的类来实现你这个功能吗？
项目中有用到多线程吗？
简化了后续开发的成本是指通过拦截器简化了后续开发成本吗？
具体是什么功能需要异步化？
了解其他的消息中间件吗？
简单说下 Redis 的底层数据结构
简单说下 JVM 的内存模型
说一下 Java 虚拟机的类加载机制
Java jdk 中会有自己实现的一些类，比如 Integer 类，假设自己开发时也想开发一个同名的类，此时在类的加载过程中，JVM 是如何确定你使用的是哪一个类？
JVM 中可以管理对象，对象是有生命周期的，那么JVM 是如何确定一个对象是不是有引用的？
了解 JVM 的垃圾回收算法吗？
了解 JDK 1.8 的垃圾回收机制吗？
（从这里开始面试官开始根据简历随机发问了，摊手.jpg）
解释下为什么 TCP 创建连接时只需要 3 次握手，而释放连接时需要 4 次挥手？
了解跟 MyBatis 类似的一些框架吗？
MyBatis 中其实是有数据库连接池的，那么为什么要有数据库连接池？为什么不可以来一个我就创建一个 JDBC 连接？
MyBatis 支持事务吗？
看你简历写阅读过部分 JDK 源码，阅读过哪些源码？
说一下 ArrayList 和 LinkedList 的区别
有看过一些并发的集合吗？ 答：ConcurrentHashmap
你刚才说到了锁，为什么要在并发的时候使用锁这个东西呢？
在 ConcurrentHashmap 里面是如何实现锁这个机制的呢？
我们都知道 synchronized 和 cas 都是原生的或者说 jdk 自己支持的锁的机制，那你了解过一些其他实现并发包的机制吗？例如 Lock 框架
刚才提到锁，肯定存在一些异常场景，比如说死锁，那么你了解死锁避免的一些方法吗？
Java开发岗
美团面试

ㅤ普通",
【美团】Java岗-优选后端开发一，二面+HR面,"美团效率真的超高，8.8号美团笔试，ac3道。过了好久才收到面试，一度以为凉了，面试流程很快，一周不道。一面是我面试最久的一次了，整整两个小时，面试官面到后面笔记本电脑没电了，又打电话问了我两个操作系统的知识，一面总体是常见八股，无深入。二面面试官问的深入一些，很多问题答的不好，以为凉了。今天接到HR面，HR说面试通过了，一周能收到意向。太好了，感谢！
8.17 号15：00-17：05
1.算法题：LRU
2.项目介绍
3.项目中如何实现单点登录
4.项目中的分布式锁如何实现的
5.用过redission吗
6.电商系统一般有那几块服务
7.JAVA的三大特性
8.JVM内存模型
9.JVM内存结构
10.堆里面可以分代，还可以使用什么区分（G1中分region）
11.可以手动GC吗
12.new一个会放在哪个区
13.搜索树和红黑树对比
14.map接口下的类
15.JAVA里锁的区别
16.死锁解决办法及监测方法
17.mysql创建一个表需要注意什么
18.mysql的语句优化
19.TCP三次握手
20.操作系统段页式内存管理的寻址
21.写代码时候前应该如何思考
8.20号19：00-20：00
1.项目中下单和扣库存分布式任务怎么保证的
2.java hashcode和equals方法为什么需要两个一起重写
3.说一下collections下的接口以及队列常用方法
4.说一下map下的子类，为什么需要linkedhashmap 以及treemap的应用场景
5.jvm常用的垃圾回收器，以及新生代和老年代垃圾回收器的不同
6.为什么新生代用标记复制算法
7.中途一个算法题:有序数组第一个出现的目标数字的下标（二分法寻找左边界）
8.操场系统为什么有内核态和用户态
9.说一下aqs是怎么阻塞线程的
10.开启线程的方法
11.mysql的基本组成单元
12.mysql底层结构和隔离基本
13.线程中的异常如何处理
14.为什么数据库需要意向锁
8.23号 17：00-17：30
1.自我介绍
2.大学里最喜欢的科目和感觉比较难的科目，为什么觉得难
3.所做的项目遇到的难点，如何克服
4.大学里参加的比赛
5.最近学习的书
6.自己意向的公司
7.比较注重公司的什么特点
8.学习路线
9.未来发展规划
10.反问环节:新人培训，入职后能否换城市
Java开发岗
美团面试

ㅤ普通",
【美团】Java岗-点评社招凉筋,"有遇到过内存泄漏吗？你们是怎么解决的？这个前阵子确实遇到过一次，还算运气比较好。
java的基本类型有哪几个？String是不是java的基本类型？String为什么要是final类型的？
反射机制的底层实现是什么？动态呢？动态的实现原理？
hashmap了解吗？说一下hashmap相关的一些东西？
hashmap是线程安全的吗？为什么是线程安全的？
concureenthashmap了解吗？他是如何实现线程安全的？你刚才说1.8基于cas？cas的ABA问题怎么解决？
说一下JVM的线程模型？这些区域都分别是干啥用的？
java线程模型和jvm线程模型注意区分、总结下，网上很多文章都是错的。
说一下java类加载器的工作机制？类加载在那个区域进行的？
说一下java的线程模型？violate了解吗？他的原理是什么？violate是线程安全的吗？为什么不是？
保证线程安全的解决方法有哪些？说一说读写锁吧，读写锁的读
数据库的索引有哪几种？为什么要用B+树来做索引？
组合索引和几个单个的索引有什么区别？数据库的大表查询优化了解吗？
MVCC机制了解不？MVCC机制有什么问题？怎么去解决这个问题？
mysql慢语句调优做过吗？说说你是怎么做的？
redis了解吗？你说说怎么用redis实现分布式锁？
spring中Bean的作用域，springMVC的controller是线程安全的吗？怎么去保证线程安全呢？
消息队列有用过吗？说说你怎么用的？你这么用感觉不大对吧。。大写的尴尬。。
计算机网络了解吗？说一说TCP三次握手和四次挥手吧，感觉这个真的是计算机网络必考知识点啊，每次问到计算机网络都会问这个。
time_wait状态产生的原因是什么？，有什么危害？可以如何避免？
leetcode153. 寻找旋转排序数组中的最小值
假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
请找出其中最小的元素。
你可以假设数组中不存在重复元素。
示例1:
输入: [3,4,5,1,2]
输出: 1
示例2:
输入: [4,5,6,7,0,1,2]
输出: 0
你手里有哪些offer了？最快什么时候能入职呢？还有什么问题想问的？然后说会有hr联系你，第二天就接到了hr约二面时间的通知。
总结下来，面试问的东西还是挺宽的，而且问的很细，一个知识点基本都是问到答不上来为止。还是有很多东西需要加强？在美团的面试中还是学到了一些东西。
首先还是问项目。问的比较细，比较全。
String，StringBuffer，StringBuilder的区别，为什么String是不可变的，StringBuffer和StringBuilder哪个是线程安全的，他们分别适用于什么场景。
java类加载过程是怎么样的，说一下volatile。
并发包了解吗？假如几个线程之间相互等待，可以用哪个并发类来实现，他的原理是什么？
数据库慢查询优化了解哪些？说了很多，面试官说假如这些都已经做好了还是很慢怎么办？最后不清楚问了下面试官，面试官主要想了解数据库分区的知识。
说一下spring容器的启动过程？
讲一下分布式锁，基于zookeeper实现和redis实现在性能上有什么差异？
kafka如何保证不丢消息又不会重复消费。了解大数据相关的一些技术吗？
最后写了道题，leetcode55. 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例1:
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
示例2:
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
最快什么时候能过来？有什么问题想问的？然后说后面有hr再和你联系。
1.面试官首先问了很多简历中的一些基本信息.画一下你这个项目与哪些工程交互，它在你们的产品中处于什么样一个位置
2.画一下你们这个项目的架构图，挑一个你觉得比较难的业务场景来讲一下，
3.你们这个项目中都遇到了哪些问题呢？说说你们最后都怎么解决的
写了一段代码，问这个代码最后输出什么？申请多大的内存空间，都在什么位置申请的
public class Test {
}
4.hashmap了解吗？他的set和get的时间复杂度是多少？为什么是O(1),说下详细过程，hashmap是线程安全的吗？
5.Jvm了解吗？jvm中哪些可以作为垃圾回收的gcroot?为什么呢？
6.什么时候能过来上班？然后就说等会hr面。
问了下基本情况，什么时候能过来，为什么想换工作？在上家的绩效和薪水情况，期望工资是多少
Java开发岗
美团C++开发面经
美团面试

ㅤ普通",
滴滴Java岗开发面经汇总,"本系列将提供滴滴Java岗位历年面经，所有面经都有候选人面试之后根据回忆整理而出，大家可以通过面经来复习以及看看滴滴面试难度。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接。
不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 【滴滴】Java岗-一天高效率面三轮
1. 【滴滴】Java岗-一天高效率面三轮
2. 【滴滴】Java岗-后端实习面筋分享
2. 【滴滴】Java岗-后端实习面筋分享
3. 【滴滴】Java岗-提前批(offer get!)
3. 【滴滴】Java岗-提前批(offer get!)
4. 【滴滴】Java岗-实习生一二面面经(已oc)
4. 【滴滴】Java岗-实习生一二面面经(已oc)
5. 【滴滴】Java岗-差点被赛码网搞崩心态
5. 【滴滴】Java岗-差点被赛码网搞崩心态
Java开发岗
滴滴面试

ㅤ普通",
【滴滴】Java岗-一天高效率面三轮,"大概记录一下，因为滴滴三面同一天，太难了。我觉得不记录一下对不起我饿着肚子不午休换来的面试。
早上11点一面，40min，之后直接二面通知，12点二面，又40min，之后1点三面，哭哭，饿着肚子，顶着困意，面试官还迟到了半个小时。最后三面一个点。但是三轮面试官人都挺好的，很有耐心。
一面偏向于自由发挥（也可能是我太自由了）
写个简单的二叉树中序遍历
介绍一下项目，讲一下业务流程
讲一下JVM的了解（从内存结构说到类加载说到垃圾回收，疯狂背课文）
讲一下mybatis使用遇到的问题
说一下mysql的了解（感觉又背了快七八分钟吧）
讲一下线程池的了解（再次吟唱）
平常通过什么途径学习的java，需要学习一项新技术你是什么样的思路
怎么和同事进行一个项目的推进
面试官总结：基础不错，学习能力也ok，项目没有落地，可以接受
二面偏向考察逻辑了，大多数是设计类的问题
讲一下项目吧
java的基础（三大特性）
如果让你抽象一个面试，怎么抽象（先答的抽象面试官和候选人，后来让抽象面试的接口）
如何设计让同一个面试官的面试时间不会冲突？（加锁，问还有什么方案，线程池？）
为什么需要线程安全？会出现哪些问题？
介绍一下自己平常有总结的类图？（大概就是包、类的继承关系吧）
如何实现一个扑克牌的洗牌的功能？
如何实现的查询某一门科目班级的分数情况，要求有序（一开始说mysql，不让用，要对象实现，成员变量和排序吧）
讲一下快排的思路
内部类都有哪些？有什么好处？什么场景下使用
函数式接口了解吗？讲一下，有什么好处
如何设计一个电梯的调度系统（尴尬，全程瞎扯，面试官不满意，说我可能对题意不是很清楚，最后就算了）
面试官总结：对于已经学过的东西掌握不错，java抽象也可以，学过的数据结构和算法也能够有意识的去应用，但是对于实际问题的剖析找不到切入点和重点，解决问题的思路有待加强，但问题不大。
偏实际需求了，然后被吊打
说一下项目吧（一个烂大街的秒杀被要求讲三遍，我是崩溃的），讲一讲在其中主要的收获
如何解决mysql访问量大的问题
行锁和表锁平常是怎么使用的
讲一下线程同步的语义？（忘记怎么说了，最后问的就是哪些方法线程同步）
大概讲一下各个语义是怎么实现的
线程安全大概讲一下，可能出现什么问题，从jvm层面来说呢？（堆）
一个2GB的数据表，如何去掉重复的数据，或者可能重复的数据，需要考虑哪些问题？（瞎扯+不会）
一个百万条的日志记录，如何从中找出排名前4的用户（说的的滴滴司机接单量）（瞎扯+不会）
k个一组反转链表（力扣25）（写了半天，写个空指针异常，面试官问要不要放弃，想了想，快一个小时了，累了，放弃了，面试官嫌我代码写的乱，让讲一下）
面试官总结：还是挺聪明的（表面安慰一下），但是实际业务方面写的太少了，光看是没有用的。业务方面的话多加强一下吧（实际直接劝退）
自己总结：一面感觉还行，二面感觉勉勉强强，三面直接拉闸。但是我还是祈愿一下，能有个hr面。
最后，滴滴约时间千万不要约半晌的，不然你可能吃不上饭
Java开发岗
滴滴面试

ㅤ普通",
【滴滴】Java岗-后端实习面筋分享,"早上连着两面，下午一面，面试体验贼好，面试官会引导着问你，是滴滴统一面试，没有分部门
而且不是直接问八股文，通过场景引出八股文
穿插着问了一些项目细节和职业规划
1.Spring IOC和AOP原理
2.写一个jdk动态代理例子
3.redis数据类型
4.现在有一个大文件怎么尽快的写到redis里面（提示我说用pipeline，我没听过）
5.数据库三范式，核心是什么，为什么有三范式
1.操作系统io的过程，详细说包括用户态内核态转换
2.比如阻塞io，java在调用read之后发生了什么
3.广播多播单播任播的概念和应用场景（提示我nginx上的多播）
4.nginx怎么实现负载均衡
5.比如有5亿用户，系统内存4g，要判断用户状态，该用怎样的数据结构和算法(布隆过滤器，然后就不用分批读，4g内存装得下)
6.一个文件里有几百万行关于用户的数据，要建立姓名和性别的聚簇索引，什么思路
7.比如性别男为0女为1，为什么性别应该接在姓名后面（因为性别只有两种，对索引优化是起不到什么作用的，粒度太大）
8.你觉得你在性格上有哪些优点
1.浏览器输入url到页面显示过程
2.http和https的区别以及https的握手过程
3.假如以前12306就一台服务器提供一个单进程的服务，现在人越来越多了，假设服务器性能足够，该怎么优化（网络上采用IO多路复用，单进程改为多线程和协程）
4.多线程会产生什么问题
5.设计个12306的关于买票的数据结构（车次，站，座位）
6.如何在这个数据结构上加锁控制并发
7.用户怎么根据车站查找车次
大部分都是场景题，面试体验很好，感觉比较注重你解决问题的思路
Java开发岗
滴滴面试

ㅤ普通",
【滴滴】Java岗-提前批(offer get!),"自我介绍
学习Java的方法
三次握手四次挥手（状态改变）
dns协议
concurrentHasmap、HashMap、HashTable（实现原理、底层结构、性能差异原因）
JVM内存分区
垃圾回收（回收算法，原因）
synchronized（锁升级）
mysql事务（特性、存在的问题、解决方式、隔离级别）
算法：快排，分析时间复杂度
反问
体验：有史以来体验最佳的面试，面试官提出一个点然后自己发散说就行，有什么问题面试官会指出
自我介绍
学过哪些课
做两道题：
1.第一天1元，后面两天每天2元，后面三天每天3元。。。第n天收益（写了个说复杂度需要改进）
2.排序+数组合并，用的快排和双指针
介绍项目
访问量大的情况怎么解决（没接触过，只说了个消息队列不知道对不对）
说说设计模式
Spring的IOC和AOP
让你实现AOP需要写哪些代码，十行以内（没思路，就说了下用反射）
多线程写一个死锁
反问
体验：回答的时候面试官会附和你，并肯定你的回答，感觉很好
自我介绍
详细介绍科研项目
详细介绍Java项目
说说项目的架构、数据库设计的思想
题目：二进制1的个数
反问
体验：别的不说面试体验一如既往的好
Java开发岗
滴滴面试

ㅤ普通",
【滴滴】Java岗-实习生一二面面经(已oc),"11/3中午一点半收到hr电话，说通过了。
11/2下午三点时长一个小时，zoom，代码共享屏幕写：
简单自我介绍+项目
先写个算法题：两个二叉树合并，值相加，或者创建一个新树或者用原来的合并，递归和不递归的区别？
看一段代码：常见的Integer==问题输出什么？equals 和==？
问HashMap、hashtable、concurrentHashmap区别，分别讲讲，会有什么问题、什么异常，期间说完hashmap的时候打断问：如果你自己处理会怎么解决并发的问题，顺着说了concurrentHashmap 的做法。
进程和线程的区别?
讲一讲线程池？线程池的好处？
mysql的索引怎么实现的
如果a,b有索引，c没有，我一个while查询条件里面用 c and a=xx ,b==xx，能用索引吗？模糊查询有索引吗？%在前后区别？
索引一定越多越好吗?
mysql事务的隔离级别，对应的隔离级别解决了什么问题
mysql的查询优化，自己有总结方法吗?
知道sql注入吗？怎么解决？mybatis是怎么解决的？
说说你熟悉的设计模式？为什么要有设计模式？
linux 常用命令说一说？
git 常用命令说一说？
11/2下午五点半点，时长四十分钟，zoom，代码共享屏幕写：
项目。问怎么实现的，因为我的项目其实很垃圾，就是个java web，没什么技术含量，面试官就从怎么总体设计架构、模块划分、数据块设计问了些。
mysql索引、如何优化
jvm内存区域，垃圾回收器
写个算法题，删除链表的倒数第 n 个节点，要求时间  O(n)，空间 O(1)；
然后就是一些别的感性问题，未来发展等等。
Java开发岗
滴滴面试

ㅤ普通",
【滴滴】Java岗-差点被赛码网搞崩心态,"自我介绍
怼项目
apollo
流程介绍
客户端如何与服务端进行连接
业务端如何与客户端连接，需要的信息
手撕
二叉树中序遍历
1-N的硬币，1-N个人从每个硬币走过，如果硬币编号可以整除人编号，硬币翻面，求最后被翻面朝上的硬币有哪些（说思路）
sql
redis
应用场景
跳表
设计模式
工厂，单例，责任链，策略模式应用场景
自我介绍
策略模式
java
hashmap结构
红黑树的限制条件
gc
说垃圾回收器
mysql
索引失效
索引结构
使用的框架，中间件
自我介绍
进程和线程
区别
多线程问题
锁
计网
http与tcp区别
长连接与短连接
time wait，过多怎么办
数据库
使用注意事项
什么情况不建议使用索引
索引结构
隔离级别
幻读
快照读与当前读如何避免幻读
手撕
100万个ip地址，如何存这些ip地址，需要加入ip地址及判断ip地址是否存在，如何做
ipv4转int
兴趣爱好
优点和缺点
职业规划
Java开发岗
滴滴面试

ㅤ普通",
Shopee Java岗开发面经汇总,"本系列将提供Shopee Java岗位历年面经，所有面经都有候选人面试之后根据回忆整理而出，大家可以通过面经来复习以及看看Shopee面试难度。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 【Shopee】Java岗-一、二面面经(已意向）
1. 【Shopee】Java岗-一、二面面经(已意向）
2. 【Shopee】Java岗-社招面试经历
2. 【Shopee】Java岗-社招面试经历
3. 【Shopee】Java岗-呜呜呜三轮面试凉经
3. 【Shopee】Java岗-呜呜呜三轮面试凉经
4. 【Shopee】Java岗-后端面经总结
4. 【Shopee】Java岗-后端面经总结
5. 【Shopee】Java岗-后台开发工程师实习生
5. 【Shopee】Java岗-后台开发工程师实习生
Java开发岗
Shopee面试

ㅤ普通",
【Shopee】Java岗-一、二面面经(已意向）,"感觉是个不会JAVA的面试官，疯狂在电脑上面找题目问我，整体面试体验还行，但是实验室好几个小伙伴，都觉得体验不错，第二天就收到感谢信 ?
hashmap的实现原理
volatile关键字
线程池的创建方式，还有参数是什么意义
JVM内存分配与回收策略
常用的数据结构
优先级队列的实现原理
满二叉树、完全二叉树、二叉搜索树
TCP和UDP的区别
三次握手、四次挥手
三次握手建立状态分别是什么时候
TCP/IP如何保证可靠传输
聚集索引和非聚集索引
MySQL索引的最左匹配原则
单个索引可以用到最左匹配吗
MySQL乐观锁悲观锁
IO多路复用的原理
长度未知的链表，删除倒数第五个节点
编程题 跳跃游戏II
有后续再来更。
8.14 共40min
直接上来问项目
项目里面mysql的索引为什么选择hash，用的什么引擎
mysql怎么建表的
mysql的索引怎么设计的，为什么选择这个设计方式
博客项目里面的评论的表怎么设计的
redis数据结构
redis的内存不足怎么办（主要想听集群这个答案，我说了内存替换）
redis主从机制
怎么建立多主机的redis集群
后面的问题忘了
编程题：合并K个升序链表
这一面主要偏场景，还有设计的原理，主要是上来都没让我自我介绍，就感觉猝不及防，后续也没收到感谢信和HR面试通知，估计在池子里了
8.19 20min（昨天给我打电话没接）
确认了本硕学历是不是全日制
本科排名和硕士排名
后端项目及难点
自我评价，优点和缺点
怎么解决缺点带来的问题
第一份工作看重什么
前面面试的体验
现在投了哪些公司，拿到了什么offer
了解过虾皮哪些
如果都给offer了去哪（铁定虾皮！！！），为什么（讲了一下学姐在虾皮，自由，包容等等）
后面进入流程审批，9月初给回复
反问环节
许愿offer！！！ballball了！！！
8.31 号收到意向书啦！
Java开发岗
Shopee面试

ㅤ普通",
【Shopee】Java岗-社招面试经历,"1、MySQL中常用存储引擎有哪些？它们相互之间有什么区别？
2、MySQL 索引在什么情况下会失效？
（1）当使用like关键字时，如果查询条件以%开头，索引无效；当like前缀没有%，后缀有%时，索引依然有效。
（2）当使用or关键字时，or语句前后没有同时使用索引或当or关键字左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效。
（3）使用组合索引时，如果查询条件不包括该组合索引全部字段或查询条件不是该组合索引左边第一个字段时，索引失效。
（4）数据类型出现隐式转化。如某个索引字段的数据类型为varchar，查询内容为123，如不加引号的话可能会自动转换为int型，使索引无效，产生全表扫描。
（5）在索引字段上使用not及运算符
（6）对索引字段进行计算操作、字段上使用函数，索引失效。
3、innodb 与myisam 的区别？
4、MySQL 的索引模型；
5、MySQL 主从同步怎么搞的？分哪几个过程？如果有一台新机器要加到从机里，怎么个过程。
6、乐观锁与悲观锁的区别？
7、binlog 日志是 master 推的还是 salve 来拉的？
8、redis 持久化有哪几种方式，怎么选？
9、redis 主从同步是怎样的过程？
10、redis 的 zset 怎么实现的？
11、redis key 的过期策略
12、hashmap 是怎样实现的？
13、tcp 的握手与挥手；
14、select 和 epoll的区别；
15、http与https的区别？
（1）HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的ssl加密传输协议
（2）HTTP 和 HTTPS 使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。
（3）HTTP 的连接很简单,是无状态的
（4）HTTPS 协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比 HTTP 协议安全
（5）HTTPS 内容传输经过完整性校验
（6）HTTPS 内容经过对称加密，每个连接生成一个唯一的加密密钥
（7）HTTPS 第三方无法伪造服务端（客户端）身份
16、raft算法和zk选主算法；
17、Kafka 选主怎么做的？
18、kafka 与 rabbitmq区别；
19、kafka 分区怎么同步的？
20、kafka 怎么保证不丢消息的？
21、kafka 为什么可以扛住这么高的qps？
22、http各种返回码，401和406啥区别？
23、redis哨兵和集群；
24、kafka partition broker consumer consumer group topic 等都是啥关系？
26、手撕代码。牛客题霸上的原题，可以去看看：NC58 找到搜索二叉树中两个错误的节点。
27、两个单向链表，返回求和后的链表结构，例如2->3->1->5，和3->6，结果返回2->3->5->1
Java开发岗
Shopee面试

ㅤ普通",
【Shopee】Java岗-呜呜呜三轮面试凉经,"笔试 2.7 / 3
30min
自我介绍
Redis基本数据结构
Redis中用来去重的结构 map set
场景: 单词 – 频率的对应关系，什么结构存省空间(提示压缩算法: 没想出来)
Map有哪些实现，HashMap原理
说说双亲委派机制
数据库索引 聚簇和非聚簇 覆盖索引
最左前缀原则，给个例子
用过哪些数据库 关系型、非关系型、分布式数据库？what
Mysql应用场景，nosql应用场景
TCP三次握手，不两次？四次挥手不三次？
进程通信方式
对称、非对称加密概念，为啥https先非对称再对称。对称、非对称的具体算法有哪些？
SQL注入，防范
看了笔试，不考算法了
38min
自我介绍
共享变量long，的原子性、可见性。怎么解决
JDK设计模式，说说IO包中的设计模式。装饰器模式作用，具体代码中怎么实现的
float会用到金融中吗
Redis架构，单线程网络模型是怎么做的，Redis集群有几个节点(三主三从)
跳表是什么结构
10个 1G文件，100M排序
Springboot相比spring的区别，为啥能配置的更少，starter原理
项目技术栈，难点
技术规划
对现在公司和shopee的看法
8.19 30min
对前两面面试官的评价
为啥转行，出于什么考虑 (化学系专业?)
学习过程
实习最有挑战的事情
实习最大收获
相对于其他同学竞争力在哪里
还投递了哪些公司，怎么选择
个人感觉面试都答得挺好，HR面挂。还是太菜了
Java开发岗
Shopee面试

ㅤ普通",
【Shopee】Java岗-后端面经总结,"背景：本人2019届毕业的，在第一家公司干了不到两年，去年11月带我的一个领导走了，后来我开始想换个工作环境，于是在今年元旦开始着手准备，白天上班，晚上复习，为今年的金三银四做准备，虽然过程有点累，但是值得！
现已顺利入职虾皮，在此记录和分享一下自己的面经，希望对各位有所帮助！
3.14 60+分钟
自我介绍，然后问了java基础、网络、mysql、多线程等基础知识，还有框架和分布式的一些知识，做了一道算法题，记不太全了，尽量回忆一下吧。。。
说下java的集合，List,Set,Map三者的区别
ArrayList、Vector、LinkedList有什么区别
hashmap原理，底层数据结构、扩容机制，双链表和红黑树的时间复杂度是多少，有什么优缺点，为什么1.8源码达到阈值要转
hashmap是线程安全的吗？如何实现线程安全呢？怎样提高读写性能
concurrentHashmap除了分段锁，还能实现更细粒度的线程安全吗
谈下你对JVM的理解、 JVM GC有哪几种算法，分别适用于什么场景、分配担保机制、新生代为什么是两个幸存者区域，可以改进吗？
什么是协程、线程、进程，并发和并行有什么区别、线程的生命周期和状态
深拷贝、浅拷贝
TCP三握四挥
OSI七层模型包括哪些
数据库ACID、隔离机制、B树和B+树、一条sql的执行过程，做过优化吗？
Redis为什么快？ 缓存穿透、雪崩、主从复制，实际应用中还碰到过哪些问题
springboot启动原理，设计模式，让你自己写一个的话，你觉得该怎么设计
分布式、RAFT协议以及在实际的应用场景
然后开始聊了下项目，大概聊了20多分钟，对自己负责的模块问的很细，建议各位在这块多多思考，做足准备，免得跟我一样，在问到项目的优化时，答的不太好，心态差点崩了…
算法题：二叉树的层次遍历
3.14
线程池了解吗？ 如果让你设计一个线程池如何设计（上来就暴击…）
然后开始问项目，项目扒了个遍，二面整个过程聊得感觉还可以。
算法题：相交链表
Hr面：常规问题，有没有拿到其他公司offer，薪资，到岗情况等，然后还介绍一下虾皮的福利，传说中的1075，15天年假，货真价实的弹性上班，确实很棒！
祝大家都能拿到心仪的offer！
Java开发岗
Shopee面试

ㅤ普通",
【Shopee】Java岗-后台开发工程师实习生,"试两面，现在拿到offer，有一起的小伙伴？可以一起交流一下
过程
牛客网提前批投的，当时就是投了很多公司。
面经整理
自我介绍
问答环节
1、实习
为什么实习时间那么短？
亚信实习时全职？
2、操作系统与网络的知识
进程和线程有什么区别？可以讲讲？
操作系统进程之间的通信的有哪些方式？五种
TCP和UDP有什么区别？
怎么理解字节流和数据报文的概念？
Http与Https有什么区别？https的加密流程是怎样的？
Http的状态码和返回码？
Post和Get有什么区别？Post请求放在哪里？
TCP的三次握手？四次挥手？
3、Java
Java内存管理有哪些构成？java虚拟机内存管理。
根搜索算法？
哪些对象可以作为GcRoot对象？
Java集合的关系？
hashMap和concurrenthashmap有关系？
J.u.c包你用过？下面里面有线程池你有了解过？
线程池参数？如果让你去设计一个线程池你会怎么去做？
C语言、C++你们用到的多？
4、数据库
MySQL用的多？
在一个oracle里面一般如何优化一个SQL？
怎么查看一个SQL是否用到索引？
怎么建一个索引？其他字段怎么判断是否建索引，还要验证一句SQL是否用到索引？这是数据库应用最基础的东西。
5、上机笔试
删除公共字符串
Java开发岗
Shopee面试

ㅤ普通",
finally 块中的代码什么时候被执行？,"在 Java 语言的异常处理中，finally 块的作用就是为了保证无论出现什么情况，finally 块里的代码一定会被执行。由于程序执行 return 就意味着结束对当前函数的调用并跳出这个函数体，因此任何语句要执行都只能在 return 前执行（除非碰到 exit 函数），因此 finally 块里的代码也是在 return 之前执行的。
此外，如果 try-finally 或者 catch-finally 中都有 return，那么 finally 块中的 return 将会覆盖别处的 return 语句，最终返回到调用者那里的是 finally 中 return 的值。
Java异常
Java面试题",
finally 是不是一定会被执行到？,"不一定。下面列举两种执行不到的情况：
（1）当程序进入 try 块之前就出现异常时，会直接结束，不会执行 finally 块中的代码；
（2）当程序在 try 块中强制退出时也不会去执行 finally 块中的代码，比如在 try 块中执行 exit 方法。
Java异常
Java面试题",
try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？,"会。程序在执行到 return 时会首先将返回值存储在一个指定的位置，其次去执行 finally 块，最后再返回。因此，对基本数据类型，在 finally 块中改变 return 的值没有任何影响，直接覆盖掉；而对引用类型是有影响的，返回的是在 finally 对 前面 return 语句返回对象的修改值。
Java异常
Java面试题",
try-catch-finally 中那个部分可以省略？,"catch 和 finally可以省略其中一个，但必须保留其中一个。try 只适合处理运行时异常，try+catch 适合处理运行时异常+普通异常。也就是说，如果你只用 try 去处理普通异常却不加以 catch 处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch 显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以 catch 可以省略，你加上 catch 编译器也觉得无可厚非。
Java异常
Java面试题",
Error 和 Exception 的区别？,"Error 类和 Exception 类的父类都是 Throwable 类。主要区别如下：
Error 类： 一般是指与虚拟机相关的问题，如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防；
Exception 类：分为运行时异常和受检查的异常。
Java异常
Java面试题",
运行时异常与受检异常有何异同？,"运行时异常：如：空指针异常、指定的类找不到、数组越界、方法传递参数错误、数据类型转换错误。可以编译通过，但是一运行就停止了，程序不会自己处理；
受检查异常：要么用 try … catch… 捕获，要么用 throws 声明抛出，交给父类处理。
Java异常
Java面试题",
throw 和 throws 的区别？,"（1）throw：在方法体内部，表示抛出异常，由方法体内部的语句处理；throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例；
（2）throws：在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理；表示出现异常的可能性，并不一定会发生这种异常。
Java异常
Java面试题",
常见的异常类有哪些？,"NullPointerException：当应用程序试图访问空对象时，则抛出该异常。
SQLException：提供关于数据库访问错误或其他错误信息的异常。
IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。
FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。
IOException：当发生某种 I/O 异常时，抛出此异常。此类是失败或中断的 I/O 操作生成的异常的通用类。
ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。
IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。
Java异常
Java面试题",
主线程可以捕获到子线程的异常吗？,"线程设计的理念：“线程的问题应该线程自己本身来解决，而不要委托到外部”。
正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。如果想要在主线程中捕获子线程的异常，我们可以用如下的方式进行处理，使用 Thread 的静态方法
Java异常
Java面试题",
Java异常,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里：Java异常面试题阅读指南
Java异常面试题阅读指南
Java异常",
Java异常面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. finally 块中的代码什么时候被执行？
1. finally 块中的代码什么时候被执行？
2. finally 是不是一定会被执行到？
2. finally 是不是一定会被执行到？
3. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
3. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
4. try-catch-finally 中那个部分可以省略？
4. try-catch-finally 中那个部分可以省略？
5. Error 和 Exception 的区别？
5. Error 和 Exception 的区别？
6. 运行时异常与受检异常有何异同？
6. 运行时异常与受检异常有何异同？
7. throw 和 throws 的区别？
7. throw 和 throws 的区别？
8. 常见的异常类有哪些？
8. 常见的异常类有哪些？
9. 主线程可以捕获到子线程的异常吗？
9. 主线程可以捕获到子线程的异常吗？
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
Java异常",
Java 的泛型是如何工作的 ? 什么是类型擦除 ?,"泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如：List\<String> 在运行时仅用一个 List 来表示。这样做的目的，是确保能和 Java 5 之前的版本开发二进制类库进行兼容。
类型擦除：泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 < T > 则会被转译成普通的 Object 类型，如果指定了上限如 < T extends String > 则类型参数就被替换成类型上限。
补充
1、两个 String 其实只有第一个起作用，后面一个没什么卵用，只不过 JDK7 才开始支持 List\<String>list = new ArrayList<> 这种写法。
2、第一个 String 就是告诉编译器，List 中存储的是 String 对象，也就是起类型检查的作用，之后编译器会擦除泛型占位符，以保证兼容以前的代码。
Java泛型
Java面试题",
什么是泛型中的限定通配符和非限定通配符 ?,"限定通配符对类型进行了限制。有两种限定通配符，一种是< ? extends T > 它通过确保类型必须是 T 的子类来设定类型的上界，另一种是< ? super T >它通过确保类型必须是 T 的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面 < ? > 表示了非限定通配符，因为 < ? > 可以用任意类型来替代。
Java泛型
Java面试题",
List< ? extends T > 和 List < ? super T > 之间有什么区别 ?,"这两个 List 的声明都是限定通配符的例子，List< ? extends T > 可以接受任何继承自 T 的类型的 List，而List < ? super T > 可以接受任何 T 的父类构成的 List。例如 List< ? extends Number > 可以接受 List< Integer > 或 List< Float > 。

  Array 不支持泛型，要用 List 代替 Array，因为 List 可以提供编译器的类型安全保证，而 Array却不能。

Java泛型
Java面试题",
谈谈对运行时数据区的理解？,"Tip：这道题是非常重要的题目，几乎问到 Java 虚拟机这块都是会被问到的。建议不要简单的只回答几个区域的名称，最好展开的讲解下，下面的答案是比较详细的，根据自己的理解回答其中某一段即可。

程序计数器（Program  Counter  Register）：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的命令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，我们程这块内存区域为“线程私有”的内存。
此区域是唯一 一个虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。
Java 虚拟机栈（Java  Virtual  Machine  Stacks）：描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个帧栈（Stack  Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。它的线程也是私有的，生命周期与线程相同。
局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和 returnAddress 类型（指向了一条字节码指令的地址）。
Java 虚拟机栈的局部变量表的空间单位是槽（Slot），其中 64 位长度的 double 和 long 类型会占用两个 Slot。局部变量表所需内存空间在编译期完成分配，当进入一个方法时，该方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。
Java虚拟机栈有两种异常状况：如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。
本地方法栈（Native  Method  Stack）：与虚拟机栈所发挥的作用是非常相似的，它们之间的区别只不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
Java 虚拟机规范没有对本地方法栈中方法使用的语言、使用的方式和数据结构做出强制规定，因此具体的虚拟机可以自由地实现它。比如：Sun  HotSpot 虚拟机直接把Java虚拟机栈和本地方法栈合二为一。
与Java虚拟机栈一样，本地方法栈也会抛出StackOverflowError和 OutOfMemoryError 异常。
Java堆（Java  Heap）：是被所有线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是：存放对象实例，几乎所有的对象实例都在这里分配内存。
Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC”堆（Garbage  Collected  Heap）。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代。从内存分配角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread  Local  Allocation  Buffer, TLAB）。不过无论如何划分，都与存放的内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。
Java 虚拟机规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，可以是固定大小的，也可以是可扩展的。如果在堆中没有完成实例分配。并且堆也无法扩展时，将会抛出 OutOfMemoryError 异常。
方法区（Method  Area）：与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），其目的应该就是与 Java 堆区分开来。
Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。
根据Java虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

运行时常量池:运行时常量池（Runtime  Constant  Pool）：是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一些信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
  Java 虚拟机对 Class 文件每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。
 直接内存:直接内存（Direct  Memory）：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也频繁地使用，而且也可能导致 OutOfMemoryError 异常。
  本地直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存大小以及处理器寻址空间的限制。如果各个内存区域总和大于物理内存限制，从而导致动态扩展时出现 OutOfMemoryError 异常。

Java虚拟机",
堆和栈的区别是什么？,"堆和栈（虚拟机栈）是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的。二者之间最大的区别就是存储的内容不同：堆中主要存放对象实例。栈（局部变量表）中主要存放各种基本数据类型、对象的引用。
从作用来说，栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。在 Java 中一个线程就会相应有一个线程栈与之对应，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。
Java虚拟机",
堆中存什么？栈中存什么？,"堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个 4btye 的引用（堆栈分离的好处）。
为什么不把基本类型放堆中呢？
因为基本数据类型占用的空间一般是1~8个字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况，长度固定，因此栈中存储就够了。如果把它存在堆中是没有什么意义的。基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，它们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java 中参数传递时的问题。
Java虚拟机",
为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？,"从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。
堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。
栈因为运行时的需要，比如：保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。
Java虚拟机",
Java 中的参数传递时传值呢？还是传引用？,"要说明这个问题，先要明确两点：
程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。
Java 在方法调用传递参数时，因为没有指针，所以它都是进行传值调用。但是传引用的错觉是如何造成的呢？在运行栈中，基本类型和引用的处理是一样的，都是传值。所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。
对象，从某种意义上说，是由基本类型组成的。可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树（即非叶子节点），基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点（即一个对象引用），则可以修改这个节点下面的所有内容。
Java虚拟机",
Java 对象的大小是怎么计算的？,"基本数据的类型的大小是固定的。对于非基本类型的 Java 对象，其大小就值得商榷。在 Java 中，一个空 Object 对象的大小是 8 byte，这个大小只是保存堆中一个没有任何属性的对象的大小。看下面语句：
这样在程序中完成了一个 Java 对象的生命，但是它所占的空间为：4 byte + 8 byte。4 byte 是上面部分所说的 Java 栈中保存引用的所需要的空间。而那 8 byte 则是 Java 堆中对象的信息。因为所有的 Java 非基本类型的对象都需要默认继承 Object 对象，因此不论什么样的 Java 对象，其大小都必须是大于 8 byte。有了 Object 对象的大小，我们就可以计算其他对象的大小了。
MaNong 的大小为：空对象大小(8 byte) + int 大小(4 byte) + Boolean 大小(1 byte) + 空 Object 引用的大小（4 byte） = 17byte。但是因为 Java 在对对象内存分配时都是以 8 的整数倍来分，因此大于 17 byte 的最接近 8 的整数倍的是 24，因此此对象的大小为 24 byte。
这里需要注意一下基本类型的包装类型的大小。因为这种包装类型已经成为对象了，因此需要把它们作为对象来看待。包装类型的大小至少是12 byte（声明一个空 Object 至少需要的空间），而且 12 byte 没有包含任何有效信息，同时，因为 Java 对象大小是 8 的整数倍，因此一个基本类型包装类的大小至少是 16 byte。这个内存占用是很恐怖的，它是使用基本类型的 N 倍（N > 2），有些类型的内存占用更是夸张（随便想下就知道了）。因此，可能的话应尽量少使用包装类。在 JDK5 以后，因为加入了自动类型装换，因此，Java 虚拟机会在存储方面进行相应的优化。
Java虚拟机",
对象的访问定位的两种方式？,"Java 程序通过栈上的引用数据来操作堆上的具体对象。目前主流的对象访问方式有：句柄 和 直接指针。
如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象的地址。
1、 使用句柄来访问的最大好处是引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而引用本身不需要修改；
2、使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
Java虚拟机",
判断垃圾可以回收的方法有哪些？,"垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法。
1、引用计数法
引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为 1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b，则 b 引用的对象实例的计数器加 1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减 1。任何引用计数器为 0 的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减 1。
优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。
缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为 0。
例如如下代码：
这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将 object1 和 object2 赋值为null，也就是说 object1 和 object2 指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。
2、可达性分析算法
可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。

在 Java 语言中，可作为 GC Roots 的对象包括下面几种： 
Java虚拟机",
垃圾回收是从哪里开始的呢？,"查找哪些对象是正在被当前系统使用的。上面分析的堆和栈的区别，其中栈是真正进行程序执行地方，所以要获取哪些对象正在被使用，则需要从 Java 栈开始。同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。

同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以 null 引用或者基本类型结束，这样就形成了一颗以 Java 栈中引用所对应的对象为根节点的一颗对象树。如果栈中有多个引用，则最终会形成多颗对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。
Java虚拟机",
被标记为垃圾的对象一定会被回收吗？,"即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。  
第一次标记：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记；  
第二次标记：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。在 finalize() 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。第二次标记成功的对象将真的会被回收，如果对象在 finalize() 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。
Java虚拟机",
谈谈对 Java 中引用的了解？,"无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用 4 种，这四种引用强度依次逐渐减弱。
在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
也叫幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。
Java虚拟机",
谈谈对内存泄漏的理解？,"在 Java 中，内存泄漏就是存在一些不会再被使用确没有被回收的对象，这些对象有下面两个特点：
这些对象是无用的，即程序以后不会再使用这些对象。
如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。
Java虚拟机",
内存泄露的根本原因是什么？,"长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。
Java虚拟机",
举几个可能发生内存泄漏的情况？,"静态集合类引起的内存泄漏；
当集合里面的对象属性被修改后，再调用 remove() 方法时不起作用；
监听器：释放对象的时候没有删除监听器；
各种连接：比如数据库连接（dataSourse.getConnection()），网络连接(socket) 和 IO 连接，除非其显式的调用了其 close() 方法将其连接关闭，否则是不会自动被 GC 回收的；
内部类：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放；
单例模式：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。
Java虚拟机",
尽量避免内存泄漏的方法？,"尽量不要使用 static 成员变量，减少生命周期；
及时关闭资源；
不用的对象，可以手动设置为 null。
Java虚拟机",
常用的垃圾收集算法有哪些？,"标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。
复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于 copying 算法的垃圾收集就从根集合（GC Roots）中扫描活动对象，并将每个活动对象复制到空闲面（使得活动对象所占的内存之间没有空闲洞），这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。
标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。
分代收集算法是目前大部分 JVM 的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。
老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。
Java虚拟机",
为什么要采用分代收集算法？,"分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 Http 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String 对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。
在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。
Java虚拟机",
分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法？,"1、年轻代（Young Generation）的回收算法 (主要以 Copying 为主)
新生代内存按照 8:1:1 的比例分为一个 eden 区和两个 survivor（survivor0、 survivor1）区。大部分对象在 Eden 区中生成。回收时先将 Eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区，然后清空 eden 区 和这个 survivor0 区，此时 survivor0 区是空的，然后将survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。
当 survivor1 区不足以存放 Eden 区 和 survivor0区 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC（Major GC），也就是新生代、老年代都进行回收。
新生代发生的 GC 也叫做 Minor GC，MinorGC 发生频率比较高（不一定等 Eden 区满了才触发）。
2、年老代（Old Generation）的回收算法（主要以 Mark-Compact 为主）
在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
内存比新生代也大很多（大概比例是1 : 2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率标记高。
Java虚拟机",
什么是浮动垃圾？,"由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了“Floating Garbage”，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，并发收集器一般需要20%的预留空间用于这些浮动垃圾。
Java虚拟机",
什么是内存碎片？如何解决？,"由于不同 Java 对象存活时间是不一定的，因此，在程序运行一段时间以后，如果不进行内存整理，就会出现零散的内存碎片。碎片最直接的问题就是会导致无法分配大块的内存空间，以及程序运行效率降低。所以，在上面提到的基本垃圾回收算法中，“复制”方式和“标记-整理”方式，都可以解决碎片的问题。
Java虚拟机",
常用的垃圾收集器有哪些？,"新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是 client 级别默认的 GC 方式，可以通过 -XX:+UseSerialGC 来强制指定。
老年代单线程收集器，Serial 收集器的老年代版本。
新生代收集器，可以认为是 Serial 收集器的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现。
并行收集器，追求高吞吐量，高效利用 CPU。吞吐量一般为 99%， 吞吐量= 用户线程时间 / (用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是 server 级别默认采用的GC方式，可用 -XX:+UseParallelGC 来强制指定，用 -XX:ParallelGCThreads=4 来指定线程数。
Parallel Old 收集器的老年代版本，并行收集器，吞吐量优先。
高并发、低停顿，追求最短 GC 回收停顿时间，cpu 占用比较高，响应时间快，停顿时间短，多核 cpu 追求高响应时间的选择。
CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。
CMS 使用的是标记-清除的算法实现的，所以在 GC 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。
G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First的由来。
Java虚拟机",
谈谈你对 CMS 垃圾收集器的理解？,"CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。是使用标记清除算法实现的，整个过程分为四步：
并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。【这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短】；
并发清除：开启用户线程，同时 GC 线程开始对为标记的区域做清扫。
CMS 的优缺点：
主要优点：并发收集、低停顿；
主要缺点：对 CPU 资源敏感、无法处理浮动垃圾、它使用的回收算法“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
Java虚拟机",
谈谈你对 G1 收集器的理解？,"垃圾回收的瓶颈：传统分代垃圾回收方式，已经在一定程度上把垃圾回收给应用带来的负担降到了最小，把应用的吞吐量推到了一个极限。但是他无法解决的一个问题，就是 Full GC 所带来的应用暂停。在一些对实时性要求很高的应用场景下，GC 暂停所带来的请求堆积和请求失败是无法接受的。这类应用可能要求请求的返回时间在几百甚至几十毫秒以内，如果分代垃圾回收方式要达到这个指标，只能把最大堆的设置限制在一个相对较小范围内，但是这样有限制了应用本身的处理能力，同样也是不可接受的。
分代垃圾回收方式确实也考虑了实时性要求而提供了并发回收器，支持最大暂停时间的设置，但是受限于分代垃圾回收的内存划分模型，其效果也不是很理想。
G1 可谓博采众家之长，力求到达一种完美。它吸取了增量收集优点，把整个堆划分为一个一个等大小的区域（region）。内存的回收和划分都以region为单位；同时，它也吸取了 CMS 的特点，把这个垃圾回收过程分为几个阶段，分散一个垃圾回收过程；而且，G1 也认同分代垃圾回收的思想，认为不同对象的生命周期不同，可以采取不同收集方式，因此，它也支持分代的垃圾回收。为了达到对回收时间的可预计性，G1 在扫描了 region 以后，对其中的活跃对象的大小进行排序，首先会收集那些活跃对象小的 region，以便快速回收空间（要复制的活跃对象少了），因为活跃对象小，里面可以认为多数都是垃圾，所以这种方式被称为 Garbage First（G1）的垃圾回收算法，即：垃圾优先的回收。
Java虚拟机",
说下你对垃圾回收策略的理解/垃圾回收时机？,"所有对象创建在新生代的 Eden 区，当 Eden 区满后触发新生代的 Minor GC，将 Eden 区和非空闲 Survivor 区存活的对象复制到另外一个空闲的 Survivor 区中。保证一个 Survivor 区是空的，新生代 Minor GC 就是在两个 Survivor 区之间相互复制存活对象，直到 Survivor 区满为止。
Minor/Scavenge 这种方式的 GC 是在年轻代的 Eden 区进行，不会影响到年老代。因为大部分对象都是从 Eden 区开始的，同时 Eden 区不会分配的很大，所以 Eden 区的 GC 会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使 Eden 去能尽快空闲出来。
2. Major GC
发生在老年代的GC ，基本上发生了一次Major GC 就会发生一次 Minor GC。并且Major GC 的速度往往会比 Minor GC 慢 10 倍。
什么时候会发生 Major GC 呢？
对整个堆进行整理，包括 Young、Tenured 和 Perm。Full GC 因为需要对整个堆进行回收，所以比 Minor GC 要慢，因此应该尽可能减少 Full GC 的次数。在对 JVM 调优的过程中，很大一部分工作就是对于 Full GC 的调节。
如下原因可能导致 Full GC：
1、 调用 System.gc()，会建议虚拟机执行 Full GC。只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。
2、 老年代空间不足，原因：老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间；
3、 空间分配担保失败：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC；
4、JDK 1.7 及以前的永久代空间不足。在 JDK1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。
5、Concurrent Mode Failure 执行 CMS GC 的过程中，同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。
Java虚拟机",
谈谈你对内存分配的理解？大对象怎么分配？空间分配担保？,"大对象直接进入老年代：大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。
长期存活的对象将进入老年代：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄的阈值。
动态对象年龄判定：为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。
空间分配担保
（1）在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；
（2）如果不成立的话，虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。
Java虚拟机",
说下你用过的 JVM 监控工具？,"jvisualvm：虚拟机监视和故障处理平台
jps ：查看当前 Java 进程
jstat：显示虚拟机运行数据
jmap：内存监控
jhat：分析 heapdump 文件
jstack：线程快照
jinfo：虚拟机配置信息
Java虚拟机",
如何利用监控工具调优？,"1、堆信息查看
提供即时的垃圾回收功能
垃圾监控（长时间监控回收情况）
查看堆内类、对象信息查看：数量、类型等
对象引用情况查看
有了堆信息查看方面的功能，我们一般可以顺利解决以下问题：
内存泄漏
垃圾回收算法设置是否合理
2、线程监控
线程信息监控：系统线程数量
线程状态监控：各个线程都处在什么样的状态下
Dump 线程详细信息：查看线程内部运行情况
死锁检查
3、 热点分析
内存热点：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）这两个东西对于系统优化很有帮助。我们可以根据找到的热点，有针对性的进行系统的瓶颈查找和进行系统优化，而不是漫无目的的进行所有代码的优化。
4、快照
快照是系统运行到某一时刻的一个定格。在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到问题。
举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进行垃圾回收前后，分别进行一次堆情况的快照，然后对比两次快照的对象情况。
5、内存泄露检查
内存泄漏是比较常见的问题，而且解决方法也比较通用，这里可以重点说一下，而线程、热点方面的问题则是具体问题具体分析了。
内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。内存泄漏对系统危害比较大，因为它可以直接导致系统的崩溃。
Java虚拟机",
JVM 的一些参数？,"-Xms：初始堆大小
-Xmx：最大堆大小
-XX:NewSize=n：设置年轻代大小
-XX:NewRatio=n：设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为 1：3，年轻代占整个年轻代年老代和的 1/4
-XX:SurvivorRatio=n：年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如：3，表示 Eden：Survivor=3：2，一个Survivor区占整个年轻代的 1/5
-XX:MaxPermSize=n：设置持久代大小
-XX:+UseSerialGC：设置串行收集器
-XX:+UseParallelGC：设置并行收集器
-XX:+UseParalledlOldGC：设置并行年老代收集器
-XX:+UseConcMarkSweepGC：设置并发收集器
-XX:+PrintGC：开启打印 gc 信息
-XX:+PrintGCDetails：打印 gc 详细信息
-XX:+PrintGCTimeStamps
-Xloggc:filename
-XX:ParallelGCThreads=n：设置并行收集器收集时使用的 CPU 数
-XX:MaxGCPauseMillis=n：设置并行收集最大暂停时间
-XX:GCTimeRatio=n：设置垃圾回收时间占程序运行时间的百分比
-XX:+CMSIncrementalMode：设置为增量模式。适用于单 CPU 情况
-XX:ParallelGCThreads=n：设置并发收集器年轻代收集方式为并行收集时，使用的 CPU 数。并行收集线程数
Java虚拟机",
谈谈你对类文件结构的理解？有哪些部分组成？,"Class 文件结构如下标所示：

Class 文件没有任何分隔符，严格按照上面结构表中的顺序排列。无论是顺序还是数量，甚至于数据存储的字节序这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。
文件的版本：minor_version 和 major_version。
常量池：constant_pool_count 和 constant_pool：常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic  References）。
访问标志：access_flags：用于识别一些类或者接口层次的访问信息。包括：这个 Class 是类还是接口、是否定义了 Public 类型、是否定义为 abstract 类型、如果是类，是否被声明为了 final 等等。
5.类索引、父类索引与接口索引集合：this_class、super_class和interfaces。
字段表集合：field_info、fields_count：字段表（field_info）用于描述接口或者类中声明的变量；fields_count 字段数目：表示Class文件的类和实例变量总数。
方法表集合：methods、methods_count
属性表集合：attributes、attributes_count
Java虚拟机",
谈谈你对类加载机制的了解？,"虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载 7 个阶段。其中验证、准备、解析 3 个部分统称为连接，这7个阶段发生的顺序如下图所示：

Java虚拟机",
类加载各阶段的作用分别是什么？,"在加载阶段，虚拟机需要完成以下三件事情：
1、通过一个类的全限定名来获取定义此类的二进制字节流；
2、 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3、在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问接口。
主要是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上分为 4 个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
1、文件格式校验：验证字节流是否符合 class 文件的规范，并且能被当前版本的虚拟机处理。只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的3个阶段的全部是基于方法区的存储结构进行的，不会再直接操作字节流；
2、 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。目的是保证不存在不符合 Java 语言规范的元数据信息；
3、 字节码验证：该阶段主要工作是进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为；
4、 符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证的目的是确保解析动作能正常执行。
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配**。这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。
初始值是默认值 0 或 false 或 null。如果类变量是常量（final），那么会按照表达式来进行初始化，而不是赋值为 0。public static final int value = 123;
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
在准备阶段，变量已经赋过一次系统要求的初始值了，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器 () 方法的过程。
Java虚拟机",
有哪些类加载器？分别有什么作用？,"其他类加载器：由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。如扩展类加载器和应用程序类加载器：
（1）扩展类加载器(Extension  ClassLoader)：这个类加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载\lib\ext目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
（2）应用程序类加载器 (Application  ClassLoader)：这个类加载器由 sun.misc.Launcher$AppClassLoder 实现。由于个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称之为系统类加载器。它负责加载用户路径（ClassPath）所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
Java虚拟机",
类与类加载器的关系?,"类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。换句话说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。
Java虚拟机",
谈谈你对双亲委派模型的理解？工作过程？为什么要使用,"应用程序一般是由上诉的三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器，它们的关系如下图所示：

如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如：类 java.lang.Object，它存放在 rt.jar 中，无论哪一个类加载器需要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类（使用的是同一个类加载器加载的）。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个 java.lang.Object 类，并放在程序的 ClassPath 中，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将变得一片混乱。
实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法中，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。
Java虚拟机",
怎么实现一个自定义的类加载器？需要注意什么？,"若要实现自定义类加载器，只需要继承 java.lang.ClassLoader 类，并且重写其 findClass() 方法即可。
Java虚拟机",
怎么打破双亲委派模型？,"重写 loadClass() 方法
重写 findClass() 方法
这里最主要的是重写 loadClass 方法，因为双亲委派机制的实现都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载再由自己来进行加载，源码里会直接找到根加载器，重写了这个方法以后就能自己定义加载的方式了。
Java虚拟机",
有哪些实际场景是需要打破双亲委派模型的？,"JNDI 服务，它的代码由启动类加载器去加载，但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现并部署在应用程序的 classpath 下的 JNDI 接口提供者(SPI, Service Provider Interface) 的代码，但启动类加载器不可能“认识”之些代码，该怎么办？
为了解决这个困境，Java 设计团队只好引入了一个不太优雅的设计：**线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。
Java虚拟机",
谈谈你对编译期优化和运行期优化的理解？,"1、编译期优化：
插入式注解处理器的注解处理过程
分析与字节码生成过程
2、编译优化：
方法内联
公共子表达式消除
数组范围检查消除
逃逸分析
Java虚拟机",
为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？,"解释器：程序可以迅速启动和执行，消耗内存小 （类似人工，成本低，到后期效率低）；
编译器：随着代码频繁执行会将代码编译成本地机器码 （类似机器，成本高，到后期效率高）。
在整个虚拟机执行架构中，解释器与编译器经常配合工作，两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大（如部分嵌入式系统），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。
解释执行可以节约内存，而编译执行可以提升效率。因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作。
Java虚拟机",
说下你对 Java 内存模型的理解？,"处理器和内存不是同数量级，所以需要在中间建立中间层，也就是高速缓存，这会引出缓存一致性问题。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），有可能操作同一位置引起各自缓存不一致，这时候需要约定协议在保证一致性。
Java 内存模型(Java  Memory  Model，JMM)：屏蔽掉了各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致性的内存访问效果

Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中，每个线程有自己的工作线程（Working Memory），保存主内存副本拷贝和自己私有变量，不同线程不能访问工作内存中的变量。线程间变量值的传递需要通过主内存来完成。
Java虚拟机",
内存间的交互操作有哪些？需要满足什么规则？,"关于主内存与工作内存之间的具体的交互协议，即：一个变量如何从主内存拷贝到工作内存、如何从工作内存同步主内存之类的实现细节，Java内存模型中定义一下八种操作来完成：
unlock(解锁)：作用于主内存的变量，它把处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；
read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；
load(载入)：作用于工作内存的变量，它把read操作从主内存中得到变量值放入工作内存的变量的副本中；
use(使用)：作用于工作内存的变量， 它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；
assign(赋值)：作用于工作内存的变量。它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到需要给一个变量赋值的字节码时执行这个操作；
store(存储)：作用于工作内存的变量。它把一个工作内存中一个变量的值传递到主内存中，以便随后的write操作使用；
write(写入)：作用于主内存的变量。它把store操作从工作内存中得到的变量的值放入主内存的变量中。
如果要把一个变量从主存内存复制到工作内存，那就要按顺序执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要按顺序执行 store 和 write 操作。
上诉 8 种基本操作必须满足的规则：
不允许 read 和 load、store 和 write 操作之一单独出现；
不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变之后必须把该变化同步回主内存；
不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中；
一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须执行过了 assign 和 load 操作；
一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock，变量才会被解锁；
如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值；
如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定主的变量；
对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store 和 write 操作）。
Java虚拟机",
Java虚拟机,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里：JVM阅读指南（必看）
JVM阅读指南（必看）
Java虚拟机",
JVM阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 说一下 Jvm 的主要组成部分？及其作用？
1. 说一下 Jvm 的主要组成部分？及其作用？
2. 谈谈对运行时数据区的理解？
2. 谈谈对运行时数据区的理解？
3. 堆和栈的区别是什么？
3. 堆和栈的区别是什么？
4. 堆中存什么？栈中存什么？
4. 堆中存什么？栈中存什么？
5. 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？
5. 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？
6. Java 中的参数传递时传值呢？还是传引用？
6. Java 中的参数传递时传值呢？还是传引用？
7. Java 对象的大小是怎么计算的？
7. Java 对象的大小是怎么计算的？
8. 对象的访问定位的两种方式？
8. 对象的访问定位的两种方式？
9. 判断垃圾可以回收的方法有哪些？
9. 判断垃圾可以回收的方法有哪些？
10. 垃圾回收是从哪里开始的呢？
10. 垃圾回收是从哪里开始的呢？
11. 被标记为垃圾的对象一定会被回收吗？
11. 被标记为垃圾的对象一定会被回收吗？
12. 谈谈对 Java 中引用的了解？
12. 谈谈对 Java 中引用的了解？
13. 谈谈对内存泄漏的理解？
13. 谈谈对内存泄漏的理解？
14. 内存泄露的根本原因是什么？
14. 内存泄露的根本原因是什么？
15. 举几个可能发生内存泄漏的情况？
15. 举几个可能发生内存泄漏的情况？
16. 尽量避免内存泄漏的方法？
16. 尽量避免内存泄漏的方法？
17. 常用的垃圾收集算法有哪些？
17. 常用的垃圾收集算法有哪些？
18. 为什么要采用分代收集算法？
18. 为什么要采用分代收集算法？
19. 分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法？
19. 分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法？
20. 什么是浮动垃圾？
20. 什么是浮动垃圾？
21. 什么是内存碎片？如何解决？
21. 什么是内存碎片？如何解决？
22. 常用的垃圾收集器有哪些？
22. 常用的垃圾收集器有哪些？
23. 谈谈你对 CMS 垃圾收集器的理解？
23. 谈谈你对 CMS 垃圾收集器的理解？
24. 谈谈你对 G1 收集器的理解？
24. 谈谈你对 G1 收集器的理解？
25. 说下你对垃圾回收策略的理解/垃圾回收时机？
25. 说下你对垃圾回收策略的理解/垃圾回收时机？
26. 谈谈你对内存分配的理解？大对象怎么分配？空间分配担保？
26. 谈谈你对内存分配的理解？大对象怎么分配？空间分配担保？
27. 说下你用过的 JVM 监控工具？
27. 说下你用过的 JVM 监控工具？
28. 如何利用监控工具调优？
28. 如何利用监控工具调优？
29. JVM 的一些参数？
29. JVM 的一些参数？
30. 谈谈你对类文件结构的理解？有哪些部分组成？
30. 谈谈你对类文件结构的理解？有哪些部分组成？
31. 谈谈你对类加载机制的了解？
31. 谈谈你对类加载机制的了解？
32. 类加载各阶段的作用分别是什么？
32. 类加载各阶段的作用分别是什么？
33. 有哪些类加载器？分别有什么作用？
33. 有哪些类加载器？分别有什么作用？
34. 类与类加载器的关系?
34. 类与类加载器的关系?
35. 谈谈你对双亲委派模型的理解？工作过程？为什么要使用
35. 谈谈你对双亲委派模型的理解？工作过程？为什么要使用
36. 怎么实现一个自定义的类加载器？需要注意什么？
36. 怎么实现一个自定义的类加载器？需要注意什么？
37. 怎么打破双亲委派模型？
37. 怎么打破双亲委派模型？
38. 有哪些实际场景是需要打破双亲委派模型的？
38. 有哪些实际场景是需要打破双亲委派模型的？
39. 谈谈你对编译期优化和运行期优化的理解？
39. 谈谈你对编译期优化和运行期优化的理解？
40. 为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？
40. 为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？
41. 说下你对 Java 内存模型的理解？
41. 说下你对 Java 内存模型的理解？
42. 内存间的交互操作有哪些？需要满足什么规则？
42. 内存间的交互操作有哪些？需要满足什么规则？
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
Java虚拟机",
并行和并发有什么区别？,"并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；
并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；
在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如 Hadoop 分布式集群。所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。
Java锁",
线程和进程的区别？,"进程：是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。
线程：是进程的一个实体，是 cpu 调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。
Java锁",
守护线程是什么？,"守护线程（即 Daemon thread），是个服务线程，准确地来说就是服务其他的线程
Java锁",
创建线程的几种方式？,"继承 Thread 类创建线程；
实现 Runnable 接口创建线程；
通过 Callable 和 Future 创建线程；
通过线程池创建线程。
Java锁",
Runnable 和 Callable 有什么区别？,"Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已；
Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。
Java锁",
线程状态及转换？,"Thread 的源码中定义了6种状态：new（新建）、runnnable（可运行）、blocked（阻塞）、waiting（等待）、time waiting （定时等待）和 terminated（终止）。

线程状态转换如下图所示：

Java锁",
sleep() 和 wait() 的区别？,"1、sleep() 方法正在执行的线程主动让出 cpu（然后 cpu 就可以去执行其他任务），在 sleep 指定时间后 cpu 再回到该线程继续往下执行（注意：sleep 方法只让出了 cpu，而并不会释放同步资源锁）；而 wait() 方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了 notify() 方法，之前调用 wait() 的线程才会解除 wait 状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify 的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说 notify 只是让之前调用 wait 的线程有权利重新参与线程的调度）；
2、 sleep() 方法可以在任何地方使用，而 wait() 方法则只能在同步方法或同步块中使用；
3、 sleep() 是线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait() 是 Object 的方法，调用会放弃对象锁，进入等待队列，待调用 notify()/notifyAll() 唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态。
Java锁",
线程的 run() 和 start() 有什么区别？,"1、每个线程都是通过某个特定 Thread 对象所对应的方法 run() 来完成其操作的，方法 run() 称为线程体。通过调用 Thread 类的 start() 方法来启动一个线程；
2、start() 方法来启动一个线程，真正实现了多线程运行。这时无需等待 run() 方法体代码执行完毕，可以直接继续执行下面的代码；这时此线程是处于就绪状态，并没有运行。然后通过此 Thread 类调用方法 run() 来完成其运行状态，这里方法 run() 称为线程体，它包含了要执行的这个线程的内容，run() 方法运行结束，此线程终止。然后 cpu 再调度其它线程；
3、 run() 方法是在本线程里的，只是线程里的一个函数，而不是多线程的。如果直接调用 run()，其实就相当于是调用了一个普通函数而已，直接调用 run() 方法必须等待 run() 方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用 start() 方法而不是 run() 方法。
Java锁",
在 Java 程序中怎么保证多线程的运行安全？,"线程安全在三个方面体现：
原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic，synchronized）；
可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized、volatile）；
有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before 原则）。
Java锁",
Java 线程同步的几种方法？,"使用 Synchronized 关键字；
wait 和 notify；
使用特殊域变量 volatile 实现线程同步；
使用可重入锁实现线程同步；
使用阻塞队列实现线程同步；
使用信号量 Semaphore。
Java锁",
Thread.interrupt() 方法的工作原理是什么？,"在 Java 中，线程的中断 interrupt 只是改变了线程的中断状态，至于这个中断状态改变后带来的结果，那是无法确定的，有时它更是让停止中的线程继续执行的唯一手段。不但不是让线程停止运行，反而是继续执行线程的手段。
在一个线程对象上调用 interrupt() 方法，真正有影响的是 wait、join、sleep 方法，当然这 3 个方法包括它们的重载方法。请注意：上面这三个方法都会抛出 InterruptedException。
1、对于 wait 中的等待 notify、notifyAll 唤醒的线程，其实这个线程已经“暂停”执行，因为它正在某一对象的休息室中，这时如果它的中断状态被改变，那么它就会抛出异常。这个 InterruptedException 异常不是线程抛出的，而是 wait 方法，也就是对象的 wait 方法内部会不断检查在此对象上休息的线程的状态，如果发现哪个线程的状态被置为已中断，则会抛出 InterruptedException，意思就是这个线程不能再等待了，其意义就等同于唤醒它了，然后执行 catch 中的代码。
2、 对于 sleep 中的线程，如果你调用了 Thread.sleep(一年)；现在你后悔了，想让它早些醒过来，调用 interrupt() 方法就是唯一手段，只有改变它的中断状态，让它从 sleep 中将控制权转到处理异常的 catch 语句中，然后再由 catch 中的处理转换到正常的逻辑。同样，对于 join 中的线程你也可以这样处理。
Java锁",
谈谈对 ThreadLocal 的理解？,"1、Java 的 Web 项目大部分都是基于 Tomcat。每次访问都是一个新的线程，每一个线程都独享一个 ThreadLocal，我们可以在接收请求的时候 set 特定内容，在需要的时候 get 这个值。
2、 ThreadLocal 提供 get 和 set 方法，为每一个使用这个变量的线程都保存有一份独立的副本。
1、get() 方法是用来获取 ThreadLocal 在当前线程中保存的变量副本；
2、set() 用来设置当前线程中变量的副本；
3、 remove() 用来移除当前线程中变量的副本；
4、 initialValue() 是一个 protected 方法，一般是用来在使用时进行重写的，如果在没有 set 的时候就调用 get，会调用 initialValue 方法初始化内容。
Java锁",
在哪些场景下会使用到 ThreadLocal？,"在调用 API 接口的时候传递了一些公共参数，这些公共参数携带了一些设备信息（是安卓还是 ios），服务端接口根据不同的信息组装不同的格式数据返回给客户端。假定服务器端需要通过设备类型（device）来下发下载地址，当然接口也有同样的其他逻辑，我们只要在返回数据的时候判断好是什么类型的客户端就好了。上面这种场景就可以将传进来的参数 device 设置到 ThreadLocal 中。用的时候取出来就行。避免了参数的层层传递。
Java锁",
说一说自己对于 synchronized 关键字的了解？,"synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
另外，在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 JDK6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
synchronized 关键字底层原理属于 JVM 层面。
synchronized 同步语句块的情况
通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行 javap -c -s -v -l SynchronizedDemo.class

从上面我们可以看出：synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。
当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。monitor 对象存在于每个 Java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1。相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
synchronized 修饰方法的的情况
synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用
Java锁",
如何在项目中使用 synchronized 的？,"synchronized 关键字最主要的三种使用方式：
1、 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁；
2、修饰静态方法：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管 new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁；
3、 修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。和 synchronized 方法一样，synchronized(this) 代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。这里再提一下：synchronized 关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓冲功能。
补充：双重校验锁实现单例模式
问到 synchronized 的使用，很有可能让你用 synchronized 实现个单例模式。这里补充下使用 synchronized 双重校验锁的方法实现单例模式：
“`java
public class Singleton {
<pre><code>private volatile static Singleton uniqueInstance;
private Singleton() {}
public static Singleton getUniqueInstance() {
   // 先判断对象是否已经实例过，没有实例化过才进入加锁代码
    if (uniqueInstance == null) {
        // 类对象加锁
        synchronized (Singleton.class) {
            if (uniqueInstance == null) {
                uniqueInstance = new Singleton();
            }
        }
    }
    return uniqueInstance;
}
</code></pre>
}
“`
另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：
初始化 uniqueInstance
将 uniqueInstance 指向分配的内存地址
但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1 -> 3 -> 2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。
使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。
Java锁",
说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？,"说明：这道题答案有点长，但是回答的详细面试会很加分。
JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。
锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，它们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。
引入偏向锁的目的和引入轻量级锁的目的很像，它们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。
偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。
但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。
倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(JDK1.6 之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了 CAS 操作。
轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生 CAS 操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！
关于重量级锁，轻量级锁，自旋锁和自适应自旋，推荐大家看下这篇文章：一句话撸完重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等各种锁 ，讲的比较清晰一些
一句话撸完重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等各种锁 
锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。
原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小。只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。
大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗
Java锁",
谈谈 synchronized 和 ReenTrantLock 的区别？,"1、synchronized 是和 for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized 更多更灵活的特性：等待可中断、可实现公平锁、可实现选择性通知（锁可以绑定多个条件）、性能已不是选择标准。
2、 synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API。synchronized 是依赖于 JVM 实现的，JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。
Java锁",
synchronized 和 volatile 的区别是什么？,"volatile 本质是在告诉 JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。
volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。
Java锁",
谈一下你对 volatile 关键字的理解？,"volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，这样做是为了减少流水线阻塞，提高 CPU 的执行效率。这就需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知道对不对了，所以有 happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作、有序性实现的是通过插入内存屏障来保证的。
被 volatile 修饰的共享变量，就具有了以下两点特性：
1 . 保证了不同线程对该变量操作的内存可见性;
2 . 禁止指令重排序。
备注：这个题如果扩展了答，可以从 Java 的内存模型入手，下一篇 Java 虚拟机高频面试题中会讲到，这里不做过多赘述。
Java锁",
说下对 ReentrantReadWriteLock 的理解？,"ReentrantReadWriteLock 允许多个读线程同时访问，但是不允许写线程和读线程、写线程和写线程同时访问。读写锁内部维护了两个锁：一个是用于读操作的 ReadLock，一个是用于写操作的 WriteLock。读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。
ReentrantReadWriteLock 基于 AQS 实现，它的自定义同步器（继承 AQS）需要在同步状态 state 上维护多个读线程和一个写线程，该状态的设计成为实现读写锁的关键。ReentrantReadWriteLock 很好的利用了高低位。来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。
1、写锁可以降级为读锁，但是读锁不能升级为写锁；
2、 不管是 ReadLock 还是 WriteLock 都支持 Interrupt，语义与 ReentrantLock 一致；
3、WriteLock 支持 Condition 并且与 ReentrantLock 语义一致，而 ReadLock 则不能使用 Condition，否则抛出 UnsupportedOperationException 异常；
4、 默认构造方法为非公平模式 ，开发者也可以通过指定 fair 为 true 设置为公平模式 。
1、 读锁里面加写锁，会导致死锁；
\2. 写锁里面是可以加读锁的，这就是锁的降级。
Java锁",
说下对悲观锁和乐观锁的理解？,"总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如：行锁、表锁、读锁、写锁等，都是在做操作之前先上锁。Java 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。
从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
Java锁",
乐观锁常见的两种实现方式是什么？,"乐观锁一般会使用版本号机制或者 CAS 算法实现。
一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加 1。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。
CAS 算法
即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS 算法涉及到三个操作数：
1、需要读写的内存值 V
2、进行比较的值 A
3、拟写入的新值 B
当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。
Java锁",
乐观锁的缺点有哪些？,"如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA” 问题。
JDK 1.5 以后的AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
自旋 CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一：它可以延迟流水线执行指令（de-pipeline），使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二：它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。 但是从 JDK 1.5 开始，提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用 AtomicReference 类把多个共享变量合并成一个共享变量来操作。
Java锁",
CAS 和 synchronized 的使用场景？,"简单的来说 CAS 适用于写比较少的情况下（多读场景，冲突一般较少），synchronized 适用于写比较多的情况下（多写场景，冲突一般较多）。
1、对于资源竞争较少（线程冲突较轻）的情况，使用 synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 cpu 资源；而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
2、对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。
Java锁",
简单说下对 Java 中的原子类的理解？,"这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。所以，所谓原子类说简单点就是具有原子操作特征的类。
并发包 java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic 下。根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类：
使用原子的方式更新基本类型：
AtomicInteger：整型原子类
AtomicLong：长整型原子类
AtomicBoolean ：布尔型原子类
使用原子的方式更新数组里的某个元素：
AtomicIntegerArray：整型数组原子类
AtomicLongArray：长整型数组原子类
AtomicReferenceArray ：引用类型数组原子类
AtomicReference：引用类型原子类
AtomicStampedReference：原子更新引用类型里的字段原子类
AtomicMarkableReference ：原子更新带有标记位的引用类型
AtomicIntegerFieldUpdater：原子更新整型字段的更新器
AtomicLongFieldUpdater：原子更新长整型字段的更新器
AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。
Java锁",
atomic 的原理是什么？,"Atomic 包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。
Atomic 系列的类中的核心方法都会调用 unsafe 类中的几个本地方法。我们需要先知道一个东西就是 Unsafe 类，全名为：sun.misc.Unsafe，这个类包含了大量的对 C 代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过 unsafe 分配内存的时候，如果自己指定某些区域可能会导致一些类似 C++ 一样的指针越界到其他进程的问题。
Java锁",
说下对同步器 AQS 的理解？,"AQS 的全称为：AbstractQueuedSynchronizer，这个类在 java.util.concurrent.locks 包下面。AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如：我们提到的 ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器
Java锁",
AQS 的原理是什么？,"AQS 核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。


  CLH队列：CLH(Craig, Landin, and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。

AQS 使用一个 int 成员变量 (state) 来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。
“`java
// 共享变量，使用 volatile 修饰保证线程可见性
private volatile int state;
 “`
Java锁",
AQS 对资源的共享模式有哪些？,"Exclusive（独占）：只有一个线程能执行，如：ReentrantLock，又可分为公平锁和非公平锁：
Share（共享）：多个线程可同时执行，如：CountDownLatch、Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock。
Java锁",
AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗？,"使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。
isHeldExclusively() ：该线程是否正在独占资源。只有用到 condition 才需要去实现它。
tryAcquire(int) ：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。
tryRelease(int) ：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。
tryAcquireShared(int) ：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
Java锁",
说下对信号量 Semaphore 的理解？,"synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore (信号量)可以指定多个线程同时访问某个资源。
执行 acquire 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 release 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。Semaphore 经常用于限制获取某种资源的线程数量。当然一次也可以一次拿取和释放多个许可证，不过一般没有必要这样做。除了 acquire方法（阻塞）之外，另一个比较常用的与之对应的方法是 tryAcquire 方法，该方法如果获取不到许可就立即返回 false。
Java锁",
CountDownLatch 和 CyclicBarrier 有什么区别？,"CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。
对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。
CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。
CountDownLatch 应用场景：
1、某一线程在开始运行前等待 n 个线程执行完毕：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。
2、实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。
3、死锁检测：一个非常方便的使用场景是，你可以使用 n 个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。
CyclicBarrier  应用场景：
CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如：我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。
Java锁",
说下对线程池的理解？为什么要使用线程池？,"线程池提供了一种限制和管理资源（包括执行一个任务）的方式。每个线程池还维护一些基本统计信息，例如：已完成任务的数量。
1、降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗;
2、 提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行;
3、 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
Java锁",
创建线程池的参数有哪些？,"1、 corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前 poolSize < corePoolSize 时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads() 方法，线程池会提前创建并启动所有基本线程。
2、 maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。
3、 keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。
4、 TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。
5、 workQueue（任务队列）：用于保存等待执行的任务的阻塞队列。
可以选择以下几个阻塞队列：
1）、 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
2）、LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按 FIFO 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool() 使用了这个队列。
3）、SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。
4）、 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。
6、 threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。
7、RejectExecutionHandler（饱和策略）：队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。
饱和策略：
在 JDK1.5 中 Java 线程池框架提供了以下 4 种策略：
CallerRunsPolicy：只用调用者所在线程来运行任务。
DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
DiscardPolicy：不处理，丢弃掉。
当然，也可以根据应用场景需要来实现RejectedExecutionHandler 接口自定义策略。如记录日志或持久化存储不能处理的任务。
Java锁",
如何创建线程池？,"方式一：通过 ThreadPoolExecutor 的构造方法实现：

方式二：通过 Executor 框架的工具类 Executors 来实现：
我们可以创建三种类型的 ThreadPoolExecutor：
1、FixedThreadPool：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
2、 SingleThreadExecutor：方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先进先出的顺序执行队列中的任务。
3、CachedThreadPool：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。
注意：
阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
Executors 创建线程池对象的弊端如下：
FixedThreadPool 和 SingleThreadExecutor ：允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。
Java锁",
线程池中的的线程数一般怎么设置？需要考虑哪些问题？,"主要考虑下面几个方面：
计算密集型的任务比较占 cpu，所以一般线程数设置的大小 等于或者略微大于 cpu 的核数；但 IO 型任务主要时间消耗在 IO 等待上，cpu 压力并不大，所以线程数一般设置较大。
当线程数设置较大时，会有如下几个问题：第一，线程的初始化，切换，销毁等操作会消耗不小的 cpu 资源，使得 cpu 利用率一直维持在较高水平。第二，线程数较大时，任务会短时间迅速执行，任务的集中执行也会给 cpu 造成较大的压力。第三， 任务的集中支持，会让 cpu 的使用率呈现锯齿状，即短时间内 cpu 飙高，然后迅速下降至闲置状态，cpu 使用的不合理，应该减小线程数，让任务在队列等待，使得 cpu 的使用率应该持续稳定在一个合理，平均的数值范围。所以 cpu 在够用时，不宜过大，不是越大越好。可以通过上线后，观察机器的 cpu 使用率和 cpu 负载两个参数来判断线程数是否合理。
线程数过多和队列的大小都会影响此项数据，队列的大小应该通过前期计算线程池任务的条数，来合理的设置队列的大小，不宜过小，让其不会溢出，因为溢出会走拒绝策略，多少会影响性能，也会增加复杂度。
多线程给下游系统造成的并发等于你设置的线程数，例如：如果是多线程访问数据库，你就考虑数据库的连接池大小设置，数据库并发太多影响其 QPS，会把数据库打挂等问题。如果访问的是下游系统的接口，你就得考虑下游系统是否能抗的住这么多并发量，不能把下游系统打挂了。
Java锁",
执行 execute() 方法和 submit() 方法的区别是什么呢？,"1、 execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；
2、 submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，而使用 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。
Java锁",
说下对 Fork和Join 并行计算框架的理解？,"Fork/Join 并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小的子任务的结果聚合起来从而得到最终结果。
Fork/Join 并行计算框架的核心组件是 ForkJoinPool。ForkJoinPool 支持任务窃取机制，能够让所有的线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的情况，所以性能很好。
ForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。
Java锁",
JDK 中提供了哪些并发容器？,"JDK 提供的这些容器大部分在 java.util.concurrent 包中。
ConcurrentHashMap：线程安全的 HashMap；
CopyOnWriteArrayList：线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector；
ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列；
BlockingQueue：这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道；
ConcurrentSkipListMap：跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。
Java锁",
谈谈对 CopyOnWriteArrayList 的理解？,"在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问 List 的内部数据，毕竟读取操作是安全的。
CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我们并不需要修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。
从 CopyOnWriteArrayList 的名字就能看出 CopyOnWriteArrayList 是满足 CopyOnWrite 的 ArrayList，所谓 CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。
CopyOnWriteArrayList 读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。
CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。
Java锁",
谈谈对 BlockingQueue 的理解？分别有哪些实现类？,"阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。
BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 的相关实现类：

Java锁",
谈谈对 ConcurrentSkipListMap 的理解？,"对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。
但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 O(logn) 。跳表的本质是同时维护了多个链表，并且链表是分层的。
Java锁",
Java并发,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里：Java并发面试题阅读指南
Java并发面试题阅读指南
Java锁",
Java并发面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 并行和并发有什么区别？
1. 并行和并发有什么区别？
2. 线程和进程的区别？
2. 线程和进程的区别？
3. 守护线程是什么？
3. 守护线程是什么？
4. 创建线程的几种方式？
4. 创建线程的几种方式？
5. Runnable 和 Callable 有什么区别？
5. Runnable 和 Callable 有什么区别？
6. 线程状态及转换？
6. 线程状态及转换？
7. sleep() 和 wait() 的区别？
7. sleep() 和 wait() 的区别？
8. 线程的 run() 和 start() 有什么区别？
8. 线程的 run() 和 start() 有什么区别？
9. 在 Java 程序中怎么保证多线程的运行安全？
9. 在 Java 程序中怎么保证多线程的运行安全？
10. Java 线程同步的几种方法？
10. Java 线程同步的几种方法？
11. Thread.interrupt() 方法的工作原理是什么？
11. Thread.interrupt() 方法的工作原理是什么？
12. 谈谈对 ThreadLocal 的理解？
12. 谈谈对 ThreadLocal 的理解？
13. 在哪些场景下会使用到 ThreadLocal？
13. 在哪些场景下会使用到 ThreadLocal？
14. 说一说自己对于 synchronized 关键字的了解？
14. 说一说自己对于 synchronized 关键字的了解？
15. 如何在项目中使用 synchronized 的？
15. 如何在项目中使用 synchronized 的？
16. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？
16. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？
17. 谈谈 synchronized 和 ReenTrantLock 的区别？
17. 谈谈 synchronized 和 ReenTrantLock 的区别？
18. synchronized 和 volatile 的区别是什么？
18. synchronized 和 volatile 的区别是什么？
19. 谈一下你对 volatile 关键字的理解？
19. 谈一下你对 volatile 关键字的理解？
20. 说下对 ReentrantReadWriteLock 的理解？
20. 说下对 ReentrantReadWriteLock 的理解？
21. 说下对悲观锁和乐观锁的理解？
21. 说下对悲观锁和乐观锁的理解？
22. 乐观锁常见的两种实现方式是什么？
22. 乐观锁常见的两种实现方式是什么？
23. 乐观锁的缺点有哪些？
23. 乐观锁的缺点有哪些？
24. CAS 和 synchronized 的使用场景？
24. CAS 和 synchronized 的使用场景？
25. 简单说下对 Java 中的原子类的理解？
25. 简单说下对 Java 中的原子类的理解？
26. atomic 的原理是什么？
26. atomic 的原理是什么？
27. 说下对同步器 AQS 的理解？
27. 说下对同步器 AQS 的理解？
28. AQS 的原理是什么？
28. AQS 的原理是什么？
29. AQS 对资源的共享模式有哪些？
29. AQS 对资源的共享模式有哪些？
30. AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗？
30. AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗？
31. 说下对信号量 Semaphore 的理解？
31. 说下对信号量 Semaphore 的理解？
32. CountDownLatch 和 CyclicBarrier 有什么区别？
32. CountDownLatch 和 CyclicBarrier 有什么区别？
33. 说下对线程池的理解？为什么要使用线程池？
33. 说下对线程池的理解？为什么要使用线程池？
34. 创建线程池的参数有哪些？
34. 创建线程池的参数有哪些？
35. 如何创建线程池？
35. 如何创建线程池？
36. 线程池中的的线程数一般怎么设置？需要考虑哪些问题？
36. 线程池中的的线程数一般怎么设置？需要考虑哪些问题？
37. 执行 execute() 方法和 submit() 方法的区别是什么呢？
37. 执行 execute() 方法和 submit() 方法的区别是什么呢？
38. 说下对 Fork和Join 并行计算框架的理解？
38. 说下对 Fork和Join 并行计算框架的理解？
39. JDK 中提供了哪些并发容器？
39. JDK 中提供了哪些并发容器？
40. 谈谈对 CopyOnWriteArrayList 的理解？
40. 谈谈对 CopyOnWriteArrayList 的理解？
41. 谈谈对 BlockingQueue 的理解？分别有哪些实现类？
41. 谈谈对 BlockingQueue 的理解？分别有哪些实现类？
42. 谈谈对 ConcurrentSkipListMap 的理解？
42. 谈谈对 ConcurrentSkipListMap 的理解？
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
Java锁",
Java 中常用的容器有哪些？,"常见容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表

Vection的非线程安全操作
Java集合",
ArrayList 和 LinkedList 的区别？,"ArrayList：底层是基于数组实现的，查找快，增删较慢；
LinkedList：底层是基于链表实现的。确切的说是循环双向链表（JDK1.6 之前是双向循环链表、JDK1.7 之后取消了循环），查找慢、增删快。LinkedList 链表由一系列表项连接而成，一个表项包含 3 个部分：元素内容、前驱表和后驱表。链表内部有一个 header 表项，既是链表的开始也是链表的结尾。header 的后继表项是链表中的第一个元素，header 的前驱表项是链表中的最后一个元素。
ArrayList 的增删未必就是比 LinkedList 要慢：
如果增删都是在末尾来操作【每次调用的都是 remove() 和 add()】，此时 ArrayList 就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比 LinkedList 要快的。
如果删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上，ArrayList 的消耗主要是在移动和复制上（底层调用的是 arraycopy() 方法，是 native 方法）。LinkedList 的遍历速度是要慢于 ArrayList 的复制移动速度的如果数据量有百万级的时，还是 ArrayList 要快。
Java集合",
ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？,"RandomAccess 接口只是一个标志接口，只要 List 集合实现这个接口，就能支持快速随机访问。通过查看 Collections 类中的 binarySearch() 方法，可以看出，判断 List 是否实现 RandomAccess 接口来实行indexedBinarySerach(list, key) 或 iteratorBinarySerach(list, key)方法。再通过查看这两个方法的源码发现：实现 RandomAccess 接口的 List 集合采用一般的 for 循环遍历，而未实现这接口则采用迭代器，即 ArrayList 一般采用 for 循环遍历，而 LinkedList 一般采用迭代器遍历；
ArrayList 用 for 循环遍历比 iterator 迭代器遍历快，LinkedList 用 iterator 迭代器遍历比 for 循环遍历快。所以说，当我们在做项目时，应该考虑到 List 集合的不同子类采用不同的遍历方式，能够提高性能。
Java集合",
ArrayList 的扩容机制？,"推荐阅读：
https://juejin.im/post/5d42ab5e5188255d691bc8d6
Java集合",
Array 和 ArrayList 有何区别？什么时候更适合用 Array？,"什么时候更适合使用 Array：
Java集合",
HashMap 的实现原理/底层数据结构？JDK1.7 和 JDK1.8,"JDK1.7：Entry数组 + 链表
JDK1.8：Node 数组 + 链表/红黑树，当链表上的元素个数超过 8 个并且数组长度 >= 64 时自动转化成红黑树，节点变成树节点，以提高搜索效率和插入效率到 O(logN)。Entry 和 Node 都包含 key、value、hash、next 属性。
Java集合",
HashMap 的 put 方法的执行过程？,"当我们想往一个 HashMap 中添加一对 key-value 时，系统首先会计算 key 的 hash 值，然后根据 hash 值确认在 table 中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依次比较其 key 的 hash 值。如果两个 hash 值相等且 key 值相等(e.hash = = hash && ((k = e.key) = = key || key.equals(k)))，则用新的 Entry 的 value 覆盖原来节点的 value。如果两个 hash 值相等但 key 值不等 ，则进行插入操作。
不过呢，插入操作在 JDK1.7 和 JDK1.8 是有所不同的，JDK1.7 底层采用数组+链表，插入时采用头插法，JDK1.8，底层采用数组 + 链表 / 红黑树，并且把头插法改成了尾插法，主要是为了减少线程安全的问题，另外，当链表长度大于8，且数组长度大于64时，会把链表转化为红黑树处理，这个时候，就无关是头插还是尾插了，得按照红黑树的规则来插了。
Java集合",
HashMap 的 get 方法的执行过程？,"通过 key 的 hash 值找到在 table 数组中的索引处的 Entry，然后返回该 key 对应的 value 即可。
在这里能够根据 key 快速的取到 value 除了和 HashMap 的数据结构密不可分外，还和 Entry 有莫大的关系。HashMap 在存储过程中并没有将 key，value 分开来存储，而是当做一个整体 key-value 来处理的，这个整体就是Entry 对象。同时 value 也只相当于 key 的附属而已。在存储的过程中，系统根据 key 的 HashCode 来决定 Entry 在 table 数组中的存储位置，在取的过程中同样根据 key 的 HashCode 取出相对应的 Entry 对象（value 就包含在里面）。
Java集合",
HashMap 的 resize 方法的执行过程？,"有两种情况会调用 resize 方法：
扩容时会调用 resize，即 size > threshold 时，table 数组大小翻倍。
每次扩容之后容量都是翻倍。扩容后要将原数组中的所有元素找到在新数组中合适的位置。
当我们把 table[i] 位置的所有 Node 迁移到 newtab 中去的时候：这里面的 node 要么在 newtab 的 i 位置（不变），要么在 newtab 的 i + n 位置。也就是我们可以这样处理：把 table[i] 这个桶中的 node 拆分为两个链表 l1 和 l2：如果 hash & n = = 0，那么当前这个 node 被连接到 l1 链表；否则连接到 l2 链表。这样下来，当遍历完 table[i] 处的所有 node 的时候，我们得到两个链表 l1 和 l2，这时我们令 newtab[i] = l1，newtab[i + n] = l2，这就完成了 table[i] 位置所有 node 的迁移（rehash），这也是 HashMap 中容量一定的是 2 的整数次幂带来的方便之处。
Java集合",
HashMap 的 size 为什么必须是 2 的整数次方？,Java集合,
HashMap 的 get 方法能否判断某个元素是否在 map 中？,"HashMap 的 get 函数的返回值不能判断一个 key 是否包含在 map 中，因为 get 返回 null 有可能是不包含该 key，也有可能该 key 对应的 value 为 null。因为 HashMap 中允许 key 为 null，也允许 value 为 null。
Java集合",
HashMap 与 HashTable 的区别是什么？,"HashTable的补充：
HashTable 和 HashMap 的实现原理几乎一样，差别无非是
HashTable 不允许 key 和 value 为 null；
HashTable 是线程安全的。但是 HashTable 线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。
Java集合",
HashMap 与 ConcurrentHashMap 的区别是什么?,"HashMap 不是线程安全的，而 ConcurrentHashMap 是线程安全的。
ConcurrentHashMap 采用锁分段技术，将整个Hash桶进行了分段segment，也就是将这个大的数组分成了几个小的片段 segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁，这样做明显减小了锁的粒度。
Java集合",
HashTable 和 ConcurrentHashMap 的区别？,"HashTable 和 ConcurrentHashMap 相比，效率低。 Hashtable 之所以效率低主要是使用了 synchronized 关键字对 put 等操作进行加锁，而 synchronized 关键字加锁是对整张 Hash 表的，即每次锁住整张表让线程独占，致使效率低下，而 ConcurrentHashMap 在对象中保存了一个 Segment 数组，即将整个 Hash 表划分为多个分段；
而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行 put 操作时首先根据 hash 算法定位到元素属于哪个 Segment，然后对该 Segment 加锁即可，因此， ConcurrentHashMap 在多线程并发编程中可是实现多线程 put操作。
Java集合",
ConcurrentHashMap 的实现原理是什么？,"数据结构
JDK 7：中 ConcurrentHashMap 采用了数组 + Segment + 分段锁的方式实现。
JDK 8：中 ConcurrentHashMap 参考了 JDK 8 HashMap 的实现，采用了数组 + 链表 + 红黑树的实现方式来设计，内部大量采用 CAS 操作。
ConcurrentHashMap 采用了非常精妙的”分段锁”策略，ConcurrentHashMap 的主干是个 Segment 数组。
Segment 继承了 ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在 ConcurrentHashMap，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，并发环境下，对于不同 Segment 的数据进行操作是不用考虑锁竞争的。就按默认的 ConcurrentLevel 为 16 来讲，理论上就允许 16 个线程并发执行。
所以，对于同一个 Segment 的操作才需考虑线程同步，不同的 Segment 则无需考虑。Segment 类似于 HashMap，一个 Segment 维护着一个HashEntry 数组：
HashEntry 是目前我们提到的最小的逻辑处理单元了。一个 ConcurrentHashMap 维护一个 Segment 数组，一个 Segment 维护一个 HashEntry 数组。因此，ConcurrentHashMap 定位一个元素的过程需要进行两次 Hash 操作。第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。
Java集合",
HashSet 的实现原理？,"HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复。因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。
Java集合",
HashSet 怎么保证元素不重复的？,"元素值作为的是 map 的 key，map 的 value 则是 PRESENT 变量，这个变量只作为放入 map 时的一个占位符而存在，所以没什么实际用处。其实，这时候答案已经出来了：HashMap 的 key 是不能重复的，而这里HashSet 的元素又是作为了 map 的 key，当然也不能重复了。
Java集合",
LinkedHashMap 的实现原理?,"LinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header，这个 header 不是放在 Table 里，它是额外独立出来的。LinkedHashMap 通过继承 hashMap 中的 Entry，并添加两个属性 Entry before，after 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。
LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。
Java集合",
Iterator 怎么使用？有什么特点？,"迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。Java 中的 Iterator 功能比较简单，并且只能单向移动：　　
Java集合",
Iterator 和 ListIterator 有什么区别？,"Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。
Java集合",
Iterator 和 Enumeration 接口的区别？,"与 Enumeration 相比，Iterator 更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。否则会抛出 ConcurrentModificationException 异常。这其实就是 fail-fast 机制。具体区别有三点：
Java集合",
fail-fast 与 fail-safe 有什么区别？,"Iterator 的 fail-fast 属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util 包中的所有集合类都被设计为 fail-fast 的，而 java.util.concurrent 中的集合类都为 fail-safe 的。当检测到正在遍历的集合的结构被改变时，fail-fast 迭代器抛出ConcurrentModificationException，而 fail-safe 迭代器从不抛出 ConcurrentModificationException。
Java集合",
Collection 和 Collections 有什么区别？,"Collection：是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素。它的直接继承接口有 List，Set 和 Queue。
Collections：是不属于 Java 的集合框架的，它是集合类的一个工具类/帮助类。此类不能被实例化， 服务于 Java 的 Collection 框架。它包含有关集合操作的静态多态方法，实现对各种集合的搜索、排序、线程安全等操作。
Java集合",
Java集合,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里： Java集合面试题阅读指南
 Java集合面试题阅读指南
Java集合",
Java集合面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. Java 中常用的容器有哪些？
1. Java 中常用的容器有哪些？
2. ArrayList 和 LinkedList 的区别？
2. ArrayList 和 LinkedList 的区别？
3. ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？
3. ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？
4. ArrayList 的扩容机制？
4. ArrayList 的扩容机制？
5. Array 和 ArrayList 有何区别？什么时候更适合用 Array？
5. Array 和 ArrayList 有何区别？什么时候更适合用 Array？
6. HashMap 的实现原理/底层数据结构？JDK1.7 和 JDK1.8
6. HashMap 的实现原理/底层数据结构？JDK1.7 和 JDK1.8
7. HashMap 的 put 方法的执行过程？
7. HashMap 的 put 方法的执行过程？
8. HashMap 的 get 方法的执行过程？
8. HashMap 的 get 方法的执行过程？
9. HashMap 的 resize 方法的执行过程？
9. HashMap 的 resize 方法的执行过程？
10. HashMap 的 size 为什么必须是 2 的整数次方？
10. HashMap 的 size 为什么必须是 2 的整数次方？
11. HashMap 多线程死循环问题？
11. HashMap 多线程死循环问题？
12. HashMap 的 get 方法能否判断某个元素是否在 map 中？
12. HashMap 的 get 方法能否判断某个元素是否在 map 中？
13. HashMap 与 HashTable 的区别是什么？
13. HashMap 与 HashTable 的区别是什么？
14. HashMap 与 ConcurrentHashMap 的区别是什么?
14. HashMap 与 ConcurrentHashMap 的区别是什么?
15. HashTable 和 ConcurrentHashMap 的区别？
15. HashTable 和 ConcurrentHashMap 的区别？
16. ConcurrentHashMap 的实现原理是什么？
16. ConcurrentHashMap 的实现原理是什么？
17. HashSet 的实现原理？
17. HashSet 的实现原理？
18. HashSet 怎么保证元素不重复的？
18. HashSet 怎么保证元素不重复的？
19. LinkedHashMap 的实现原理?
19. LinkedHashMap 的实现原理?
20. Iterator 怎么使用？有什么特点？
20. Iterator 怎么使用？有什么特点？
21. Iterator 和 ListIterator 有什么区别？
21. Iterator 和 ListIterator 有什么区别？
22. Iterator 和 Enumeration 接口的区别？
22. Iterator 和 Enumeration 接口的区别？
23. fail-fast 与 fail-safe 有什么区别？
23. fail-fast 与 fail-safe 有什么区别？
24. Collection 和 Collections 有什么区别？
24. Collection 和 Collections 有什么区别？
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
Java集合",
JDK1.8之后，HashMap头插法改为尾插法？,"1.头插法在并发下有致命问题，就是可能形成数据环，get 数据时死循环，而在 1.8 之前因为处理 hash 冲突的方式是用链表存放数据，使用头插法可以提升一定效率。
但是在 1.8 之后这个效率提升就可有可无了，链表长度超过 7 就要考虑升级红黑树了，所以哪怕进行尾插遍历次数也会很有限，效率影响不大。
2.就是因为 1.8 之后数据结构的变动，当链表长度达到阈值，升级为红黑树后头插法就不适用了，因为构建红黑树需要进行比对更新序列，也就不能去说是头插法还是尾插了
Java集合",
JavaSe面试题分类阅读指南(附答案),"大家好，我是帅地。
由于 Java 内容较多，为了方便大家复习，这里采取了分类阅读的方式
 Java基础面试题阅读指南
 Java基础面试题阅读指南
 Java集合面试题阅读指南
 Java集合面试题阅读指南
Java并发面试题阅读指南
Java并发面试题阅读指南
JVM 面试题阅读指南
JVM 面试题阅读指南
同时帅地也上线了配套小程序哦

持续更新～持续更新～持续更新～
记得收藏呀
Java面试题",
