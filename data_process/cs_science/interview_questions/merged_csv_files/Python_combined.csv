问题,回答,所属分类
Python面试题分类阅读指南(附答案),"大家好，我是帅地。
这里会汇总 Python 各类面试题，包括爬虫，Python 机器学习等，由于 Python 后面内容会越来越多，为了方便大家复习，这里采取了分类阅读的方式
Python 基础面试题阅读指南（必看）
Python 基础面试题阅读指南（必看）
Python 进阶面试题阅读指南（必看）
Python 进阶面试题阅读指南（必看）
Python 后台开发面试题阅读指南（必看）
Python 后台开发面试题阅读指南（必看）
Python 爬虫面试题阅读指南（必看）
Python 爬虫面试题阅读指南（必看）
Python 机器学习面试题阅读指南（必看）
Python 机器学习面试题阅读指南（必看）
Python
Python面试题",
Python 后台开发面试题阅读指南（必看）,"大家好，我是帅地。 为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。 由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. Flask 中请求上下文和应用上下文的区别和作用？
1. Flask 中请求上下文和应用上下文的区别和作用？
2. 对 Flask 蓝图(Blueprint)的理解？
2. 对 Flask 蓝图(Blueprint)的理解？
3. Flask 项目中如何实现 session 信息的写入？
3. Flask 项目中如何实现 session 信息的写入？
4. 项目接口实现后路由访问不到怎么办？
4. 项目接口实现后路由访问不到怎么办？
5. Flask 中 url_for 函数？
5. Flask 中 url_for 函数？
6. Flask 中请求钩子的理解和应用？
6. Flask 中请求钩子的理解和应用？
7. 一个变量后写多个过滤器是如何执行的？
7. 一个变量后写多个过滤器是如何执行的？
8. 如何把整个数据库导出来，再导入指定数据库中？
8. 如何把整个数据库导出来，再导入指定数据库中？
9. Flask 和 Django 路由映射的区别？
9. Flask 和 Django 路由映射的区别？
10. 跨站请求伪造和跨站请求保护的实现？
10. 跨站请求伪造和跨站请求保护的实现？
11. Flask(name)中的name可以传入哪些值？
11. Flask(name)中的name可以传入哪些值？
12. Django 创建项目的命令？
12. Django 创建项目的命令？
13. Django 创建项目后，项目文件夹下的组成部分（对 mvt 的理解）？
13. Django 创建项目后，项目文件夹下的组成部分（对 mvt 的理解）？
14. 对 MVC,MVT 解读的理解？
14. 对 MVC,MVT 解读的理解？
15. Django 中 models 利用 ORM 对 Mysql 进行查表的语句（多个语句）
15. Django 中 models 利用 ORM 对 Mysql 进行查表的语句（多个语句）
16. django 中间件的使用？
16. django 中间件的使用？
17. Django 项目的优化？
17. Django 项目的优化？
18. 谈一下你对 uWSGI 和 nginx 的理解？
18. 谈一下你对 uWSGI 和 nginx 的理解？
19. 说说 nginx 和 uWISG 服务器之间如何配合工作的？
19. 说说 nginx 和 uWISG 服务器之间如何配合工作的？
20. django 开发中数据库做过什么优化?
20. django 开发中数据库做过什么优化?
21. 验证码过期时间怎么设置？
21. 验证码过期时间怎么设置？
22. Python 中 Django、Flask、Tornado 三大框架各自的应用场景？
22. Python 中 Django、Flask、Tornado 三大框架各自的应用场景？
23. django 如何提升性能？
23. django 如何提升性能？
24. 什么是 restful api，谈谈你的理解?
24. 什么是 restful api，谈谈你的理解?
25. 启动 Django 服务的方法？
25. 启动 Django 服务的方法？
26. 怎样测试 django 框架中的代码？
26. 怎样测试 django 框架中的代码？
27. 有过部署经验？用的什么技术？可以满足多少压力？
27. 有过部署经验？用的什么技术？可以满足多少压力？
28. Django 中哪里用到了线程?哪里用到了协程?哪里用到了进程？
28. Django 中哪里用到了线程?哪里用到了协程?哪里用到了进程？
29. django 关闭浏览器，怎样清除 cookies 和 session？
29. django 关闭浏览器，怎样清除 cookies 和 session？
30. 代码优化从哪些方面考虑？有什么想法？
30. 代码优化从哪些方面考虑？有什么想法？
31. Django 中间件是如何使用的？
31. Django 中间件是如何使用的？
32. ngnix 的正向代理与反向代理?
32. ngnix 的正向代理与反向代理?
33. 简述 Django 下的（内建的）缓存机制?
33. 简述 Django 下的（内建的）缓存机制?
34. Django HTTP 请求的处理流程？
34. Django HTTP 请求的处理流程？
35. Django 里 QuerySet 的 get 和 filter 方法的区别？
35. Django 里 QuerySet 的 get 和 filter 方法的区别？
36. 跨域请求问题 django 怎么解决的？
36. 跨域请求问题 django 怎么解决的？
37. Django 对数据查询结果排序怎么做，降序怎么做，查询大于某个字段怎么做？
37. Django 对数据查询结果排序怎么做，降序怎么做，查询大于某个字段怎么做？
38. Django 重定向你是如何实现的？用的什么状态码？
38. Django 重定向你是如何实现的？用的什么状态码？
39. 生成迁移文件和执行迁移文件的命令是什么？
39. 生成迁移文件和执行迁移文件的命令是什么？
40. 关系型数据库的关系包括哪些类型？
40. 关系型数据库的关系包括哪些类型？
41. 查询集返回列表的过滤器有哪些？
41. 查询集返回列表的过滤器有哪些？
42. Django 本身提供了 runserver，为什么不能用来部署？
42. Django 本身提供了 runserver，为什么不能用来部署？
43. HttpRequest 和 HttpResponse 是什么？干嘛用的？
43. HttpRequest 和 HttpResponse 是什么？干嘛用的？
44. Django 日志管理
44. Django 日志管理
Python后台开发

ㅤ普通",
Flask 中请求上下文和应用上下文的区别和作用？,"current_app、g 是应用上下文。
request、session 是请求上下文。
手动创建上下文的两种方法：
两者区别：
请求上下文：保存了客户端和服务器交互的数据。
应用上下文：flask 应用程序运行过程中，保存的一些配置信息，比如程序名、数据库连接、应用 信息等。
两者作用：
请求上下文(request context)：Flask 从客户端收到请求时，要让视图函数能访问一些对象，这样才能处理请求。请求对象是一个很好的例子，它封装了客户端发送的 HTTP 请求。要想让视图函数能够访问请求对象，一个显而易见的方式是将其作为参数传入视图函数，不过这会导致程序中的每个视图函数都增加一个参数，除了访问请求对象,如果视图函数在处理请求时还要访问其他对象，情况会变得更糟。为了避免大量可有可无的参数把视图函数弄得一团糟，Flask使用上下文临时把某些对象变为全局可访问。
应用上下文(application context)：它的字面意思是 应用上下文，但它不是一直存在的，它只是 request context 中的一个对 app 的代理(人)，所谓 local proxy。它的作用主要是帮助 request 获取当前的应用，它是伴 request 而生，随 request 而灭的。
Python后台开发

ㅤ普通",
对 Flask 蓝图(Blueprint)的理解？,"蓝图的定义
蓝图 /Blueprint 是 Flask 应用程序组件化的方法，可以在一个应用内或跨越多个项目共用蓝图。使用蓝图可以极大地简化大型应用的开发难度，也为 Flask 扩展 提供了一种在应用中注册服务的集中式机制。
蓝图的应用场景
(1) 把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。
(2) 以 URL 前缀和/或子域名，在应用上注册一个蓝图。 URL 前缀/子域名中的参数即成为这个蓝 图下的所有视图函数的共同的视图参数（默认情况下）。
(3) 在一个应用中用不同的 URL 规则多次注册一个蓝图。
(4) 通过蓝图提供模板过滤器、静态文件、模板和其它功能。一个蓝图不一定要实现应用或者视图函 数。
(5) 初始化一个 Flask 扩展时，在这些情况中注册一个蓝图。
蓝图的缺点
不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。
使用蓝图的三个步骤
(1) 创建一个蓝图对象
(2) 在这个蓝图对象上进行操作 ，例如注册路由、指定静态文件夹、注册模板过滤器…
(3) 在应用对象上注册这个蓝图对象
Python后台开发

ㅤ普通",
Flask 项目中如何实现 session 信息的写入？,"Flask 中有三个 session：
(1) 数据库中的 session，例如:db.session.add()
(2)在 flask_session 扩展中的 session，使用：from flask_session importSession，使用第三方扩展的 session 可以把信息存储在服务器中，客户端浏览器中只存储 sessionid
(3) flask 自带的 session，是一个请求上下文， 使用：from flask import session。自带的session 把信息加密后都存储在客户端的浏览器 cookie 中。
Python后台开发

ㅤ普通",
项目接口实现后路由访问不到怎么办？,"可以通过 postman 测试工具测试，或者看 log 日志信息找到错误信息的大概位置。
Python后台开发

ㅤ普通",
Flask 中 url_for 函数？,"URL 反转：根据视图函数名称得到当前所指向的 url。
url_for() 函数最简单的用法是以视图函数名作为参数，返回对应的 url，还可以用作加载静态文件。
该条语句就是在模版中加载 css 静态文件。
url_for 和 redirect 区别
url_for 是用来拼接 URL 的，可以使用程序 URL 映射中保存的信息生成 URL。
url_for() 函数最简单的用法是以视图函数名作为参数， 返回对应的 URL。例如，在示例程序中 hello.py 中调用 url_for(‘index’) 得到的结果是 /。
redirect 是重定向函数，输入一个 URL 后，自动跳转到另一个 URL 所在的地址，例如，你在函数中写 return redirect(‘https://www.baidu.com’) 页面就会跳转向百度页面。
Python后台开发

ㅤ普通",
Flask 中请求钩子的理解和应用？,"请求钩子是通过装饰器的形式实现的，支持以下四种：

  before_first_request 在处理第一个请求前运行 before_request 在每次请求前运行 after_request 如果没有未处理的异常抛出，在每次请求后运行 teardown_request 即使有未处理的异常抛出，在每次请求后运行

应用：
请求钩子
Python后台开发

ㅤ普通",
一个变量后写多个过滤器是如何执行的？,"{{ expression | filter1 | filter2 | … }} 即表达式(expression)使用 filter1 过滤后再使用 filter2 过滤。
Python后台开发

ㅤ普通",
如何把整个数据库导出来，再导入指定数据库中？,"导出
导入指定的数据库中:
第一种方法：
第二种方法：
先创建好数据库，因为导出的文件里没有创建数据库的语句，如果数据库已经建好，则不用再创建。
切换数据库：
导入指定 sql 文件：
Python后台开发

ㅤ普通",
Flask 和 Django 路由映射的区别？,"在 django 中，路由是浏览器访问服务器时，先访问的项目中的 url，再由项目中的 url 找到应用 url，这些 url 是放在一个列表里，遵从从前往后匹配的规则。在 flask 中，路由是通过装饰器给每个视图函数提供的，而且根据请求方式的不同可以一个 url 用于不同的作用。
Python后台开发

ㅤ普通",
跨站请求伪造和跨站请求保护的实现？,"图中 Browse 是浏览器，WebServerA 是受信任网站/被攻击网站 A，WebServerB 是恶意网站/点击网站 B。
（1）一开始用户打开浏览器，访问受信任网站 A，输入用户名和密码登陆请求登陆网站 A。
（2）网站 A 验证用户信息，用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器。
（3）用户登陆网站 A 成功后，可以正常请求网站 A。
（4）用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 访问网站 B。
（5）网站 B 看到有人方式后，他会返回一些攻击性代码。
（6）浏览器在接受到这些攻击性代码后，促使用户不知情的情况下浏览器携带 Cookie（包括  sessionId）信息，请求网站 A。这种请求有可能更新密码，添加用户什么的操作。
从上面 CSRF 攻击原理可以看出，要完成一次 CSRF 攻击，需要被攻击者完成两个步骤：
(1) 登陆受信任网站 A，并在本地生成 COOKIE。 (2) 在不登出 A 的情况下，访问危险网站 B。
如果不满足以上两个条件中的一个，就不会受到 CSRF 的攻击，以下情况可能会导致 CSRF：
(1) 登录了一个网站后，打开一个 tab 页面并访问另外的网站。
(2) 关闭浏览器了后，本地的 Cookie 尚未过期，你上次的会话还没有已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）
解决办法：就是在表单中添加 from.csrf_token。
Python后台开发

ㅤ普通",
Flask(name)中的name可以传入哪些值？,"可以传入的参数：
(1) 字符串：‘hello’, 但是‘abc’,不行，因为 abc 是 python 内置的模块
(2) name，约定俗成
不可以传入的参数：
(1) python 内置的模块，re,urllib,abc 等
(2) 数字
Python后台开发

ㅤ普通",
Django 创建项目的命令？,"django-admin startproject 项目名称
python manage.py startapp 应用 app 名
Python后台开发

ㅤ普通",
Django 创建项目后，项目文件夹下的组成部分（对 mvt 的理解）？,"项目文件夹下的组成部分：
manage.py 是项目运行的入口，指定配置文件路径。
与项目同名的目录，包含项目的配置文件。
___init.py 是一个空文件，作用是这个目录可以被当作包使用。
settings.py 是项目的整体配置文件。
urls.py 是项目的 URL 配置文件。
wsgi.py 是项目与 WSGI 兼容的 Web 服务器。
Python后台开发

ㅤ普通",
"对 MVC,MVT 解读的理解？","M：Model，模型，和数据库进行交互
V：View，视图，负责产生 Html 页面
C：Controller，控制器，接收请求，进行处理，与 M 和 V 进行交互，返回应答。


1 用户点击注按钮，将要注册的信息发送给网站服务器。
2 Controller 控制器接收到用户的注册信息，Controller 会告诉 Model 层将用户的注册信息保 存到数据库
3 Model 层将用户的注册信息保存到数据库
4 数据保存之后将保存的结果返回给 Model 模型
5 Model 层将保存的结果返回给 Controller 控制器
6 Controller 控制器收到保存的结果之后，或告诉 View 视图，view 视图产生一个 html 页面
7 View 将产生的 Html 页面的内容给了 Controller 控制器
8 Controller 将 Html 页面的内容返回给浏览器
9 浏览器接受到服务器 Controller 返回的 Html 页面进行解析展示
M：Model，模型，和 MVC 中的 M 功能相同，和数据库进行交互
V：view，视图，和 MVC 中的 C 功能相同，接收请求，进行处理，与 M 和 T 进行交互，返回应答
T：Template，模板，和 MVC 中的 V 功能相同，产生 Html 页面


1 用户点击注册按钮，将要注册的内容发送给网站的服务器
2 View 视图，接收到用户发来的注册数据，View 告诉 Model 将用户的注册信息保存进数据库
3 Model 层将用户的注册信息保存到数据库中
4 数据库将保存的结果返回给 Model
5 Model 将保存的结果给 View 视图
6 View 视图告诉 Template 模板去产生一个 Html 页面
7 Template 生成 html 内容返回给 View 视图
8 View 将 html 页面内容返回给浏览器
9 浏览器拿到 view 返回的 html 页面内容进行解析，展示
Python后台开发

ㅤ普通",
Django 中 models 利用 ORM 对 Mysql 进行查表的语句（多个语句）,"字段查询
all():返回模型类对应表格中的所有数据。
get():返回表格中满足条件的一条数据，如果查到多条数据，则抛异常：MultipleObjectsReturned，查询不到数据，则抛异常：DoesNotExist。
filter():参数写查询条件，返回满足条件 QuerySet 集合数据。
条件格式：
模型类属性名__条件名=值
注意：此处是模型类属性名，不是表中的字段名
关于 filter 具体案例如下：
判等 exact
模糊查询 like
例：查询书名包含’传’的图书。contains
空查询 where 字段名 isnull
范围查询 where id in (1，3，5)
比较查询 gt lt(less than) gte(equal) lte
日期查询
exclude:返回不满足条件的数据。
F 对象
作用：用于类属性之间的比较条件。
Q 对象
作用：用于查询时的逻辑条件。可以对 Q 对象进行&|~操作。
order_by 返回 QuerySet
作用：对查询结果进行排序。
聚合函数
作用：对查询结果进行聚合操作。
aggregate：调用这个函数来使用聚合。
{‘id__count’: 5} 注意返回值类型及键名
{‘bread__sum’:120} 注意返回值类型及键名
count 函数
作用：统计满足条件数据的数目。
例：统计所有图书的数目。
例：统计 id 大于 3 的所有图书的数目。
模型类关系
一对多关系
例：图书类-英雄类
models.ForeignKey() 定义在多的类中。
2）多对多关系
例：新闻类-新闻类型类
models.ManyToManyField() 定义在哪个类中都可以。
3）一对一关系
例：员工基本信息类-员工详细信息类
models.OneToOneField() 定义在哪个类中都可以。
Python后台开发

ㅤ普通",
django 中间件的使用？,"Django 在中间件中预置了六个方法，这六个方法的区别在于不同的阶段执行，对输入或输出进行干预，方法如下：
1.初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件。
2.处理请求前：在每个请求上调用，返回 None 或 HttpResponse 对象。
3.处理视图前：在每个请求上调用，返回 None 或 HttpResponse 对象。
4.处理模板响应前：在每个请求上调用，返回实现了 render 方法的响应对象。
5.处理响应后：所有响应返回浏览器之前被调用，在每个请求上调用，返回 HttpResponse 对象。
6.异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个 HttpResponse 对象。
Python后台开发

ㅤ普通",
Django 项目的优化？,"这个答案 web 通用
(1) 优化数据库查询
(2) 代码优化
Python后台开发

ㅤ普通",
谈一下你对 uWSGI 和 nginx 的理解？,"uWSGI
uWSGI 是一个 Web 服务器，它实现了 WSGI 协议、uwsgi、http 等协议。Nginx 中 HttpUwsgiModule 的作用是与 uWSGI 服务器进行交换。WSGI 是一种 Web 服务器网关接口。它是一 个 Web 服务器（如 nginx，uWSGI 等服务器）与 web 应用（如用 Flask 框架写的程序）通信的一种 规范。
要注意 WSGI / uwsgi / uWSGI 这三个概念的区分。
(1) WSGI 是一种通信协议。
(2) uwsgi 是一种线路协议而不是通信协议，在此常用于在 uWSGI 服务器与其他网络服务器的数据通信。
(3) uWSGI 是实现了 uwsgi 和 WSGI 两种协议的 Web 服务器。
ngix
nginx 是一个开源的高性能的 HTTP 服务器和反向代理：
(1) 作为 web 服务器，它处理静态文件和索引文件效果非常高；
(2) 它的设计非常注重效率，最大支持 5 万个并发连接，但只占用很少的内存空间；
(3) 稳定性高，配置简洁；
(4) 强大的反向代理和负载均衡功能，平衡集群中各个服务器的负载压力应用。
Python后台开发

ㅤ普通",
说说 nginx 和 uWISG 服务器之间如何配合工作的？,"首先浏览器发起 http 请求到 nginx 服务器，Nginx 根据接收到请求包，进行 url 分析，判断访问的资源类型。
如果是静态资源，直接读取静态资源返回给浏览器。
如果请求的是动态资源就转交给 uwsgi 服务器，uwsgi 服务器根据自身的 uwsgi 和 WSGI 协议，找到对应的 Django 框架，Django 框架下的应用进行逻辑处理后，将返回值发送到 uwsgi 服务器，然后 uwsgi 服务器再返回给 nginx，最后 nginx 将返回值返回给浏览器进行渲染显示给用户。
Python后台开发

ㅤ普通",
django 开发中数据库做过什么优化?,"(1) 设计表时，尽量少使用外键，因为外键约束会影响插入和删除性能
(2) 使用缓存，减少对数据库的访问
(3) 在 orm 框架下设置表时，能用 varchar 确定字段长度时，就别用 text
(4) 可以给搜索频率高的字段属性，在定义时创建索引
(5) Django orm 框架下的 Querysets 本来就有缓存的
(6) 如果一个页面需要多次连接数据库，最好一次性取出所有需要的数据，减少对数据库的查询次数
(7) 若页面只需要数据库里某一个两个字段时，可以用 QuerySet.values()
(8) 在模板标签里使用 with 标签可以缓存 Qset 的查询结果
Python后台开发

ㅤ普通",
验证码过期时间怎么设置？,"将验证码保存到数据库或 session，设置过期时间为 1 分钟，然后页面设置一个倒计时(一般是前端 js 实现 这个计时)的展示，一分钟过后再次点击获取新的信息。
Python后台开发

ㅤ普通",
Python 中 Django、Flask、Tornado 三大框架各自的应用场景？,"Django
主要是用来搞快速开发的，他的亮点就是快速开发，节约成本，正常的并发量不过 10000，如果要实现高并发的话，就要对 Django 进行二次开发，比如把整个笨重的框架给拆掉，自己写 socket 实现 http 的通信，底层用纯 c/c++写提升效率，ORM 框架给干掉，自己编写封装与数据库交互的框架，因为啥呢，ORM 虽然面向对象来操作数据库，但是它的效率很低，使用外键来联系表与表之间的查询
Flask
轻量级，主要是用来写接口的一个框架，实现前后端分离，提升开发效率，Flask 本身相当于一个内核，其他几乎所有的功能都要用到扩展（邮件扩展 Flask-Mail，用户认证 Flask-Login），都需要用第三方的扩展来实现。比如可以用 Flask-extension 加入 ORM、窗体验证工具，文件上传、身份验证等。Flask 没有默认使用的数据库，你可以选择 MySQL，也可以用 NoSQL。
其 WSGI 工具箱采用 Werkzeug（路由模块），模板引擎则使用 Jinja2。这两个也是 Flask 框架的核心。Python 最出名的框架要数 Django，此外还有 Flask、Tornado 等框架。虽然 Flask 不是最出名的框架，但是 Flask 应该算是最灵活的框架之一，这也是 Flask 受到广大开发者喜爱的原因。
Tornado
Tornado 是一种 Web 服务器软件的开源版本。
Tornado 和现在的主流 Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其非阻塞的方式和对 epoll 的运用，Tornado 每秒可以处理数以千计的连接，因此 Tornado 是实时 Web 服务的一个 理想框架。
Python后台开发

ㅤ普通",
django 如何提升性能？,"对一个后端开发程序员来说，提升性能指标主要有两个一个是并发数，另一个是响应时间网站性能的优化一般包括 web 前端性能优化，应用服务器性能优化，存储服务器优化。
对前端的优化主要有：
(1) 减少 http 请求，减少数据库的访问量，比如使用雪碧图。
(2)使用浏览器缓存，将一些常用的 css，js，logo 图标，这些静态资源缓存到本地浏览器，通过设置 http 头中的 cache-control 和 expires 的属性，可设定浏览器缓存，缓存时间可以自定义。
(3) 对 html，css，javascript 文件进行压缩，减少网络的通信量。
对我个人而言，我做的优化主要是以下三个方面：
(1)合理的使用缓存技术，对一些常用到的动态数据，比如首页做一个缓存，或者某些常用的数据做个缓存，设置一定得过期时间，这样减少了对数据库的压力，提升网站性能。
(2) 使用 celery 消息队列，将耗时的操作扔到队列里，让 worker 去监听队列里的任务，实现异步操 作，比如发邮件，发短信。
(3) 就是代码上的一些优化，补充：nginx 部署项目也是项目优化，可以配置合适的配置参数，提升效率，增加并发量。
(4) 如果太多考虑安全因素，服务器磁盘用固态硬盘读写，远远大于机械硬盘，这个技术现在没有普及，主要是固态硬盘技术上还不是完全成熟， 相信以后会大量普及。
(5) 另外还可以搭建服务器集群，将并发访问请求，分散到多台服务器上处理。
(6) 最后就是运维工作人员的一些性能优化技术了。
Python后台开发

ㅤ普通",
什么是 restful api，谈谈你的理解?,"REST:Representational State Transfer 的缩写，翻译：“具象状态传输”。一般解释为“表现层状态转换”。
REST 是设计风格而不是标准。是指客户端和服务器的交互形式。我们需要关注的重点是如何设计 REST 风格的网络接口。
REST 的特点：
(1) 具象的。一般指表现层，要表现的对象就是资源。比如，客户端访问服务器，获取的数据就是资源。比如文字、图片、音视频等。
(2) 表现：资源的表现形式。txt 格式、html 格式、json 格式、jpg 格式等。浏览器通过 URL 确定资源的位置，但是需要在 HTTP 请求头中，用 Accept 和 Content-Type 字段指定，这两个字段是对资源表现的描述。
(3) 状态转换：客户端和服务器交互的过程。在这个过程中，一定会有数据和状态的转化，这种转化叫做状态转换。其中，GET 表示获取资源，POST 表示新建资源，PUT 表示更新资源，DELETE 表示删除资源。HTTP 协议中最常用的就是这四种操作方式。
RESTful 架构：
(1) 每个 URL 代表一种资源
(2) 客户端和服务器之间，传递这种资源的某种表现层
(3) 客户端通过四个 http 动词，对服务器资源进行操作，实现表现层状态转换
Python后台开发

ㅤ普通",
启动 Django 服务的方法？,"runserver 方法是调试 Django 时经常用到的运行方式，它使用 Django 自带的 WSGI Server 运 行，主要在测试和开发中使用，并且 runserver 开启的方式也是单进程 。
Python后台开发

ㅤ普通",
怎样测试 django 框架中的代码？,"在单元测试方面，Django 继承 python 的 unittest.TestCase 实现了自己的　django.test.TestCase，编写测试用例通常从这里开始。测试代码通常位于 app 的 tests.py 文件中(也可以在 models.py 中编写，一般不建议）。在 Django 生成的 depotapp 中，已经包含了这个文件，并且其中包含了一个测试
用例的样例：
一些测试工具：unittest 或者 pytest
Python后台开发

ㅤ普通",
有过部署经验？用的什么技术？可以满足多少压力？,"(1) 有部署经验，在阿里云服务器上部署的
(2) 技术有：nginx + uwsgi 的方式来部署 Django 项目
(3) 无标准答案（例：压力测试一两千）
Python后台开发

ㅤ普通",
Django 中哪里用到了线程?哪里用到了协程?哪里用到了进程？,"(1) Django 中耗时的任务用一个进程或者线程来执行，比如发邮件，使用 celery。
(2) 部署 django 项目的时候，配置文件中设置了进程和协程的相关配置。
Python后台开发

ㅤ普通",
django 关闭浏览器，怎样清除 cookies 和 session？,"设置 Cookie
读取 Cookie
以键值对的格式写会话。
根据键读取值。
清除所有会话，在存储中删除值部分。
清除会话数据，在存储中删除会话的整条数据。
删除会话中的指定键及值，在存储中只删除某个键及对应的值。
设置会话的超时时间，如果没有指定过期时间则两个星期后过期。 如果 value 是一个整数，会话将在 value 秒没有活动后过期。 如果 value 为 0，那么用户会话的 Cookie 将在用户的浏览器关闭时过期。 如果 value 为 None，那么会话永不过期。
Session 依赖于 Cookie，如果浏览器不能保存 cookie 那么 session 就失效了。因为它需要浏览器的 cookie 值去 session 里做对比。session 就是用来在服务器端保存用户的会话状态。
cookie 可以有过期时间，这样浏览器就知道什么时候可以删除 cookie 了。 如果 cookie 没有设置过期时间，当用户关闭浏览器的时候，cookie 就自动过期了。你可以改变 SESSION_EXPIRE_AT_BROWSER_CLOSE 的设置来控制 session 框架的这一行为。缺省情况下，SESSION_EXPIRE_AT_BROWSER_CLOSE 设置为 False ，这样，会话 cookie 可以在用户浏览器中保持有效达 SESSION_COOKIE_AGE 秒（缺省设置是两周，即 1，209，600 秒）如果你不想用户每次打开浏览器都必须重新登陆的话，用这个参数来帮你。如果 SESSION_EXPIRE_AT_BROWSER_CLOSE 设置为 True，当浏览器关闭时，Django 会使 cookie 失效。
SESSION_COOKIE_AGE：设置 cookie 在浏览器中存活的时间。
Python后台开发

ㅤ普通",
代码优化从哪些方面考虑？有什么想法？,"1、优化算法时间
算法的时间复杂度对程序的执行效率影响最大，在 Python 中可以通过选择合适的数据结构来优化时间复杂度，如 list 和 set 查找某一个元素的时间复杂度分别是 O(n)和 O(1)。不同的场景有不同的 优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。
2、循环优化
每种编程语言都会强调需要优化循环。当使用 Python 的时候，你可以依靠大量的技巧使得循环运行得更快。然而，开发者经常漏掉的一个方法是：
避免在一个循环中使用点操作。每一次你调用方法 str.upper，Python 都会求该方法的值。然而，如果你用一个变量代替求得的值，值就变成了已知的，Python 就可以更快地执行任务。优化循环的关键，是要减少 Python 在循环内部执行的工作量，因为 Python 原生的解释器在那种情况下，真的会减缓执行的速度。（注意：优化循环的方法有很多，这只是其中的一个。例如，许多程序员都会说，列表推导是在循环中提高执行速度的最好方式。这里的关键是，优化循环是程序取得更高的执行速度的更好方式之一。）
3、函数选择
在循环的时候使用 xrange 而不是 range；使用 xrange 可以节省大量的系统内存，因为 xrange() 在序列中每次调用只产生一个整数元素。而 range()將直接返回完整的元素列表，用于循环时会有不必要的开销。在 python3 中 xrange 不再存在，里面 range 提供一个可以遍历任意长度的范围的 iterator。
4、并行编程
因为 GIL 的存在，Python 很难充分利用多核 CPU 的优势。但是，可以通过内置的模 multiprocessing 实现下面几种并行模式：
多进程：对于 CPU 密集型的程序，可以使用 multiprocessing 的 Process，Pool 等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。
多线程：对于 IO 密集型的程序，multiprocessing.dummy 模块使用 multiprocessing 的接口封装 threading，使得多线程编程也变得非常轻松(比如可以使用 Pool 的 map 接口，简洁高效)。
布式：multiprocessing 中的 Managers 类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。
不同的业务场景可以选择其中的一种或几种的组合实现程序性能的优化。
5、使用性能分析工具
除了上面在 ipython 使用到的 timeit 模块，还有 cProfile。cProfile 的使用方式也非常简单：python-mcProfilefilename.py，filename.py 是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间，从而找到程序的性能瓶颈，然后可以有针对性地优化。
6、set 的用法
set 的 union，intersection，difference 操作要比 list 的迭代要快。因此如果涉及到求 list 交集，并集或者差的问题可以转换为 set 来操作。
7、PyPy
PyPy 是用 RPython(CPython 的子集)实现的 Python，根据官网的基准测试数据，它比 CPython 实现的 Python 要快 6 倍以上。快的原因是使用了 Just-in-Time(JIT)编译器，即动态编译器，与静态编译器(如 gcc，javac 等)不同，它是利用程序运行的过程的数据进行优化。由于历史原因，目前 pypy 中还保留着 GIL，不过正在进行的 STM 项目试图将 PyPy 变成没有 GIL 的 Python。如果 python 程序中含有 C 扩展(非 cffi 的方式)，JIT 的优化效果会大打折扣，甚至比 CPython 慢（比 Numpy）。
所以在 PyPy 中最好用纯 Python 或使用 cffi 扩展。
Python后台开发

ㅤ普通",
Django 中间件是如何使用的？,"中间件不用继承自任何类（可以继承 object），下面一个中间件大概的样子：
还有 process_view， process_exception 和 process_template_response 函数。
(1) 初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件。
(2) 处理请求前：在每个请求上，request 对象产生之后，url 匹配之前调用，返回 None 或HttpResponse 对象。
(3) 处理视图前：在每个请求上，url 匹配之后，视图函数调用之前调用，返回 None 或HttpResponse 对象。
(4) 处理响应后：视图函数调用之后，所有响应返回浏览器之前被调用，在每个请求上调用，返回HttpResponse 对象。
(5) 异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个 HttpResponse 对象。
Python后台开发

ㅤ普通",
ngnix 的正向代理与反向代理?,"web 开发中，部署方式大致类似。简单来说，使用 Nginx 主要是为了实现分流、转发、负载均衡，以及分担服务器的压力。Nginx 部署简单，内存消耗少，成本低。Nginx 既可以做正向代理，也可以做反向代理。
正向代理：请求经过代理服务器从局域网发出，然后到达互联网上的服务器。
特点：服务端并不知道真正的客户端是谁。
反向代理：请求从互联网发出，先进入代理服务器，再转发给局域网内的服务器。
特点：客户端并不知道真正的服务端是谁。
区别：正向代理的对象是客户端。反向代理的对象是服务端。
Python后台开发

ㅤ普通",
简述 Django 下的（内建的）缓存机制?,"一个动态网站的基本权衡点就是，它是动态的。每次用户请求页面，服务器会重新计算。从开销处理的角度来看，这比你读取一个现成的标准文件的代价要昂贵的多。
这就是需要缓存的地方。
Django 自带了一个健壮的缓存系统来保存动态页面这样避免对于每次请求都重新计算。方便起见，Django 提供了不同级别的缓存粒度：可以缓存特定视图的输出、可以仅仅缓存那些很难生产出来的部分、或者可以缓存整个网站 Django 也能很好的配合那些“下游”缓存， 比如 Squid 和基于浏览器的缓存。这里有一些缓存不必要直接去控制但是可以提供线索， (via HTTPheaders)关于网站哪些部分需要缓存和如何缓存。
设置缓存：
缓存系统需要一些设置才能使用。 也就是说，你必须告诉他你要把数据缓存在哪里- 是数据库中，文件系统或者直接在内存中。这个决定很重要，因为它会影响你的缓存性能，是的，一些缓存类型要比其他的缓存类型更快速。
你的缓存配置是通过 setting 文件的 CACHES 配置来实现的。这里有 CACHES 所有可配置的变量值。
Python后台开发

ㅤ普通",
Django HTTP 请求的处理流程？,"Django 和其他 Web 框架的 HTTP 处理的流程大致相同，Django 处理一个 Request 的过程是首先通过中间件，然后再通过默认的 URL 方式进行的。我们可以在 Middleware 这个地方把所有 Request 拦截住，用我们自己的方式完成处理以后直接返回 Response。
(1) 加载配置
Django 的配置都在 “Project/settings.py” 中定义，可以是 Django 的配置，也可以是自定义的配置，并且都通过 django.conf.settings 访问，非常方便。
(2) 启动
最核心动作的是通过 django.core.management.commands.runfcgi 的 Command 来启动，它运行 django.core.servers.fastcgi 中的 runfastcgi，runfastcgi 使用了 flup 的 WSGIServer 来启动 fastcgi 。而 WSGIServer 中携带了 django.core.handlers.wsgi 的 WSGIHandler 类的一个实例，通过 WSGIHandler 来处理由 Web 服务器（比如 Apache，Lighttpd 等）传过来的请求，此时才是真正进入 Django 的世界。
(3) 处理 Request
当有 HTTP 请求来时，WSGIHandler 就开始工作了，它从 BaseHandler 继承而来。WSGIHandler 为每个请求创建一个 WSGIRequest 实例，而 WSGIRequest 是从 http.HttpRequest 继承而来。接下来就开始创建 Response 了。
(4) 创建 Response
BaseHandler 的 get_response 方法就是根据 request 创建 response，而具体生成 response 的动作就是执行 urls.py 中对应的 view 函数了，这也是 Django 可以处理“友好 URL ”的关键步骤，每个这样的函数都要返回一个 Response 实例。此时一般的做法是通过 loader 加载 template 并生成页面内容，其中重要的就是通过 ORM 技术从数据库中取出数据，并渲染到 Template 中，从而生成具体的页面了。
(5) 处理 Response
Django 返回 Response 给 flup，flup 就取出 Response 的内容返回给 Web 服务器，由后者返回给浏览器。
总之，Django 在 fastcgi 中主要做了两件事：处理 Request 和创建 Response，而它们对应的核心就是“ urls 分析”、“模板技术”和“ ORM 技术”。
Python后台开发

ㅤ普通",
Django 里 QuerySet 的 get 和 filter 方法的区别？,"(1) 输入参数
get 的参数只能是 model 中定义的那些字段，只支持严格匹配。filter 的参数可以是字段，也可以是扩展的 where 查询关键字，如 in，like 等。
(2) 返回值
get 返回值是一个定义的 model 对象。filter 返回值是一个新的 QuerySet 对象，然后可以对 QuerySet 在进行查询返回新的 QuerySet 对象，支持链式操作，QuerySet 一个集合对象，可使用迭代或者遍历，切片等，但是不等于 list 类型(使用一定要注意)。
(3) 异常
get 只有一条记录返回的时候才正常，也就说明 get 的查询字段必须是主键或者唯一约束的字段。当返回多条记录或者是没有找到记录的时候都会抛出异常 filter 有没有匹配的记录都可以
Python后台开发

ㅤ普通",
跨域请求问题 django 怎么解决的？,"Python后台开发

ㅤ普通",
Django 对数据查询结果排序怎么做，降序怎么做，查询大于某个字段怎么做？,"Python后台开发

ㅤ普通",
Django 重定向你是如何实现的？用的什么状态码？,"Python后台开发

ㅤ普通",
生成迁移文件和执行迁移文件的命令是什么？,"python manage.py makemigrations
python manage.py migrate
Python后台开发

ㅤ普通",
关系型数据库的关系包括哪些类型？,"Python后台开发

ㅤ普通",
查询集返回列表的过滤器有哪些？,"Python后台开发

ㅤ普通",
Django 本身提供了 runserver，为什么不能用来部署？,"runserver 方法是调试 Django 时经常用到的运行方式，它使用 Django 自带的 WSGI Server 运行，主要在测试和开发中使用，并且 runserver 开启的方式也是单进程 。
uWSGI 是一个 Web 服务器，它实现了 WSGI 协议、uwsgi、http 等协议。注意 uwsgi 是一种通信协议，而 uWSGI 是实现 uwsgi 协议和 WSGI 协议的 Web 服务器。uWSGI 具有超快的性能、低内存占用和多 app 管理等优点，并且搭配着 Nginx 就是一个生产环境了，能够将用户访问请求与应用 app 隔离开，实现真正的部署。相比来讲，支持的并发量更高，方便管理多进程，发挥多核的优势，提升性能。
Python后台开发

ㅤ普通",
HttpRequest 和 HttpResponse 是什么？干嘛用的？,"HttpRequest 是 django 接受用户发送多来的请求报文后，将报文封装到 HttpRequest 对象中去。
HttpResponse 返回的是一个应答的数据报文。render 内部已经封装好了 HttpResponse 类。
视图的第一个参数必须是 HttpRequest 对象，两点原因：表面上说，他是处理 web 请求的，所以必须是请求对象，根本上说，他是基于请求的一种 web 框架，所以，必须是请求对象。
因为 view 处理的是一个 request 对象，请求的所有属性我们都可以根据对象属性的查看方法来获取具体的信息：格式：request.属性
403 错误：表示资源不可用，服务器理解客户的请求，但是拒绝处理它，通常由于服务器上文件和目录的权限设置导致的 web 访问错误。如何解决：
(1) 把中间件注释。
(2) 在表单内部添加{% scrf_token %}
request.GET.get()取值时如果一键多值情况，get 是覆盖的方式获取的。getlist（）可以获取多值。
在一个有键无值的情况下，该键名 c 的值返回空。有键无值：c: getlist 返回的是列表，空列表在无键无值也没有默认值的情况下，返回的是 None 无键无值：e:None
常见方法：
应答对象：
方式一：render(request,”index.html”) 返回一个模板
render(request,”index.html”, context) 返回一个携带动态数据的页面
方式二：render_to_response(“index.html”) 返回一个模板页面
方式三：redirect(“/”) 重定向
方式四：HttpResponseRdeirect(“/”) 实现页面跳转功能
方式五：HttpResponse（”itcast1.0″)在返回到额页面中添加字符串内容
方式六：HttpResponseJson() 返回的页面中添加字符串内容。
JsonResponse 创建对象时候接收字典作为参数，返回的对象是一个 json 对象。
能接收 Json 格式数据的场景，都需要使用 view 的 JsonResponse 对象返回一个 json 格式数据
ajax 的使用场景，页面局部刷新功能。ajax 接收 Json 格式的数据。
在返回的应答报文中，可以看到 JsonResponse 应答的 content-Type 内容是 application/json
ajax 实现网页局部刷新功能：ajax 的 get()方法获取请求数据 ajax 的 each()方法遍历输出这些数据
Python后台开发

ㅤ普通",
Django 日志管理,"配置好之后：
可用函数有：logger.debug() logger.info() logger.warning() logger.error()
Django 文件管理：对于 jdango 老说，项目中的 css，js,图片都属于静态文件，我们一般会将静态文件放到一个单独的目录中，以方便管理，在 html 页面调用时，也需要指定静态文件的路径。静态文件可以放在项目根目录下，也可以放在应用的目录下，由于这些静态文件在项目中是通用的，所以推荐放在项目的根目录下。
在生产中，只要和静态文件相关的，所有访问，基本上没有 django 什么事，一般都是由 nignx 软件代劳了，为什么？因为 nginx 就是干这个的。
Python后台开发

ㅤ普通",
Python 基础面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 什么是 Python？
1. 什么是 Python？
2. 赋值、浅拷贝和深拷贝的区别？
2. 赋值、浅拷贝和深拷贝的区别？
3. init 和new的区别？
3. init 和new的区别？
4. Python 的变量、对象以及引用？
4. Python 的变量、对象以及引用？
5. 创建百万级实例如何节省内存？
5. 创建百万级实例如何节省内存？
6. Python 里面如何生成随机数？
6. Python 里面如何生成随机数？
7. Python 是强语言类型还是弱语言类型？
7. Python 是强语言类型还是弱语言类型？
8. 谈一下什么是解释性语言，什么是编译性语言？
8. 谈一下什么是解释性语言，什么是编译性语言？
9. Python 中有日志吗?怎么使用？
9. Python 中有日志吗?怎么使用？
10. Python 是如何进行类型转换的？
10. Python 是如何进行类型转换的？
11. Python 中的作用域？
11. Python 中的作用域？
12. 什么是 Python 自省？
12. 什么是 Python 自省？
13. 什么是 Python 的命名空间？
13. 什么是 Python 的命名空间？
14. 你所遵循的代码规范是什么？
14. 你所遵循的代码规范是什么？
15. 关于 Python 程序的运行方面，有什么手段能提升性能？
15. 关于 Python 程序的运行方面，有什么手段能提升性能？
16. dict 的 items() 方法与 iteritems() 方法的不同？
16. dict 的 items() 方法与 iteritems() 方法的不同？
17. os.path和sys.path的区别？
17. os.path和sys.path的区别？
18. 4G 内存怎么读取一个 5G 的数据？
18. 4G 内存怎么读取一个 5G 的数据？
19. 输入某年某月某日，判断这一天是这一年的第几天？
19. 输入某年某月某日，判断这一天是这一年的第几天？
20. 说明一下 os.path 和 sys.path 分别代表什么？
20. 说明一下 os.path 和 sys.path 分别代表什么？
21. Python 中的 os 模块常见方法？
21. Python 中的 os 模块常见方法？
22. 说一下字典和 json 的区别？
22. 说一下字典和 json 的区别？
23. 什么是可变、不可变类型？
23. 什么是可变、不可变类型？
24. 存入字典里的数据有没有先后排序？
24. 存入字典里的数据有没有先后排序？
25. lambda 表达式格式以及应用场景？
25. lambda 表达式格式以及应用场景？
26. 如何理解 Python 中字符串中的\字符？
26. 如何理解 Python 中字符串中的\字符？
27. 常用的 Python 标准库都有哪些？
27. 常用的 Python 标准库都有哪些？
28. 如何在Python中管理内存？
28. 如何在Python中管理内存？
29. 介绍一下 except 的作用和用法？
29. 介绍一下 except 的作用和用法？
30. 在 except 中 return 后还会不会执行 finally 中的代码？怎么抛出自定义异常？
30. 在 except 中 return 后还会不会执行 finally 中的代码？怎么抛出自定义异常？
31. read、readline 和 readlines 的区别？
31. read、readline 和 readlines 的区别？
32. range 和 xrange 的区别？
32. range 和 xrange 的区别？
33. 请简述你对 input()函数的理解？
33. 请简述你对 input()函数的理解？
34. 代码中要修改不可变数据会出现什么问题？抛出什么异常？
34. 代码中要修改不可变数据会出现什么问题？抛出什么异常？
35. print 调用 Python 中底层的什么方法？
35. print 调用 Python 中底层的什么方法？
36. Python 的 sys 模块常用方法
36. Python 的 sys 模块常用方法
37. unittest 是什么？
37. unittest 是什么？
38. 模块和包是什么？
38. 模块和包是什么？
39. 什么是正则的贪婪匹配？
39. 什么是正则的贪婪匹配？
40. 常用字符串格式化哪几种？
40. 常用字符串格式化哪几种？
41. 面向对象深度优先和广度优先是什么？
41. 面向对象深度优先和广度优先是什么？
42. “一行代码实现 xx”类题目
==
42. “一行代码实现 xx”类题目
Python基础

ㅤ普通",
什么是 Python？,"Python 是一种编程语言，它有对象、模块、线程、异常处理和自动内存管理，可以加入其他语言的对比。
Python 是一种解释型语言，Python 在代码运行之前不需要解释。
Python 是动态类型语言，在声明变量时，不需要说明变量的类型。
Python 适合面向对象的编程，因为它支持通过组合与继承的方式定义类。
在 Python 语言中，函数是第一类对象。
Python 代码编写快，但是运行速度比编译型语言通常要慢。
Python 用途广泛，常被用走”胶水语言”，可帮助其他语言和组件改善运行状况。
使用 Python，程序员可以专注于算法和数据结构的设计，而不用处理底层的细节。
Python基础

ㅤ普通",
赋值、浅拷贝和深拷贝的区别？,"(1) 赋值
在 Python 中，对象的赋值就是简单的对象引用，这点和 C++不同，如下所示：
在上述情况下，a 和 b 是一样的，他们指向同一片内存，b 不过是 a 的别名，是引用。
我们可以使用 b is a 去判断，返回 True，表明他们地址相同，内容相同，也可以使用 id() 函数来查 看两个列表的地址是否相同。
赋值操作(包括对象作为参数、返回值)不会开辟新的内存空间，它只是复制了对象的引用。也就是说除了 b 这个名字之外，没有其他的内存开销。修改了 a，也就影响了 b，同理，修改了 b，也就影响了 a。
(2) 浅拷贝
浅拷贝会创建新对象，其内容非原对象本身的引用，而是原对象内第一层对象的引用。
浅拷贝有三种形式:切片操作、工厂函数、copy 模块中的 copy 函数。
比如上述的列表 a，切片操作：b = a[:] 或者 b = [x for x in a]；
工厂函数：b = list(a)；
copy 函数：b = copy.copy(a)；
浅拷贝产生的列表 b 不再是列表 a 了，使用 is 判断可以发现他们不是同一个对象，使用 id 查看，他们也不指向同一片内存空间。但是当我们使用 id(x) for x in a 和 id(x) for x in b 来查看 a 和 b 中元素的地址时，可以看到二者包含的元素的地址是相同的。
在这种情况下，列表 a 和 b 是不同的对象，修改列表 b 理论上不会影响到列表 a。
但是要注意的是，浅拷贝之所以称之为浅拷贝，是它仅仅只拷贝了一层，在列表 a 中有一个嵌套的 list，如果我们修改了它，情况就不一样了。
比如：a[3].append(‘java’)，查看列表 b，会发现列表 b 也发生了变化，这是因为，我们修改了嵌套的 list，修改外层元素，会修改它的引用，让它们指向别的位置，修改嵌套列表中的元素，列表的地址并未发生变化，指向的都是用一个位置。
(3) 深拷贝
深拷贝只有一种形式，copy 模块中的 deepcopy() 函数。
深拷贝和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因此，它的时间和空间开销要高。
同样的对列表 a，如果使用 b = copy.deepcopy(a)，再修改列表 b 将不会影响到列表 a，即使嵌套的列表具有更深的层次，也不会产生任何影响，因为深拷贝拷贝出来的对象根本就是一个全新的对象，不再与原来的对象有任何的关联。
(4) 注意点
对于非容器类型，如数字、字符，以及其他的“原子”类型，没有拷贝一说，产生的都是原对象的引用。
如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。
Python基础

ㅤ普通",
init 和new的区别？,"当我们使用「类名()」创建对象的时候，Python 解释器会帮我们做两件事情：第一件是为对象在内存分配空间，第二件是为对象进行初始化。「分配空间」是new 方法，初始化是init方法。
new 方法在内部其实做了两件事情：第一件事是为「对象分配空间」，第二件事是「把对象的引用返回给 Python 解释器」。当 Python 的解释器拿到了对象的引用之后，就会把对象的引用传递给 init 的第一个参数 self，init 拿到对象的引用之后，就可以在方法的内部，针对对象来定义实例属性。
之所以要学习 new 方法，就是因为需要对分配空间的方法进行改造，改造的目的就是为了当使用「类名()」创建对象的时候，无论执行多少次，在内存中永远只会创造出一个对象的实例，这样就可以达到单例设计模式的目的。
Python基础

ㅤ普通",
Python 的变量、对象以及引用？,"首先把结论抛出来：
以下是具体解释：
在 Python 中使用变量的时候不需要提前声明变量及其类型，变量还是会正常工作。在 Python 中，这个是以一种非常流畅的方式完成，下面以 a = 1 为例我们来看一下它到底是个什么情况。
首先是怎么知道创建了变量：对于变量 a，或者说是变量名 a，当程序第一次给它赋值的时候就创建了它，其实真实情况是 Python 在代码运行之前就先去检测变量名，我们不去具体深究这些，你只需要当作是「最开始的赋值创建了变量」。
再者是怎么知道变量是什么类型：其实这个很多人都没有搞清楚，「类型」这个概念不是存在于变量中，而是存在于对象中。变量本身就是通用的，它只是恰巧在某个时间点上引用了当时的特定对象而已。就比如说在表达式中，我们用的那个变量会立马被它当时所引用的特定对象所替代。
上面这个是动态语言明显区别于静态语言的地方，其实对于刚开始来说，如果你适应将「变量」和「对象」分开，动态类型你也就可以很容易理解了。
我们还是以 a = 1 为例，其实从上面的讲述中，我们很容易的可以发现对于 a = 1 这个赋值语句 Python 是如何去执行它的：创建一个代表值 1 的对象 –> 创建一个变量 a –> 将变量 a 和对象 1 连接。 下面我用一个图来更清晰的表示一下：
由上图我们可以看出，变量 a 其实变成了对象 1 的一个引用。如果你学过指针的话，你就会发现在内部「变量其实就是到对象内存空间的一个指针」。
同样还是上图，我们还可以看出在 Python 中「引用」是从变量到对象的连接，它就是一种关系，在内存中以指针的形式实现。
Python基础

ㅤ普通",
Python 里面如何生成随机数？,"在 Python 中用于生成随机数的模块是 random，在使用前需要 import. 如下例子可以酌情列举：
random.random()：生成一个 0-1 之间的随机浮点数
random.uniform(a, b)：生成[a,b]之间的浮点数
random.randint(a, b)：生成[a,b]之间的整数
random.randrange(a, b, step)：在指定的集合[a,b)中，以 step 为基数随机取一个数
random.choice(sequence)：从特定序列中随机取一个元素，这里的序列可以是字符串，列表，元组等。
Python基础

ㅤ普通",
Python 是强语言类型还是弱语言类型？,"Python 是强类型的动态脚本语言。

  强类型：不允许不同类型相加。 动态：不使用显示数据类型声明，且确定一个变量的类型是在第一次给它赋值的时候。 脚本语言：一般也是解释型语言，运行代码只需要一个解释器，不需要编译。

Python基础

ㅤ普通",
谈一下什么是解释性语言，什么是编译性语言？,"计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。
解释性语言在运行程序的时候才会进行翻译。
编译型语言写的程序在执行之前，需要一个专门的编译过程，把程序编译成机器语言（可执行文件）。
Python基础

ㅤ普通",
Python 中有日志吗?怎么使用？,"Python 中有日志，Python 自带 logging 模块，调用 logging.basicConfig()方法，配置需要的日志等级和相应的参数，Python 解释器会按照配置的参数生成相应的日志。
补充知识：
Python 的标准日志模块
Python 标准库中提供了 logging 模块供我们使用。在最简单的使用中，默认情况下 logging 将日志打印到屏幕终端，我们可以直接导入 logging 模块，然后调用 debug，info，warn，error 和 critical 等函数来记录日志，默认日志的级别为 warning，级别比 warning 高的日志才会被显示（critical > error > warning > info > debug），「级别」是一个逻辑上的概念，用来区分日志的重要程度。
上述代码的执行结果如下所示：
我在上面说过，用 print 的话会产生大量的信息，从而很难从中找到真正有用的信息。而 logging 中将日志分成不同的级别以后，我们在大多数时间只保存级别比较高的日志信息，从而提高了日志的性能和分析速度，这样我们就可以很快速的从一个很大的日志文件里找到错误的信息。
配置日志格式
我们在用 logging 来记录日志之前，先来进行一些简单的配置：
运行上面的代码以后，会在当前的目录下新建一个 test.log 的文件，这个文件中存储 info 以及 info 以上级别的日志记录。运行一次的结果如下所示：
上面的例子中，我是用 basicConfig 对日志进行了简单的配置，其实我们还可以进行更为复杂些的配置，在此之前，我们先来了解一下 logging 中的几个概念：
上述三者的关系是：一个 Logger 使用一个 Handler，一个 Handler 使用一个 Formatter。那么概念我们知道了，该如何去使用它们呢？我们的 logging 中有很多种方式来配置文件，简单的就用上面所说的 basicConfig，对于比较复杂的我们可以将日志的配置保存在一个配置文件中，然后在主程序中使用 fileConfig 读取配置文件。
基本的知识我们知道了，下面我们来做一个小的题目：日志文件保存所有 debug 及其以上级别的日志，每条日志中要有打印日志的时间，日志的级别和日志的内容。请先自己尝试着思考一下，如果你已经思考完毕请继续向下看：
上述代码的一次运行结果如下：
我刚刚在上面说过，对于比较复杂的我们可以将日志的配置保存在一个配置文件中，然后在主程序中使用 fileConfig 读取配置文件。下面我们就来看一个典型的日志配置文件（配置文件名为 logging.conf）：
在上述的日志配置文件中，首先我们在 [loggers] 中声明了一个叫做 root 的日志记录器（logger），在 [handlers] 中声明了一个叫 logfile 的日志处理器（handler），在 [formatters] 中声明了一个名为 generic 的格式化（formatter）。之后在 [logger_root] 中定义 root 这个日志处理器（logger） 所使用的日志处理器（handler） 是哪个，在 [handler_logfile] 中定义了日志处理器（handler） 输出日志的方式、日志文件的切换时间等。最后在 [formatter_generic] 中定义了日志的格式，包括日志的产生时间，级别、文件名以及行号等信息。
有了上述的配置文件以后，我们就可以在主代码中使用 logging.conf 模块的 fileConfig 函数加载日志配置：
上述代码的运行一次的结果如下所示：
Python基础

ㅤ普通",
Python 是如何进行类型转换的？,"内建函数封装了各种转换函数，可以使用目标类型关键字强制类型转换，进制之间的转换可以用 int(‘str’，base=’n’)将特定进制的字符串转换为十进制，再用相应的进制转换函数将十进制转换为目标进制。
可以使用内置函数直接转换的有：
Python基础

ㅤ普通",
Python 中的作用域？,"Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定。当 Python 遇到一个变量的话它会按照这的顺序进行搜索：
本地作用域(Local)—>当前作用域被嵌入的本地作用域(Enclosing locals)—>全局/模块作用域 (Global)—>内置作用域(Built-in)。
Python基础

ㅤ普通",
什么是 Python 自省？,"Python 自省是 Python 具有的一种能力，使程序员面向对象的语言所写的程序在运行时,能够获得对象的类 Python 型。
Python 是一种解释型语言，为程序员提供了极大的灵活性和控制力。
Python基础

ㅤ普通",
什么是 Python 的命名空间？,"命名空间，又名 namesapce，是在很多的编程语言中都会出现的术语，趁着这个题顺便给大家仔细介绍一下。
全局变量 & 局部变量
全局变量和局部变量是我们理解命名空间的开始，我们先来看一段代码：
这段代码输出的结果如下：
从上述的结果中可以看出，运行 func()，输出的是 func() 里面的变量 x 所引用的对象 3，之后执行的是代码中的最后一行。这里要区分清楚，前一个 x 输出的是函数内部的变量 x，后一个 x 输出的是函数外的变量 x，两个变量互相不影响，在各自的作用域中起作用。
那个只在函数内起作用的变量就叫 “局部变量”，有了 “局部” 就有相应的 “全部”，但是后者听起来有歧义，所以就叫了 “全局”。
这段代码中比上段代码多加了一个 global x，这句话的意思是在声明 x 是全局变量，通俗点说就是这个 x 和 函数外的 x 是同一个了，所以结果就成了下面这样：
这样乍一看好像全局变量好强，可以管着函数内外，但是我们还是要注意，全局变量还是谨慎使用的好，因为毕竟内外有别，不要带来混乱。
作用域
作用域，用比较直白的方式来说，就是程序中变量与对象存在关联的那段程序，比如我在上面说的， x = 2 和 x = 3 是在两个不同的作用域中。
通常的，作用域是被分为静态作用域和动态作用域，虽然我们说 Python 是动态语言，但是它的作用域属于静态作用域，即 Python 中的变量的作用域是由该变量所在程序中的位置所决定的。
在 Python 中作用域被划分成四个层级，分别是：local（局部作用域），enclosing（嵌套作用域），global（全局作用域）和 built – in（内建作用域）。对于一个变量，Python 也是按照之前四个层级依次在不用的作用域中查找，我们在上一段代码中，对于变量 x，首先搜索的是函数体内的局部作用域，然后是函数体外的全局作用域，至于这段话具体怎么来理解，请看下面的例子：
上述代码运行的结果是：
仔细观察一下上面的代码和运行的结果，你就会发现变量在不同的范围内进行搜索的规律，是不是感觉这些都是以前被你忽略的呢？
命名空间
《维基百科》中说 “命名空间是对作用域的一种特殊的抽象”，在这里我用一个比方来具体说明一下：
比如张三在公司 A，他的工号是 111，李四在公司 B，他的工号也是 111，因为两个人在不同的公司，他们俩的工号可以相同但是不会引起混乱，这里的公司就表示一个独立的命名空间，如果两个人在一个公司的话，他们的工号就不能相同，否则光看工号也不知道到底是谁。
其实上面举的这个例子的特点就是我们使用命名空间的理由，在大型的计算机程序中，往往会出现成百上千的标识符，命名空间提供隐藏区域标识符的机制。通过将逻辑上相关的标识符构成响应的命名空间，可以使整个系统更加的模块化。
我在开头引用的《维基百科》的那句话说 “命名空间是对作用域的一种特殊的抽象”，它其实包含了处于该作用域内的标识符，且它本身也用一个标识符来表示。在 Python 中，命名空间本身的标识符也属于更外层的一个命名空间，所以命名空间也是可以嵌套的，它们共同生活在 “全局命名空间” 下。
简言之，不同的命名空间可以同时存在，但是彼此独立，互不干扰。当然了，命名空间因为其对象的不同也有所区别，可以分为以下几种：
程序查询命名空间的时候也有一套顺序，依次按照本地命名空间 ，全局命名空间，内置命名空间。
访问本地命名空间使用 locals 完成，我们来看一下结果：
从上面的结果中可以看出，命名空间中的数据存储的结构和字典是一样的。可能你已经猜到了，当我们要访问全局命名空间的时候，可以使用 globals。
关于命名空间还有一个生命周期的问题，就是一个命名空间什么时候出现，什么时候消失，这个很好理解，就是哪部分被读入内存，哪部分的命名空间就存在了，比如我们在上面说的，Python 启动，内置命名空间就建立。
Python基础

ㅤ普通",
你所遵循的代码规范是什么？,"PEP 8 编码风格
Python 代码从第一眼看上去，给人的感觉就是简洁优美，可读性强，也就是我们日常所说的「高颜值」。一方面是因为 Python 自身的优秀设计，比如统一的锁进，没有多余的符号从而让代码变的更加简洁；另一方面就是因为它有着一套较为统一的编码风格，当然它本身只是编码风格方面的建议而不是强制，相应的在编写 Python 代码的编辑器自动提供 PFP 8 检查，当你编写的代码违反了 PEP 8 规范的时候，会给出警告信息和修正的建议。与此同时，还有专门的检查工具对 Python 的代码风格进行检查。
由上，还是建议在编写 Python 代码的时候都遵循 PEP 8 编码规范，毕竟你以后不可能是只一个人写代码，未来不论是在公司或者某些开源项目中，作为其中的一份子，肯定还是要在风格上向大众看齐的。
PEP 8 编码规范详细的给出了 Python 编码的指导，包括什么对齐啦，包的导入顺序啦，空格和注释啦还有命名习惯等方方面面，并且还有详细的事例。
下面我以「包」的导入为例，看一下 PEP 8 给出的具体编程指导。在 Python 中， import 应该一次只导入一个模块，不同的模块应该独立一行：
反面例子：
如果想要从一个模块里面导入多个，也可以像下面这样：
import 语句应该处于源码文件的顶部，位于模块注释和文档字符串之后，全局变量和常量之前。在导入不同的库的时候，应该按照以下的顺序分组，各个分组之间以空行分隔：
具体事例如下所示：
Python 中还支持相对导入和绝对导入，在这里还是强推绝对导入。因为绝对导入的可读性更好一些，也不容易出错，即使出错了也会给出更加详细的错误信息。具体如下所示：
当然除了上述以外还有更多对于包的规范的描述，PEP 8 的编码风格指导比较长，并且写的非常详细，所以我就不在这一一介绍了，详细的可以参考 Python 官网上的资料。
pycodestyle 检查代码规范
我在上面说过 PEP 8 只是官方给出的 Python 编码规范，并没有强制要求大家都遵守，但是又由于大家都在用，所以它也就变成了事实上的 Python 代码风格标准，既然都是标准了，那么就应该有工具来检查这个标准，这样可以帮助 Python 小白规范自己的代码，也可以帮助大家在开源或者工作中形成统一的代码风格。
为了达成上述的目的，官方提供了同名的命令行工具来检查 Python 代码是否违反了 PEP 8 规范，并且对违反规范的地方给出了相应的提示信息。
规范的名字是 PEP 8 ，这个检查代码风格的命令行工具叫 pep8，这个很容易引起大家的困惑，因此 Python 之父建议将 pep8 重新命名为 pycodestyle，下面我们来看一下 pycodestyle 的用法。
首先通过 pip 安装一下：
对一个或者多个文件运行 pycodestyle，打印检查报告：

通过 –show-source 显示不符合规范的源码，以便程序员进行修改，具体如下所示：

autopep8 格式化代码
autopep8 能够将 Python 代码自动格式化为 PEP 8 风格，它使用 pycodestyle 工具来决定代码中的哪部分需要被格式化，这能够修复大部分 pycodestyle 工具中报告的排版问题。autopep8 本身也是一个用 Python 写的工具，所以我们还是可以用 pip 直接安装：
它的使用方式也很简单，具体如下所示：
上述代码如果不带 –in-place 的话，会将 autopep8 格式化以后的代码直接输出到控制台。我们可以用这种方式检查 autopep8 的修改，使用 –in-place 则会直接将结果保存到源文件中。在这我继续用上面的例子中用到的 py 文件，具体如下所示：

上面的例子中，autopep8 顺利的修复了所有的问题，但是如果你这个时候查看源文件的话，你会发现源文件的内容还是和原来一样，并没有被修改。这个时候我们就要用到 –in-place，加上这个选项将不会有任何输出， autopep8 会直接修改源文件。
Python基础

ㅤ普通",
关于 Python 程序的运行方面，有什么手段能提升性能？,"1、使用多进程，充分利用机器的多核性能
2、对于性能影响较大的部分代码，可以使用 C 或 C++ 编写
3、对于 IO 阻塞造成的性能影响，可以使用 IO 多路复用来解决
4、尽量使用 Python 的内建函数
5、尽量使用局部变量
Python基础

ㅤ普通",
dict 的 items() 方法与 iteritems() 方法的不同？,"items方法将所有的字典以列表方式返回，其中项在返回时没有特殊的顺序
iteritems方法有相似的作用，但是返回一个迭代器对象
Python基础

ㅤ普通",
4G 内存怎么读取一个 5G 的数据？,"方法一：
通过生成器，分多次读取，每次读取数量相对少的数据（比如 500MB）进行处理，处理结束后 在读取后面的 500MB 的数据。
方法二：
可以通过 linux 命令 split 切割成小文件，然后再对数据进行处理，此方法效率比较高。可以按照行 数切割，可以按照文件大小切割。

  　　在Linux下用split进行文件分割： 模式一：指定分割后文件行数 对与txt文本文件，可以通过指定分割后文件的行数来进行文件分割。 命令：split -l 300 large_file.txt new_file_prefix 模式二：指定分割后文件大小 split -b 10m server.log waynelog

Python基础

ㅤ普通",
输入某年某月某日，判断这一天是这一年的第几天？,"使用 Python 标准库 datetime
“`
import datetime
def dayofyear():
    year = input(“请输入年份：”)
    month = input(“请输入月份：”)
    day = input(“请输入天：”)
    date1 = datetime.date(year=int(year)，month=int(month)，day=int(day))
    date2 = datetime.date(year=int(year)，month=1，day=1)
    return (date1-date2+1).days
Python基础

ㅤ普通",
说明一下 os.path 和 sys.path 分别代表什么？,"os.path 主要是用于对系统路径文件的操作。
sys.path 主要是对 Python 解释器的系统环境参数的操作（动态的改变 Python 解释器搜索路径）。
Python基础

ㅤ普通",
Python 中的 os 模块常见方法？,"os.remove() 删除文件
os.rename() 重命名文件
os.walk() 生成目录树下的所有文件
os.chdir() 改变目录
os.mkdir/makedirs 创建目录/多层目录
os.rmdir/removedirs 删除目录/多层目录
os.listdir() 列出指定目录的文件
os.getcwd() 取得当前工作目录
os.chmod() 改变目录权限
os.path.basename() 去掉目录路径，返回文件名
os.path.dirname() 去掉文件名，返回目录路径
os.path.join() 将分离的各部分组合成一个路径名
os.path.split() 返回（dirname(),basename())元组
os.path.splitext() 返回(filename,extension)元组
os.path.getatime\ctime\mtime 分别返回最近访问、创建、修改时间
os.path.getsize() 返回文件大小
os.path.exists() 是否存在
os.path.isabs() 是否为绝对路径
os.path.isdir() 是否为目录
os.path.isfile() 是否为文件
Python基础

ㅤ普通",
说一下字典和 json 的区别？,"字典是一种数据结构，json 是一种数据的表现形式，字典的 key 值只要是能 hash 的就行，json 的必须是字符串。
Python基础

ㅤ普通",
什么是可变、不可变类型？,"可变不可变指的是内存中的值是否可以被改变，不可变类型指的是对象所在内存块里面的值不可以改变，有数值、字符串、元组；可变类型则是可以改变，主要有列表、字典。
Python基础

ㅤ普通",
存入字典里的数据有没有先后排序？,"存入的数据不会自动排序，可以使用 sort 函数对字典进行排序。
Python基础

ㅤ普通",
lambda 表达式格式以及应用场景？,"lambda函数就是可以接受任意多个参数（包括可选参数）并且返回单个表达式值得函数。
语法：lambda [arg1 [,arg2,…..argn]]:expression
将上述一般函数改写为匿名函数：
应用
(1) lambda函数比较轻便，即用即仍，适合完成只在一处使用的简单功能。
(2) 匿名函数，一般用来给filter，map这样的函数式编程服务
(3) 作为回调函数，传递给某些应用，比如消息处理。
Python基础

ㅤ普通",
如何理解 Python 中字符串中的\字符？,"1、转义字符
2、路径名中用来连接路径名
3、编写太长代码手动软换行
Python基础

ㅤ普通",
常用的 Python 标准库都有哪些？,"os 操作系统、time 时间、random 随机、pymysql 连接数据库、threading 线程、multiprocessing 进程、queue 队列
第三方库： django、flask、requests、virtualenv、selenium、scrapy、xadmin、celery、re、hashlib、md5
常用的科学计算库：Numpy，Pandas、matplotlib
Python基础

ㅤ普通",
如何在Python中管理内存？,"python中的内存管理由Python私有堆空间管理。所有Python对象和数据结构都位于私有堆中。程序员无权访问此私有堆。python解释器负责处理这个问题。
Python对象的堆空间分配由Python的内存管理器完成。核心API提供了一些程序员编写代码的工具。
Python还有一个内置的垃圾收集器，它可以回收所有未使用的内存，并使其可用于堆空间。
Python基础

ㅤ普通",
介绍一下 except 的作用和用法？,"except: 捕获所有异常
except:: 捕获指定异常
except:: 捕获异常 1 或者异常 2
except:,: 捕获指定异常及其附加的数据
except::: 捕获异常名 1 或者异常名 2,及附加的数据
Python基础

ㅤ普通",
在 except 中 return 后还会不会执行 finally 中的代码？怎么抛出自定义异常？,"会继续处理 finally 中的代码； 用 raise 方法可以抛出自定义异常。
Python基础

ㅤ普通",
read、readline 和 readlines 的区别？,"read:读取整个文件。
readline：读取下一行，使用生成器方法。
readlines：读取整个文件到一个迭代器以供我们遍历。
Python基础

ㅤ普通",
range 和 xrange 的区别？,"两者用法相同，不同的是 range 返回的结果是一个列表，而 xrange 的结果是一个生成器，前者是直接开辟一块内存空间来保存列表，后者是边循环边使用，只有使用时才会开辟内存空间，所以当列表 很长时，使用 xrange 性能要比 range 好。
Python基础

ㅤ普通",
请简述你对 input()函数的理解？,"在 Python3 中，input()获取用户输入，不论用户输入的是什么，获取到的都是字符串类型的。
在 Python2 中有 raw_input()和 input(), raw_input()和 Python3 中的 input()作用是一样的， input()输入的是什么数据类型的，获取到的就是什么数据类型的。
Python基础

ㅤ普通",
代码中要修改不可变数据会出现什么问题？抛出什么异常？,"代码不会正常运行，抛出 TypeError 异常。
Python基础

ㅤ普通",
print 调用 Python 中底层的什么方法？,"print 方法默认调用 sys.stdout.write 方法，即往控制台打印字符串。
Python基础

ㅤ普通",
Python 的 sys 模块常用方法,"sys.argv 命令行参数 List，第一个元素是程序本身路径
sys.modules.keys() 返回所有已经导入的模块列表
sys.exc_info() 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback 当前处理的 异常详细信息
sys.exit(n) 退出程序，正常退出时 exit(0)  sys.hexversion 获取 Python 解释程序的版本值，16 进制格式如：0x020403F0
sys.version 获取 Python 解释程序的版本信息
sys.maxint 最大的 Int 值
sys.maxunicode 最大的 Unicode 值
sys.modules 返回系统导入的模块字段，key 是模块名，value 是模块
sys.path 返回模块的搜索路径，初始化时使用 PYTHONPATH 环境变量的值
sys.platform 返回操作系统平台名称
sys.stdout 标准输出
sys.stdin 标准输入
sys.stderr 错误输出
sys.exc_clear() 用来清除当前线程所出现的当前的或最近的错误信息
sys.exec_prefix 返回平台独立的 python 文件安装的位置
sys.byteorder 本地字节规则的指示器，big-endian 平台的值是’big’,little-endian 平台的值是 ‘little’  sys.copyright 记录 python 版权相关的东西
sys.api_version 解释器的 C 的 API 版本
sys.version_info 元组则提供一个更简单的方法来使你的程序具备 Python 版本要求功能
Python基础

ㅤ普通",
unittest 是什么？,"在 Python 中，unittest 是 Python 中的单元测试框架。它拥有支持共享搭建、自动测试、在测试 中暂停代码、将不同测试迭代成一组等的功能。
Python基础

ㅤ普通",
模块和包是什么？,"在 Python 中，模块是搭建程序的一种方式。每一个 Python 代码文件都是一个模块，并可以引用 其他的模块，比如对象和属性。
一个包含许多 Python 代码的文件夹是一个包。一个包可以包含模块和子文件夹。
Python基础

ㅤ普通",
什么是正则的贪婪匹配？,"贪婪匹配：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。
非贪婪匹配：就是匹配到结果就好，就少的匹配字符。
Python基础

ㅤ普通",
常用字符串格式化哪几种？,"% 格式化字符串操作符
字典形式的字符串格式化方法
字符串格式化（format）
(1) 使用位置参数
位置参数不受顺序约束，且可以为{}，参数索引从0开始，format里填写{}对应的参数值。
(2) 使用关键字参数
关键字参数值要对得上，可用字典当关键字参数传入值，字典前加**即可
(3) 填充与格式化     :填充字符[宽度]
填充字符
Python基础

ㅤ普通",
面向对象深度优先和广度优先是什么？,"在子类继承多个父类时，属性查找方式分深度优先和广度优先两种。
当类是经典类时，多继承情况下，在要查找属性不存在时，会按照深度优先方式查找下去。
当类是新式类时，多继承情况下，在要查找属性不存在时，会按照广度优先方式查找下去。
Python基础

ㅤ普通",
“一行代码实现 xx”类题目,"(1) 一行代码实现 1 – 100 的和
可以利用 sum() 函数。

(2) 一行代码实现数值交换
不用二话，直接换。

(3) 一行代码求奇偶数
使用列表推导式。

(4) 一行代码展开列表
使用列表推导式，稍微复杂一点，注意顺序。

(5) 一行代码打乱列表
用到 random 的 shuffle。

(6) 一行代码反转字符串
使用切片。

(7) 一行代码查看目录下所有文件
使用 os 的 listdir。

(8) 一行代码去除字符串间的空格
法 1 replace 函数。

法 2  join & split 函数。

(9) 一行代码实现字符串整数列表变成整数列表
使用 list & map & lambda。

(10) 一行代码删除列表中重复的值
使用 list & set。

(11) 一行代码实现 9 * 9 乘法表
稍稍复杂的列表推导式，耐心点就行，一点点的搞…

(12) 一行代码找出两个列表中相同的元素
使用 set 和 &。

(13) 一行代码找出两个列表中不同的元素
使用 set 和 ^。

(14)一行代码合并两个字典
使用 Update 函数。

(15) 一行代码实现字典键从小到大排序
使用 sort 函数。

Python基础

ㅤ普通",
Python 机器学习面试题阅读指南（必看）,"大家好，我是帅地。 为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。 由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 什么是机器学习
1. 什么是机器学习
2. 机器学习与数据挖掘的区别？
2. 机器学习与数据挖掘的区别？
3. 什么是机器学习的过度拟合现象？过度拟合产生的原因？如何避免过拟合问题？
3. 什么是机器学习的过度拟合现象？过度拟合产生的原因？如何避免过拟合问题？
4. 什么是机器学习的欠拟合？如何避免欠拟合问题？
4. 什么是机器学习的欠拟合？如何避免欠拟合问题？
5. 解释有监督和无监督机器学习之间的区别？
5. 解释有监督和无监督机器学习之间的区别？
6. 偏差和方差之间的权衡是什么？
6. 偏差和方差之间的权衡是什么？
7. 解释 KNN 和 k-means 聚类之间的区别？
7. 解释 KNN 和 k-means 聚类之间的区别？
8. 什么是贝叶斯定理？我们为什么用它？
8. 什么是贝叶斯定理？我们为什么用它？
9. 什么是朴素贝叶斯分类器？我们为什么要使用它们？
9. 什么是朴素贝叶斯分类器？我们为什么要使用它们？
10. 判别模型和生成模型之间有什么区别？
10. 判别模型和生成模型之间有什么区别？
11. 什么是参数模型？提供一个例子
11. 什么是参数模型？提供一个例子
12. 如何根据训练集大小选择分类器？
12. 如何根据训练集大小选择分类器？
13. 解释ROC曲线和AUC？
13. 解释ROC曲线和AUC？
14. 如何确保您不会过度拟合模型？
14. 如何确保您不会过度拟合模型？
15. 说明如何处理数据集中的丢失或损坏的数据？
15. 说明如何处理数据集中的丢失或损坏的数据？
16. 解释如何开发数据管道？
16. 解释如何开发数据管道？
17. 如何解决模型中的高方差？
17. 如何解决模型中的高方差？
18. 什么是超参数？它们与模型参数有何不同？
18. 什么是超参数？它们与模型参数有何不同？
19. 你正在处理数据集。如何选择重要变量？
19. 你正在处理数据集。如何选择重要变量？
20. 为什么 XGBoost 的性能优于 SVM？
20. 为什么 XGBoost 的性能优于 SVM？
21. 以下混淆矩阵的召回率，特异性和精确度是多少？
21. 以下混淆矩阵的召回率，特异性和精确度是多少？
22. 使用 scikit-learn 时，是否确实需要在特征值变化很大时调整特征值？
22. 使用 scikit-learn 时，是否确实需要在特征值变化很大时调整特征值？
23. 你的数据集有 50 个变量，但是8个变量的缺失值高于 30％。如何解决这个问题？
23. 你的数据集有 50 个变量，但是8个变量的缺失值高于 30％。如何解决这个问题？
24. 协方差和相关性有什么区别？
24. 协方差和相关性有什么区别？
25. 你认为把分类变量当成连续型变量会得到一个更好的预测模型吗？
25. 你认为把分类变量当成连续型变量会得到一个更好的预测模型吗？
26. 在 K-means 或者 KNN，我们是用欧氏距离来计算最近的邻居之间的距离，为什么不用曼哈顿距离？
26. 在 K-means 或者 KNN，我们是用欧氏距离来计算最近的邻居之间的距离，为什么不用曼哈顿距离？
27. 给你一个数据集，这个数据集有缺失值，且这些缺失值分布在高中值有1一个标准偏差的的范围内，百分之多少的数据不会受到影响？为什么？
27. 给你一个数据集，这个数据集有缺失值，且这些缺失值分布在高中值有1一个标准偏差的的范围内，百分之多少的数据不会受到影响？为什么？
28. 线程分类器与非线性分类器的区别以及优劣？
28. 线程分类器与非线性分类器的区别以及优劣？
29. 文本中的余弦距离是什么，有哪些作用？
29. 文本中的余弦距离是什么，有哪些作用？
30. 什么是数据埋点？
30. 什么是数据埋点？
31. 请简要说说一个完整的机器学习项目流程
31. 请简要说说一个完整的机器学习项目流程
32. 我们知道，独热编码（OneHotEncoder）会增加数据集的维度。但是标签编码（LabelEncoder）不会。为什么？
32. 我们知道，独热编码（OneHotEncoder）会增加数据集的维度。但是标签编码（LabelEncoder）不会。为什么？
Python机器学习

ㅤ普通",
什么是机器学习,"简单的说，机器学习就是让机器从数据中学习，进而得到一个更加符合现实规律的模型，通过对模型的使用使得机器比以往表现的更好，这就是机器学习。
对上面这句话的理解：
数据：从现实生活抽象出来的一些事物或者规律的特征进行数字化得到。
学习：在数据的基础上让机器重复执行一套特定的步骤（学习算法）进行事物特征的萃取，得到一个更加逼近于现实的描述（这个描述是一个模型它的本身可能就是一个函数）。我们把大概能够描述现实的这个函数称作我们学到的模型。
更好：我们通过对模型的使用就能更好的解释世界，解决与模型相关的问题。
Python机器学习

ㅤ普通",
机器学习与数据挖掘的区别？,"数据挖掘和机器学习的区别和联系，周志华有一篇很好的论述《机器学习和数据挖掘》可以帮助大家理解。
数据挖掘受到很多学科领域的影响，其中数据库、机器学习、统计学无疑影响最大。简言之，对数据挖掘而言，数据库提供数据管理技术，机器学习和统计学提供数据分析技术。
由于统计学往往醉心于理论的优美而忽视实际的效用，因此，统计学界提供的很多技术通常都要在机器学习界进一步研究，变成有效的机器学习算法之后才能再进入数据挖掘领域。从这个意义上说，统计学主要是通过机器学习来对数据挖掘发挥影响，而机器学习和数据库则是数据挖掘的两大支撑技术。
从数据分析的角度来看，绝大多数数据挖掘技术都来自机器学习领域，但机器学习研究往往并不把海量数据作为处理对象，因此，数据挖掘要对算法进行改造，使得算法性能和空间占用达到实用的地步。同时，数据挖掘还有自身独特的内容，即关联分析。
而模式识别和机器学习的关系是什么呢，传统的模式识别的方法一般分为两种：统计方法和句法方法。句法分析一般是不可学习的，而统计分析则是发展了不少机器学习的方法。也就是说，机器学习同样是给模式识别提供了数据分析技术。
至于，数据挖掘和模式识别，那么从其概念上来区分吧，数据挖掘重在发现知识，模式识别重在认识事物。
机器学习的目的是建模隐藏的数据结构，然后做识别、预测、分类等。因此，机器学习是方法，模式识别是目的。
总结一下吧。只要跟决策有关系的都能叫 AI(人工智能)，所以说 PR（模式识别）、DM（数据挖掘）、IR（信息检索） 属于 AI 的具 体应用应该没有问题。 研究的东西则不太一样， ML(机器学习) 强调自我完善的过程。 Anyway，这些学科都是相通的。
Python机器学习

ㅤ普通",
什么是机器学习的过度拟合现象？过度拟合产生的原因？如何避免过拟合问题？,"如果一味的去提高训练数据的预测能力，所选模型的复杂度往往会很高，这种现象称为过拟合，所表现的就是模型训练时候的误差很小，但在测试的时候误差很大。
过拟合的产生总结一下大概有以下五种原因可能产生:
(1) 建模样本抽取错误，包括（但不限于）样本数量太少，抽样方法错误，抽样时没有足够正确考虑业务场景或业务特点，等等导致抽出的样本数据不能有效足够代表业务逻辑或业务场景
(2) 样本里的噪音数据干扰过大，大到模型过分记住了噪音特征，反而忽略了真实的输入输出间的关系
(3) 在决策树模型搭建中，如果我们对于决策树的生长没有合理的限制和修剪的话，决策树的自由生长有可能每片叶子里只包含单纯的事件数据(event)或非事件数据（no event），可以想象，这种决策树当然可以完美匹配（拟合）训练数据，但是一旦应用到新的业务真实数据时，效果是一塌糊涂。
(4) 建模时的“逻辑假设”到了模型应用时已经不能成立了。任何预测模型都是在假设的基础上才可以搭建和应用的，常用的假设包括：假设历史数据可以推测未来，假设业务环节没有发生显著变化，假设建模数据与后来的应用数据是相似的，等等。如果上述假设违反了业务场景的话，根据这些假设搭建的模型当然是无法有效应用的。
(5) 建模时使用了太多的输入变量，这跟上面第二点（噪音数据）有些类似，数据挖掘新人常常犯这个错误，自己不做分析判断，把所有的变量交给软件或者机器去“撞大运”。须知，一个稳定优良的模型一定要遵循建模输入变量“少而精”的原则的。
上面的原因都是现象，但是其本质只有一个，那就是“业务理解错误造成的”，无论是抽样，还是噪音，还是决策树，神经网络等等，如果我们对于业务背景和业务知识非常了解，非常透彻的话，一定是可以避免绝大多数过拟合现象产生的。因为在模型从确定需求，到思路讨论，到搭建，到业务应用验证，各个环节都是可以用业务敏感来防止过拟合于未然的。
避免过拟合问题：
(1) 重采样Bootstrap
(2) L1，L2 正则化
(3) 决策树的剪枝操作
(4) 交叉验证
Python机器学习

ㅤ普通",
什么是机器学习的欠拟合？如何避免欠拟合问题？,"所谓欠拟合就是模型复杂度低或者数据集太小，对模型数据的拟合程度不高，因此模型在训练集上的效果就不好。
避免欠拟合问题：
(1) 增加样本数量
(2) 增加样本特征的数量
(3) 可以进行特征维度扩展
Python机器学习

ㅤ普通",
解释有监督和无监督机器学习之间的区别？,"监督学习需要训练标记的数据。换句话说，监督学习使用了基本事实，这意味着我们对输出和样本已有知识。这里的目标是学习一个近似输入和输出之间关系的函数。
另一方面，无监督学习不使用标记的输出。此处的目标是推断数据集中的自然结构。
Python机器学习

ㅤ普通",
偏差和方差之间的权衡是什么？,"偏差（模型拟合数据的程度）是指由于ML算法中的假设不正确或过于简单而导致的误差，这会导致过度拟合。
方差（模型基于输入的变化量）指的是由于ML算法的复杂性而导致的错误，从而对训练数据的高水平变化和过度拟合产生了敏感性。
换句话说，简单的模型是稳定的（低方差）但有很大的偏差。复杂的模型容易过拟合，但表达了模型的真实性（低偏差）。误差的最佳减少需要权衡偏差和方差，以避免高方差和高偏差。
Python机器学习

ㅤ普通",
解释 KNN 和 k-means 聚类之间的区别？,"主要区别在于，KNN 需要标记点（分类算法，监督学习），而 k-means 则不需要（聚类算法，无监督学习）。
若要使用 K 最近邻，请使用要分类为未标记点的标记数据。K 均值聚类采用未标记的点，并学习如何使用点之间距离的平均值对它们进行分组。
Python机器学习

ㅤ普通",
什么是贝叶斯定理？我们为什么用它？,"贝叶斯定理是我们在知道其他概率时如何找到概率的方法。换句话说，它提供了先验知识事件的后验概率。该定理是计算条件概率的原则方法。
在 ML 中，贝叶斯定理用于将模型拟合到训练数据集的概率框架中，并用于建立分类预测建模问题（即，朴素贝叶斯，贝叶斯最优分类器）。
Python机器学习

ㅤ普通",
什么是朴素贝叶斯分类器？我们为什么要使用它们？,"朴素贝叶斯分类器是分类算法的集合。这些分类器是具有共同原理的一系列算法。朴素贝叶斯分类器假设某个功能的存在或不影响其他功能的存在或不存在。
换句话说，我们称其为“天真”，因为它假定所有数据集特征都同等重要且独立。
朴素贝叶斯分类器用于分类。当独立性的假设成立时，与其他复杂的预测变量相比，它们更易于实现并产生更好的结果。它们用于垃圾邮件过滤，文本分析和推荐系统。
Python机器学习

ㅤ普通",
判别模型和生成模型之间有什么区别？,"判别模型学习不同类别的数据之间的区别。生成模型学习数据类别。 区分模型通常在分类任务上表现更好。
Python机器学习

ㅤ普通",
什么是参数模型？提供一个例子,"参数模型具有有限数量的参数。您只需要知道模型的参数即可进行数据预测。常见示例如下：线性 SVM，线性回归和逻辑回归。
非参数模型具有无限数量的参数以提供灵活性。对于数据预测，您需要模型的参数和观测数据的状态。常见示例如下：k最近邻，决策树和主题模型。
Python机器学习

ㅤ普通",
如何根据训练集大小选择分类器？,"对于小的训练集，具有高偏差和低方差模型的模型更好，因为它不太可能过拟合。一个例子是朴素贝叶斯。
对于大型训练集，具有低偏差和高方差模型的模型更好，因为它表示更复杂的关系。一个例子是逻辑回归。
Python机器学习

ㅤ普通",
解释ROC曲线和AUC？,"ROC曲线是在所有阈值下分类模型的性能的图形表示。它有两个阈值：真阳性率和假阳性率。
简单来说，AUC（ ROC 曲线下方的面积）就是 ROC 曲线下方的面积。AUC 测量 ROC 曲线下从（0,0）到（1,1）的二维区域。它用作评估二进制分类模型的性能指标。
[]
Python机器学习

ㅤ普通",
如何确保您不会过度拟合模型？,"我们可以使用三种方法来防止过度拟合：
(1) 使用交叉验证技术（例如k折交叉验证）
(2) 保持模型简单（即减少变量）以减少方差
(3) 使用正则化技术（例如 LASSO）来惩罚可能导致过度拟合的模型参数
Python机器学习

ㅤ普通",
说明如何处理数据集中的丢失或损坏的数据？,"您需要标识查找数据并删除行/列，或将其替换为其他值。
pandas 提供了执行此操作的有用方法：isnull() 和 dropna()。这些使您可以识别并删除损坏的数据。该 fillna() 方法可用于使用占位符填充无效值。
Python机器学习

ㅤ普通",
解释如何开发数据管道？,"数据管道使我们能够采用数据科学模型并对其进行自动化或扩展。常见的数据管道工具是 Apache Airflow，并且使用 Google Cloud，Azure 和 AWS 托管它们。
对于这样的问题，您想解释所需的步骤并讨论您在构建数据管道方面的实际经验。
对于 Google Cloud 主机，基本步骤如下：
(1) 登录到 Google Cloud Platform
(2) 创建一个计算实例
(3) 从 GitHub 中提取教程内容
(4) 使用 AirFlow 概述管道
(5) 使用 Docker 设置虚拟主机
(6) 开发一个 Docker 容器
(7) 打开 Airflow UI 并运行数据管道
(8) 运行已部署的 Web 应用
Python机器学习

ㅤ普通",
如何解决模型中的高方差？,"如果模型具有低方差和高偏差，我们使用装袋算法，该算法使用随机抽样将数据集划分为子集。我们使用这些样本通过单个学习算法生成一组模型。
此外，我们可以使用正则化技术，其中较高的模型系数会受到惩罚，以降低总体复杂度。
Python机器学习

ㅤ普通",
什么是超参数？它们与模型参数有何不同？,"模型参数是模型内部的变量。参数值是根据训练数据估算的。
超参数是模型外部的变量。该值无法从数据中估算出来，通常用于估算模型参数。
Python机器学习

ㅤ普通",
你正在处理数据集。如何选择重要变量？,"(1) 在选择重要变量之前，请先删除相关变量
(2) 使用随机森林和绘图变量重要性图表
(3) 使用套索回归
(4) 使用线性回归以基于p值选择变量
(5) 使用前向选择，逐步选择和向后选择
Python机器学习

ㅤ普通",
为什么 XGBoost 的性能优于 SVM？,"XGBoos 是使用许多树的集成方法。这意味着它会随着自身的重复而提高。
SVM 是线性分隔符。因此，如果我们的数据不是线性可分离的，那么 SVM 需要一个内核来使数据达到可以分离的状态。这可能会限制我们，因为每个给定的数据集都没有完美的内核。
Python机器学习

ㅤ普通",
以下混淆矩阵的召回率，特异性和精确度是多少？,"TN /真阴性：案件为阴性，预计为阴性
FN /假阴性：案件为阳性，但预计为阴性
FP /误报：案例为否定，但预计为肯定


召回率= 20％
特异性= 30％
精度= 22％
补充

  说明：
召回率= TP /（TP + FN）= 10/50 = 0.2 = 20％
特异性= TN /（TN + FP）= 15/50 = 0.3 = 30％
精度= TP /（TP + FP）= 10/45 = 0.2 = 22％

Python机器学习

ㅤ普通",
使用 scikit-learn 时，是否确实需要在特征值变化很大时调整特征值？,"是。大多数机器学习算法都使用欧几里得距离作为度量标准来测量两个数据点之间的距离。如果值的范围相差很大，则不同功能部件中相同更改的结果将非常不同。
Python机器学习

ㅤ普通",
你的数据集有 50 个变量，但是8个变量的缺失值高于 30％。如何解决这个问题？,"您可以采用 3 种一般方法：
只是删除它们（不理想）
为缺失值分配唯一的类别，以查看是否有趋势生成此问题
检查目标变量的分布。如果找到了模式，请保留缺少的值，将其分配给新类别，然后删除其他类别
Python机器学习

ㅤ普通",
协方差和相关性有什么区别？,"相关性是协方差的标准化格式。协方差本身很难做比较。例如：如果我们计算工资（￥）和年龄（岁）的协方差，因为这两个变量有不同的度量，所以我们会得到不能做比较的不同的协方差。为了解决这个问题，我们计算相关性来得到一个介于-1和1之间的值，就可以忽略它们各自不同的度量。
Python机器学习

ㅤ普通",
你认为把分类变量当成连续型变量会得到一个更好的预测模型吗？,"为了得到更好的预测，只有在分类变量在本质上是有序的情况下才可以被当做连续型变量来处理。
Python机器学习

ㅤ普通",
在 K-means 或者 KNN，我们是用欧氏距离来计算最近的邻居之间的距离，为什么不用曼哈顿距离？,"我们不用曼哈顿距离，因为它只计算水平或者垂直距离，有维度的限制。另一方面，欧氏距离可以用于任何空间的距离计算问题。因为，数据点可以存在于任何空间，欧式距离是更可行的选择。例如：想象一下国际象棋棋盘，象或者车所有的移动的由曼哈顿距离计算的，因为他们是在各自的水平和垂直方向做的运动。
Python机器学习

ㅤ普通",
给你一个数据集，这个数据集有缺失值，且这些缺失值分布在高中值有1一个标准偏差的的范围内，百分之多少的数据不会受到影响？为什么？,"大约有32%的数据将不会受到缺失值的影响。因为，由于数据分布在中位数附近，让我们先假设这是一个正态分布。我们知道，在一个正态分布中，约有68%的数据位于跟平均值（或者众数，中位数）1个标准差范围内，那么剩下的约32%的数据是不受影响的。因此，约有32%的数据将不受缺失值的影响。
Python机器学习

ㅤ普通",
线程分类器与非线性分类器的区别以及优劣？,"如果模型是参数的线性函数，并且存在线性分类面，那么就是线性分类器，否则不是。　　
常用的线性分类器有:LR ,贝叶斯分类，单层感知器，线性回归
常见的非线性分类器：决策树，RF，GBDT，多层感知机
SVM两种都有（看线性核还是高斯核）
线性分类器速度快，编程方便，但是可能拟合效果不会很好
非线性分类器编程复杂，但是效果拟合能力强
Python机器学习

ㅤ普通",
文本中的余弦距离是什么，有哪些作用？,"余弦距离是两个向量的距离的一种度量方式，其值在-1~1之间，如果为1表示两个向量同相，0表示两个向量正交，-1表示两个向量反向。使用TF-IDF和余弦距离可以寻找内容相似的文章，例如首先用TF-IDF找出两篇文章的关键词，然后每个文章分别取出k个关键词(10-20个)，统计这些关键词的词频，生成两篇文章的词频向量，然后用余弦距离计算其相似度。
Python机器学习

ㅤ普通",
什么是数据埋点？,"数据埋点我们可以分为两类，其一是页面统计，其二是行为统计
页面统计可以帮我们知晓某个页面被多少人访问了多少次
行为统计是指用户在界面上的操作行为，应用最多的是按钮的点击次数
Python机器学习

ㅤ普通",
请简要说说一个完整的机器学习项目流程,"(1) 抽象成数学问题
明确问题是进行机器学习的第一步。机器学习的训练过程通常都是一件非常耗时的事情，胡乱尝试时间成本是非常高的。
这里的抽象成数学问题，指的我们明确我们可以获得什么样的数据，目标是一个分类还是回归或者是聚类的问题，如果都不是的话，如果划归为其中的某类问题。
(2) 获取数据
数据决定了机器学习结果的上限，而算法只是尽可能逼近这个上限。数据要有代表性，否则必然会过拟合。而且对于分类问题，数据偏斜不能过于严重，不同类别的数据数量不要有数个数量级的差距。
而且还要对数据的量级有一个评估，多少个样本，多少个特征，可以估算出其对内存的消耗程度，判断训练过程中内存是否能够放得下。如果放不下就得考虑改进算法或者使用一些降维的技巧了。如果数据量实在太大，那就要考虑分布式了。
(3) 特征预处理与特征选择
　　
良好的数据要能够提取出良好的特征才能真正发挥效力。
特征预处理、数据清洗是很关键的步骤，往往能够使得算法的效果和性能得到显著提高。归一化、离散化、因子化、缺失值处理、去除共线性等，数据挖掘过程中很多时间就花在它们上面。这些工作简单可复制，收益稳定可预期，是机器学习的基础必备步骤。
筛选出显著特征、摒弃非显著特征，需要机器学习工程师反复理解业务。这对很多结果有决定性的影响。特征选择好了，非常简单的算法也能得出良好、稳定的结果。这需要运用特征有效性分析的相关技术，如相关系数、卡方检验、平均互信息、条件熵、后验概率、逻辑回归权重等方法。
(4) 训练模型与调优
直到这一步才用到我们上面说的算法进行训练。现在很多算法都能够封装成黑盒供人使用。但是真正考验水平的是调整这些算法的（超）参数，使得结果变得更加优良。这需要我们对算法的原理有深入的理解。理解越深入，就越能发现问题的症结，提出良好的调优方案。
(5) 模型诊断
如何确定模型调优的方向与思路呢？这就需要对模型进行诊断的技术。
过拟合、欠拟合判断是模型诊断中至关重要的一步。常见的方法如交叉验证，绘制学习曲线等。过拟合的基本调优思路是增加数据量，降低模型复杂度。欠拟合的基本调优思路是提高特征数量和质量，增加模型复杂度。
误差分析 也是机器学习至关重要的步骤。通过观察误差样本，全面分析误差产生误差的原因：是参数的问题还是算法选择的问题，是特征的问题还是数据本身的问题……
诊断后的模型需要进行调优，调优后的新模型需要重新进行诊断，这是一个反复迭代不断逼近的过程，需要不断地尝试， 进而达到最优状态。
(6)模型融合
一般来说，模型融合后都能使得效果有一定提升。而且效果很好。
　　
工程上，主要提升算法准确度的方法是分别在模型的前端（特征清洗和预处理，不同的采样模式）与后端（模型融合）上下功夫。因为他们比较标准可复制，效果比较稳定。而直接调参的工作不会很多，毕竟大量数据训练起来太慢了，而且效果难以保证。
(7) 上线运行
这一部分内容主要跟工程实现的相关性比较大。工程上是结果导向，模型在线上运行的效果直接决定模型的成败。 不单纯包括其准确程度、误差等情况，还包括其运行的速度(时间复杂度)、资源消耗程度（空间复杂度）、稳定性是否可接受。
这些工作流程主要是工程实践上总结出的一些经验。并不是每个项目都包含完整的一个流程。这里的部分只是一个指导性的说明，只有大家自己多实践，多积累项目经验，才会有自己更深刻的认识。
Python机器学习

ㅤ普通",
我们知道，独热编码（OneHotEncoder）会增加数据集的维度。但是标签编码（LabelEncoder）不会。为什么？,"用独热编码(OneHotEncoder)，数据集的维度（也即特征）增加是因为它为分类变量中存在的的每一级都创建了一个变量。例如：假设我们有一个变量“颜色”。这变量有 3 个层级，即红色、蓝色和绿色。
对“颜色”变量进行一位有效编码会生成含0和1值的 Color.Red，Color.Blue 和 Color.Green 三个新变量。在标签编码中，分类变量的层级编码为0，1和2，因此不生成新变量。标签编码主要是用于二进制变量。
Python机器学习

ㅤ普通",
Python 爬虫面试题阅读指南（必看）,"大家好，我是帅地。 为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。 由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 爬取数据后使用哪个数据库存储数据的，为什么？
1. 爬取数据后使用哪个数据库存储数据的，为什么？
2. 你用过的爬虫框架或者模块有哪些？谈谈他们的区别或者优缺点？
2. 你用过的爬虫框架或者模块有哪些？谈谈他们的区别或者优缺点？
3. 写爬虫是用多进程好？还是多线程好？ 为什么？
3. 写爬虫是用多进程好？还是多线程好？ 为什么？
4. 常见的反爬虫和应对方法？
4. 常见的反爬虫和应对方法？
5. 需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？
5. 需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？
6. 验证码的解决？
6. 验证码的解决？
7. 使用最多的数据库（Mysql，Mongodb，redis 等），对他们的理解？
7. 使用最多的数据库（Mysql，Mongodb，redis 等），对他们的理解？
8. 写一个邮箱地址的正则表达式？
8. 写一个邮箱地址的正则表达式？
9. 如何定时启动你的爬虫项目？
9. 如何定时启动你的爬虫项目？
10. 爬的那些内容数据量有多大，多久爬一次，爬下来的数据是怎么存储？
10. 爬的那些内容数据量有多大，多久爬一次，爬下来的数据是怎么存储？
11. cookie 过期的处理问题？
11. cookie 过期的处理问题？
12. 动态加载又对及时性要求很高怎么处理？
12. 动态加载又对及时性要求很高怎么处理？
13. 谈一谈你对 Selenium 和 PhantomJS 了解？
13. 谈一谈你对 Selenium 和 PhantomJS 了解？
14. 代理 IP 里的“透明”“匿名”“高匿”分别是指？
14. 代理 IP 里的“透明”“匿名”“高匿”分别是指？
15. robots 协议有什么用处？
15. robots 协议有什么用处？
16. 为什么 requests 请求需要带上 header？
16. 为什么 requests 请求需要带上 header？
17. dumps,loads 与 dump,load 的区别？
17. dumps,loads 与 dump,load 的区别？
18. 平常怎么使用代理的？
18. 平常怎么使用代理的？
19. IP 存放在哪里？怎么维护 IP？对于封了多个 ip 的，怎么判定 IP 没被封？
19. IP 存放在哪里？怎么维护 IP？对于封了多个 ip 的，怎么判定 IP 没被封？
20. 怎么获取加密的数据？
20. 怎么获取加密的数据？
21. 假如每天爬取量在 5、6 万条数据，一般开几个线程，每个线程 ip 需要加锁限定吗？
21. 假如每天爬取量在 5、6 万条数据，一般开几个线程，每个线程 ip 需要加锁限定吗？
22. 怎么监控爬虫的状态？
22. 怎么监控爬虫的状态？
23. 描述下 scrapy 框架运行的机制？
23. 描述下 scrapy 框架运行的机制？
24. 谈谈你对 Scrapy 的理解？
24. 谈谈你对 Scrapy 的理解？
25. 什么是增量爬取？
25. 什么是增量爬取？
26. 爬虫向数据库存数据开始和结束都会发一条消息，是 scrapy 哪个模块实现的？
26. 爬虫向数据库存数据开始和结束都会发一条消息，是 scrapy 哪个模块实现的？
27. 爬取下来的数据如何去重，说一下具体的算法依据？
27. 爬取下来的数据如何去重，说一下具体的算法依据？
28. Scrapy 的优缺点？
28. Scrapy 的优缺点？
29. 什么是 scrapy-redis 中的指纹？是如何去重的？
29. 什么是 scrapy-redis 中的指纹？是如何去重的？
30. 怎么设置深度爬取？
30. 怎么设置深度爬取？
31. scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？
31. scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？
32. 分布式爬虫主要解决什么问题？
32. 分布式爬虫主要解决什么问题？
33. 什么是反向代理？作用是什么？
33. 什么是反向代理？作用是什么？
34. 什么是分布式存储？
34. 什么是分布式存储？
35. 你所知道的分布式爬虫方案有哪些？
35. 你所知道的分布式爬虫方案有哪些？
Python爬虫

ㅤ普通",
爬取数据后使用哪个数据库存储数据的，为什么？,"MongoDB 是使用比较多的数据库，这里以 MongoDB 为例，大家需要结合自己真实开发环境回答。
原因：
1.与关系型数据库相比，MongoDB 的优点如下。
(1) 弱一致性（最终一致），更能保证用户的访问速度
举例来说，在传统的关系型数据库中，一个 COUNT 类型的操作会锁定数据集，这样可以保证得到“当前”情况下的较精确值。这在某些情况下，例 如通过 ATM 查看账户信息的时候很重要，但对于 Wordnik 来说，数据是不断更新和增长的，这种“较精确”的保证几乎没有任何意义，反而会产生很大的延 迟。他们需要的是一个“大约”的数字以及更快的处理速度。
但某些情况下 MongoDB 会锁住数据库。如果此时正有数百个请求，则它们会堆积起来，造成许多问题。我们使用了下面的优化方式来避免锁定。
每次更新前，我们会先查询记录。查询操作会将对象放入内存，于是更新则会尽可能的迅速。在主/从部署方案中，从节点可以使用“-pretouch”参数运行，这也可以得到相同的效果。
使用多个 mongod 进程。我们根据访问模式将数据库拆分成多个进程。
(2) 文档结构的存储方式，能够更便捷的获取数据。
对于一个层级式的数据结构来说，如果要将这样的数据使用扁平式的，表状的结构来保存数据，这无论是在查询还是获取数据时都十分困难。
(3) 内置 GridFS，支持大容量的存储。
GridFS 是一个出色的分布式文件系统，可以支持海量的数据存储。内置了 GridFS 了 MongoDB，能够满足对大数据集的快速范围查询。
(4) 内置 Sharding。
提供基于 Range 的 Auto Sharding 机制：一个 collection 可按照记录的范围，分成若干个段，切分到不同的Shard上。Shards可以和复制结合，配合Replica sets能够实现Sharding+fail-over，不同的 Shard 之间可以负载均衡。查询是对 客户端是透明的。客户端执行查询，统计，MapReduce 等操作，这些会被 MongoDB 自动路由到后端的数据节点。这让我们关注于自己的业务，适当的时候可以无痛的升级。MongoDB 的 Sharding 设计能力较大可支持约 20 petabytes，足以支撑一般应用。
这可以保证 MongoDB 运行在便宜的 PC 服务器集群上。PC 集群扩充起来非常方便并且成本很低，避免了“sharding”操作的复杂性和成本。
(5) 第三方支持丰富。(这是与其他的 NoSQL 相比，MongoDB 也具有的优势)
现在网络上的很多 NoSQL 开源数据库完全属于社区型的，没有官方支持，给使用者带来了很大的风险。而开源文档数据库 MongoDB 背后有商业公司 10gen 为其提供供商业培训和支持。而且 MongoDB 社区非常活跃，很多开发框架都迅速提供了对 MongDB 的支持。不少知名大公司和网站也在生产环境中使用MongoDB，越来越多的创新型企业转而使用 MongoDB 作为和 Django，RoR 来搭配的技术方案。
(6) 性能优越
在使用场合下，千万级别的文档对象，近 10G 的数据，对有索引的 ID 的查询不会比 mysql 慢，而对非索引字段的查询，则是全面胜出。 mysql 实际无法胜任大数据量下任意字段的查询，而 mongodb 的查询性能实在让我惊讶。写入性能同样很令人满意，同样写入百万级别的数据，mongodb 比我以前试用过的couchdb 要快得多，基本 10 分钟以下可以解决。补上一句，观察过程中 mongodb 都远算不上是 CPU 杀手。
2.Mongodb 与 redis 相比较
(1) mongodb 文件存储是 BSON 格式类似 JSON，或自定义的二进制格式。mongodb 与 redis 性能都很依赖内存的大小，mongodb 有丰富的数据表达、索引；最类似于关系数据库，支持丰富的查询语言，redis 数据丰富，较少的 IO ，这方面 mongodb 优势明显。
(2) mongodb 不支持事物，靠客户端自身保证，redis 支持事物，比较弱，仅能保证事物中的操作按顺序执行，这方面 redis 优于 mongodb。
(3) mongodb 对海量数据的访问效率提升，redis 较小数据量的性能及运算,这方面 mongodb 性能优于 redis.monbgodb 有mapredurce功能，提供数据分析，redis 没有，这方面 mongodb 优于 redis。
Python爬虫

ㅤ普通",
你用过的爬虫框架或者模块有哪些？谈谈他们的区别或者优缺点？,"用过的：
(1) Python 自带：urllib、urllib2
urllib 和 urllib2 模块都做与请求 URL 相关的操作，但他们提供不同的功能。
urllib2：urllib2.urlopen 可以接受一个 Request 对象或者 url，（在接受 Request 对象时候，并以此可以来设置一个 URL 的 headers），urllib.urlopen 只接收一个 url。
urllib 有 urlencode,urllib2 没有，因此总是 urllib，urllib2 常会一起使用的原因。
(2) 第三方：requests
request 是一个 HTTP 库， 它只是用来，进行请求，对于 HTTP 请求，他是一个强大的库，下载，解析全部自己处理，灵活性更高，高并发与分布式部署也非常灵活，对于功能可以更好实现
(3) 框架： Scrapy
scrapy 是封装起来的框架，它包含了下载器，解析器，日志及异常处理，基于多线程，twisted 的方式处理，对于固定单个网站的爬取开发，有优势，但是对于多网站爬取，并发及分布式处理方面，不够灵活，不便调整与括展。
Scrapy 优点
scrapy 是异步的
采取可读性更强的 xpath 代替正则
强大的统计和 log 系统
同时在不同的 url 上爬行
支持 shell 方式，方便独立调试
写 middleware,方便写一些统一的过滤器
通过管道的方式存入数据库
Scrapy 缺点
基于 python 的爬虫框架，扩展性比较差
基于 twisted 框架，运行中的 exception 是不会干掉 reactor，并且异步框架出错后是不会停掉其他任务的，数据出错后难以察觉。
Python爬虫

ㅤ普通",
写爬虫是用多进程好？还是多线程好？ 为什么？,"IO 密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有 IO 操作会进行 IO 等待，造成不必要的时间浪费，而开启多线程能在线程 A 等待时，自动切换到线程 B，可以不浪费 CPU 的资源，从而能提升程序执行效率)。在实际的数据采集过程中，既考虑网速和响应的问题，也需要考虑自身机器的硬件情况，来设置多进程或多线程。
Python爬虫

ㅤ普通",
常见的反爬虫和应对方法？,"(1) 通过 Headers 反爬虫
从用户请求的 Headers 反爬虫是最常见的反爬虫策略。很多网站都会对 Headers 的 User-Agent 进行检测，还有一部分网站会对 Referer 进行检测（一些资源网站的防盗链就是检测 Referer）。如果遇到了这类反爬虫机制，可以直接在爬虫中添加 Headers，将浏览器的 User-Agent 复制到爬虫的 Headers 中；或者将 Referer 值修改为目标网站域名。对于检测 Headers 的反爬虫，在爬虫中修改或者添加 Headers 就能很好的绕过。
(2) 基于用户行为反爬虫
还有一部分网站是通过检测用户行为，例如同一 IP 短时间内多次访问同一页面，或者同一账户短时间内多次进行相同操作。
大多数网站都是前一种情况，对于这种情况，使用 IP 代理就可以解决。可以专门写一个爬虫，爬取网上公开的代理 ip，检测后全部保存起来。这样的代理 ip 爬虫经常会用到，最好自己准备一个。有了大量代理 ip 后可以每请求几次更换一个 ip，这在 requests 或者 urllib2 中很容易做到，这样就能很容易的绕过第一种反爬虫。
对于第二种情况，可以在每次请求后随机间隔几秒再进行下一次请求。有些有逻辑漏洞的网站，可以通过请求几次，退出登录，重新登录，继续请求来绕过同一账号短时间内不能多次进行相同请求的限制。
(3) 动态页面的反爬虫
上述的几种情况大多都是出现在静态页面，还有一部分网站，我们需要爬取的数据是通过 ajax 请求得到，或者通过 JavaScript 生成的。首先用 Fiddler 对网络请求进行分析。如果能够找到 ajax 请求，也能分析出具体的参数和响应的具体含义，我们就能采用上面的方法，直接利用 requests 或者 urllib2模拟 ajax 请求，对响应的 json 进行分析得到需要的数据。
能够直接模拟 ajax 请求获取数据固然是极好的，但是有些网站把 ajax 请求的所有参数全部加密了。我们根本没办法构造自己所需要的数据的请求。这种情况下就用 selenium+phantomJS，调用浏览器内核，并利用 phantomJS 执行 js 来模拟人为操作以及触发页面中的 js 脚本。从填写表单到点击按钮再到滚动页面，全部都可以模拟，不考虑具体的请求和响应过程，只是完完整整的把人浏览页面获取数据的过程模拟一遍。
用这套框架几乎能绕过大多数的反爬虫，因为它不是在伪装成浏览器来获取数据（上述的通过添加Headers 一定程度上就是为了伪装成浏览器），它本身就是浏览器，phantomJS 就是一个没有界面的浏览器，只是操控这个浏览器的不是人。利 selenium+phantomJS 能干很多事情，例如识别点触式（12306）或者滑动式的验证码，对页面表单进行暴力破解等。
Python爬虫

ㅤ普通",
"需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？","(1) 解决限制 IP 可以使用代理 IP 地址池、服务器
(2)不适用动态爬取的情况下可以使用反编译 JS 文件获取相应的文件，或者换用其他平台（比如手机端）看看是否可以获取相应的 json 文件。
Python爬虫

ㅤ普通",
验证码的解决？,"(1) 图形验证码
干扰、杂色不是特别多的图片可以使用开源库 Tesseract 进行识别，太过复杂的需要借助第三方打码平台。
(2) 滑块验证码
点击和拖动滑块验证码可以借助 selenium、无图形界面浏览器（chromedirver 或者 phantomjs）和pillow 包来模拟人的点击和滑动操作，pillow 可以根据色差识别需要滑动的位置。
Python爬虫

ㅤ普通",
使用最多的数据库（Mysql，Mongodb，redis 等），对他们的理解？,"(1) MySQL 数据库
开源免费的关系型数据库，需要实现创建数据库、数据表和表的字段，表与表之间可以进行关联（一对多、多对多），是持久化存储。
(2) Mongodb 数据库
非关系型数据库，数据库的三元素是，数据库、集合、文档，可以进行持久化存储，也可作为内存数据库，存储数据不需要事先设定格式，数据以键值对的形式存储。
(3) redis 数据库
非关系型数据库，使用前可以不用设置格式，以键值对的方式保存，文件格式相对自由，主要用与缓存数据库，也可以进行持久化存储。
Python爬虫

ㅤ普通",
写一个邮箱地址的正则表达式？,"[A-Za-z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$
Python爬虫

ㅤ普通",
如何定时启动你的爬虫项目？,"(1) 最简单的方法：直接使用 Timer 类
(2) 使用 sched
(3) 使用 Crontab
Python爬虫

ㅤ普通",
爬的那些内容数据量有多大，多久爬一次，爬下来的数据是怎么存储？,"京东整站的数据大约在 1 亿左右，爬下来的数据存入数据库，mysql 数据库中如果有重复的 url 建议去重存入数据库，可以考虑引用外键。评分、评论如果做增量，Redis 中 url 去重，评分和评论建议建立一张新表用 id 做关联。
多久爬一次这个问题要根据公司的要求去处理，不一定是每天都爬。
Mongo 建立唯一索引键（id）可以做数据重复 前提是数据量不大， 2 台电脑几百万的情况 数据库需要做分片 （数据库要设计合理）。
例：租房的网站数据量每天大概是几十万条 ，每周固定爬取。
Python爬虫

ㅤ普通",
cookie 过期的处理问题？,"因为 cookie 存在过期的现象，一个很好的处理方法就是做一个异常类，如果有异常的话 cookie 抛出异常类在执行程序。
Python爬虫

ㅤ普通",
动态加载又对及时性要求很高怎么处理？,"Selenium + Phantomjs，尽量不使用 sleep 而使用 WebDriverWait
Python爬虫

ㅤ普通",
谈一谈你对 Selenium 和 PhantomJS 了解？,"Selenium 是一个 Web 的自动化测试工具，可以根据我们的指令，让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生。Selenium 自己不带浏览器，不支持浏览器的功能，它需要与第三方浏览器结合在一起才能使用。但是我们有时候需要让它内嵌在代码中运行，所以我们可以用一个叫 PhantomJS 的工具代替真实的浏览器。Selenium 库里有个叫 WebDriver 的 API。WebDriver 有点儿像可以加载网站的浏览器，但是它也可以像 BeautifulSoup 或者其他 Selector 对象一样用来查找页面元素，与页面上的元素进行交互 (发送文本、点击等)，以及执行其他动作来运行网络爬虫。
PhantomJS 是一个基于 Webkit 的“无界面”(headless)浏览器，它会把网站加载到内存并执行页面上的 JavaScript，因为不会展示图形界面，所以运行起来比完整的浏览器要高效。相比传统的 Chrome 或 Firefox 浏览器等，资源消耗会更少。
如果我们把 Selenium 和 PhantomJS 结合在一起，就可以运行一个非常强大的网络爬虫了，这个爬虫可以处理 JavaScript、Cookie、headers，以及任何我们真实用户需要做的事情。
主程序退出后，selenium 不保证 phantomJS 也成功退出，最好手动关闭 phantomJS 进程。（有可能会导致多个 phantomJS 进程运行，占用内存）。
WebDriverWait 虽然可能会减少延时，但是目前存在 bug（各种报错），这种情况可以采用 sleep。phantomJS 爬数据比较慢，可以选择多线程。如果运行的时候发现有的可以运行，有的不能，可以尝试将 phantomJS 改成 Chrome。
Python爬虫

ㅤ普通",
代理 IP 里的“透明”“匿名”“高匿”分别是指？,"(1) 透明代理
它的意思是客户端根本不需要知道有代理服务器的存在，但是它传送的仍然是真实的 IP。你要想隐藏的话，不要用这个。
(2) 普通匿名代理
普通匿名代理能隐藏客户机的真实 IP，但会改变我们的请求信息，服务器端有可能会认为我们使用了代理。不过使用此种代理时，虽然被访问的网站不能知道你的 ip 地址，但仍然可以知道你在使用代理，当然某些能够侦测 ip 的网页仍然可以查到你的 ip。
(3) 高匿名代理
高匿名代理不改变客户机的请求，这样在服务器看来就像有个真正的客户浏览器在访问它，这时客户的真实 IP 是隐藏的，服务器端不会认为我们使用了代理。
设置代理有以下两个好处
Python爬虫

ㅤ普通",
robots 协议有什么用处？,"Robots 协议：网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。
Python爬虫

ㅤ普通",
为什么 requests 请求需要带上 header？,"原因是：模拟浏览器，欺骗服务器，获取和浏览器一致的内容
header 的形式：字典
headers = {“User-Agent”: “Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36”}
用法： requests.get(url,headers=headers)
Python爬虫

ㅤ普通",
"dumps,loads 与 dump,load 的区别？","json.dumps() 将 pyhton 的 dict 数据类型编码为 json 字符串
json.loads() 将 json 字符串解码为 dict 的数据类型
json.dump(x,y) x 是 json 对象, y 是文件对象，最终是将 json 对象写入到文件中
json.load(y) 从文件对象 y 中读取 json 对象
Python爬虫

ㅤ普通",
平常怎么使用代理的？,"(1) 自己维护代理池
(2) 付费购买（目前市场上有很多 ip 代理商，可自行百度了解，建议看看他们的接口文档（API&SDK））
Python爬虫

ㅤ普通",
IP 存放在哪里？怎么维护 IP？对于封了多个 ip 的，怎么判定 IP 没被封？,"存放在数据库(redis、mysql 等)
维护多个代理网站
一般代理的存活时间往往在十几分钟左右，定时任务，加上代理 IP 去访问网页，验证其是否可用，如果返回状态为 200，表示这个代理是可以使用的。
Python爬虫

ㅤ普通",
怎么获取加密的数据？,"(1) Web 端加密可尝试移动端（app）
(2) 解析加密，看能否破解
(3) 反爬手段层出不穷，js 加密较多，只能具体问题具体分析
Python爬虫

ㅤ普通",
假如每天爬取量在 5、6 万条数据，一般开几个线程，每个线程 ip 需要加锁限定吗？,"(1) 5、6 万条数据相对来说数据量比较小，线程数量不做强制要求(做除法得一个合理值即可）
(2) 多线程使用代理，应保证不在同时一刻使用一个代理 IP
Python爬虫

ㅤ普通",
怎么监控爬虫的状态？,"(1) 使用 python 的 STMP 包将爬虫的状态信心发送到指定的邮箱
(2) Scrapyd、pyspider
(3) 引入日志
Python爬虫

ㅤ普通",
描述下 scrapy 框架运行的机制？,"从 start_urls 里获取第一批 url 并发送请求，请求由引擎交给调度器入请求队列，获取完毕后，调度器将请求队列里的请求交给下载器去获取请求对应的响应资源，并将响应交给自己编写的解析方法做提取处理：
(1) 如果提取出需要的数据，则交给管道文件处理；
(2) 如果提取出 url，则继续执行之前的步骤（发送 url 请求，并由引擎将请求交给调度器入队列…)，直到请求队列里没有请求，程序结束。
Python爬虫

ㅤ普通",
谈谈你对 Scrapy 的理解？,"scrapy 是一个为了爬取网站数据，提取结构性数据而编写的应用框架，我们只需要实现少量代码，就能够快速的抓取到数据内容。Scrapy 使用了 Twisted 异步网络框架来处理网络通讯，可以加快我们的下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。
scrapy 框架的工作流程：
(1) 首先 Spiders（爬虫）将需要发送请求的 url(requests)经 ScrapyEngine（引擎）交给 Scheduler（调度器）
(2) Scheduler（排序，入队）处理后，经 ScrapyEngine，DownloaderMiddlewares(可选，主要有 User_Agent， Proxy 代理)交给 Downloader
(3) Downloader 向互联网发送请求，并接收下载响应（response）。将响应（response）经ScrapyEngine，SpiderMiddlewares(可选)交给 Spiders
(4)Spiders 处理 response，提取数据并将数据经 ScrapyEngine 交给 ItemPipeline 保存（可以是本地，可以是数据库）。提取 url 重新经 ScrapyEngine 交给 Scheduler 进行下一个循环。直到无 Url 请求程序停止结束
Python爬虫

ㅤ普通",
什么是增量爬取？,"增量爬取即保存上一次状态，本次抓取时与上次比对，如果不在上次的状态中，便视为增量，保存下来。对于 scrapy 来说，上一次的状态是抓取的特征数据和上次爬取的 request 队列（url 列表），request 队列可以通过 request 队列可以通过 scrapy.core.scheduler 的 pending_requests 成员得到，在爬虫启动时导入上次爬取的特征数据，并且用上次 request 队列的数据作为 start url 进行爬取，不在上一次状态中的数据便保存。
选用 BloomFilter 原因：对爬虫爬取数据的保存有多种形式，可以是数据库，可以是磁盘文件等，不管是数据库，还是磁盘文件，进行扫描和存储都有很大的时间和空间上的开销，为了从时间和空间上提升性能，故选用 BloomFilter 作为上一次爬取数据的保存。保存的特征数据可以是数据的某几项，即监控这几项数据，一旦这几项数据有变化，便视为增量持久化下来，根据增量的规则可以对保存的状态数据进行约束。比如：可以选网页更新的时间，索引次数或是网页的实际内容，cookie 的更新等。
Python爬虫

ㅤ普通",
爬虫向数据库存数据开始和结束都会发一条消息，是 scrapy 哪个模块实现的？,"Scrapy 使用信号来通知事情发生，因此答案是 signals 模块。
Python爬虫

ㅤ普通",
爬取下来的数据如何去重，说一下具体的算法依据？,"(1)通过 MD5 生成电子指纹来判断页面是否改变
(2) nutch 去重。nutch 中 digest 是对采集的每一个网页内容的 32 位哈希值，如果两个网页内容完全一样，它们的 digest 值肯定会一样。
数据量不大时，可以直接放在内存里面进行去重，python 可以使用 set()进行去重。当去重数据需要持久化时可以使用 redis 的 set 数据结构。
当数据量再大一点时，可以用不同的加密算法先将长字符串压缩成 16/32/40 个字符，再使用上面两种方法去重。
当数据量达到亿（甚至十亿、百亿）数量级时，内存有限，必须用“位”来去重，才能够满足需求。Bloomfilter 就是将去重对象映射到几个内存“位”，通过几个位的 0/1 值来判断一个对象是否已经存在。
然而 Bloomfilter 运行在一台机器的内存上，不方便持久化（机器 down 掉就什么都没啦），也不方便分布式爬虫的统一去重。如果可以在 Redis 上申请内存进行 Bloomfilter，以上两个问题就都能解决了。
simhash 最牛逼的一点就是将一个文档，最后转换成一个 64 位的字节，暂且称之为特征字，然后判断重复只需要判断他们的特征字的距离是不是<n（根据经验这个 n 一般取值为 3），就可以判断两个文档是否相似。
可见 scrapy_redis 是利用 set 数据结构来去重的，去重的对象是 request 的 fingerprint（其实就是用 hashlib.sha1()对 request 对象的某些字段信息进行压缩）。其实 fp 就是 request 对象加密压缩后的一个字符串（40 个字符，0~f）。
Python爬虫

ㅤ普通",
Scrapy 的优缺点？,"优点
(1) scrapy 是异步的
(2) 采取可读性更强的 xpath 代替正则
(3)强大的统计和 log 系统
(4) 同时在不同的 url 上爬行
(5) 支持 shell 方式，方便独立调试
(6) 写 middleware,方便写一些统一的过滤器
(7) 通过管道的方式存入数据库
缺点
(1) 基于 python 的爬虫框架，扩展性比较差
(2) 基于 twisted 框架，运行中的 exception 是不会干掉 reactor（反应器），并且异步框架出错后是不会停掉其他任务的，数据出错后难以察觉。
Python爬虫

ㅤ普通",
什么是 scrapy-redis 中的指纹？是如何去重的？,"指纹
通过 sha1 加密，把请求体，请求方式，请求 url 放在一起。然后进行 16 进制的转义符字符串生成指纹。生成一个字符串，放到数据库中作为唯一标示。
去重
url 中按照 url 去重：
(1) 按照 url 去重，有一个列表，发送请求之前从数据表中看一下这个 url有没有请求过，请求过了就不用看了
(2) 内容判断，从数据库中查数据的表示，如果请求过了就在不在请求了。
Python爬虫

ㅤ普通",
怎么设置深度爬取？,"通过在 settings.py 中设置 depth_limit 的值可以限制爬取深度，这个深度是与 start_urls 中定义 url 的相对值。也就是相对 url 的深度。若定义 url 为 http://www.domz.com/game/,depth_limit=1 那么限制爬取的只能是此 url 下一级的网页。深度大于设置值的将被忽视。
Python爬虫

ㅤ普通",
scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？,"scrapy 是一个 Python 爬虫框架，爬取效率极高，具有高度定制性，但是不支持分布式。而scrapy-redis 一套基于 redis 数据库、运行在 scrapy 框架之上的组件，可以让 scrapy 支持分布策略，Slaver 端共享 Master 端 redis 数据库里的 item 队列、请求队列和请求指纹集合。
为什么选择 redis 数据库，因为 redis 支持主从同步，而且数据都是缓存在内存中的，所以基于 redis的分布式爬虫，对请求和数据的高频读取效率非常高。
Python爬虫

ㅤ普通",
分布式爬虫主要解决什么问题？,"主要解决一下 4 个问题：
(1) ip
(2) 带宽
(3) cpu
(4) io
Python爬虫

ㅤ普通",
什么是反向代理？作用是什么？,"代理可以假扮 Web 服务器。这些被称为替换物(surrogate)或反向代理(reverse proxy)的代理接收发送给 Web 服务器的真实请求，但与 Web 服务器不同的是，它们可以发起与其他服务器的通信，以便按需定位所请求的内容。
可以用这些反向代理来提高访问慢速 Web 服务器上公共内容的性能。在这种配置中，通常将这些反向代理称为服务器加速器(server accelerator)。还可以将替换物与内容路由功能配合使用，以创建按需复制内容的分布式网络。
Python爬虫

ㅤ普通",
什么是分布式存储？,"传统定义
分布式存储系统是大量 PC 服务器通过 Internet 互联，对外提供一个整体的服务。
分布式存储系统具有以下特性
(1) 可扩展：分布式存储系统可以扩展到几百台甚至几千台这样的一个集群规模，系统的整体性能线性增长。
(2) 低成本：分布式存储系统的自动容错、自动负载均衡的特性，允许分布式存储系统可以构建在低成本的服务器上。另外，线性的扩展能力也使得增加、减少服务器的成本低，实现分布式存储系统的自动运维。
(3) 高性能：无论是针对单台服务器，还是针对整个分布式的存储集群，都要求分布式存储系统具备高性能。
(4) 易用：分布式存储系统需要对外提供方便易用的接口，另外，也需要具备完善的监控、运维工具，并且可以方便的与其他的系统进行集成。分布式存储系统的挑战主要在于数据和状态信息的持久化，要求在自动迁移、自动容错和并发读写的过程中，保证数据的一致性。
(5) 容错：可以快速检测到服务器故障，并自动的将在故障服务器上的数据进行迁移。
(6) 负载均衡：新增的服务器在集群中保障负载均衡？数据迁移过程中保障不影响现有的服务。
(7) 事务与并发控制：实现分布式事务。
(8) 易用性：设计对外接口，使得设计的系统易于使用。
Python爬虫

ㅤ普通",
你所知道的分布式爬虫方案有哪些？,"3 种分布式爬虫策略
(1) Slaver 端从 Master 端拿任务（Request/url/ID）进行数据抓取，在抓取数据的同时也生成新任务，并将任务抛给 Master。Master 端只有一个 Redis 数据库，负责对 Slaver 提交的任务进行去重、加入待爬队列。
优点： scrapy-redis 默认使用的就是这种策略，我们实现起来很简单，因为任务调度等工作 scrapy-redis 都已经帮我们做好了，我们只需要继承 RedisSpider、指定 redis_key 就行了。
缺点： scrapy-redis 调度的任务是 Request 对象，里面信息量比较大（不仅包含 url，还有 callback 函数、headers 等信息），导致的结果就是会降低爬虫速度、而且会占用 Redis 大量的存储空间。当然我们可以重写方法实现调度 url 或者用户 ID。
(2) Master 端跑一个程序去生成任务（Request/url/ID）。Master 端负责的是生产任务，并把任务去重、加入到待爬队列。Slaver 只管从 Master 端拿任务去爬。
优点： 将生成任务和抓取数据分开，分工明确，减少了 Master 和 Slaver 之间的数据交流；Master 端生成任务还有一个好处就是：可以很方便地重写判重策略（当数据量大时优化判重的性能和速度还是很重要的）。
缺点： 像 QQ 或者新浪微博这种网站，发送一个请求，返回的内容里面可能包含几十个待爬的用户 ID，即几十个新爬虫任务。但有些网站一个请求只能得到一两个新任务，并且返回的内容里也包含爬虫要抓取的目标信息，如果将生成任务和抓取任务分开反而会降低爬虫抓取效率。毕竟带宽也是爬虫的一个瓶颈问题，我们要秉着发送尽量少的请求为原则，同时也是为了减轻网站服务器的压力，要做一只有道德的 Crawler。所以，视情况而定。
3.Master 中只有一个集合，它只有查询的作用。Slaver 在遇到新任务时询问 Master 此任务是否已爬，如果未爬则加入 Slaver 自己的待爬队列中，Master 把此任务记为已爬。它和策略一比较像，但明显比策略一简单。策略一的简单是因为有 scrapy-redis 实现了 scheduler 中间件，它并不适用于非 scrapy 框架的爬虫。
优点： 实现简单，非 scrapy 框架的爬虫也适用。Master 端压力比较小，Master 与 Slaver 的数据交流也不大。
缺点：“健壮性”不够，需要另外定时保存待爬队列以实现“断点续爬”功能。各 Slaver 的待爬任务不通用。
如果把 Slaver 比作工人，把 Master 比作工头。策略一就是工人遇到新任务都上报给工头，需要干活的时候就去工头那里领任务；策略二就是工头去找新任务，工人只管从工头那里领任务干活；策略三就是工人遇到新任务时询问工头此任务是否有人做了，没有的话工人就将此任务加到自己的“行程表”。
Python爬虫

ㅤ普通",
Python 进阶面试题阅读指南（必看）,"大家好，我是帅地。 为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。 由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. Python 中类方法、类实例方法、静态方法有何区别？
1. Python 中类方法、类实例方法、静态方法有何区别？
2. Python 的内存管理机制及调优手段？
2. Python 的内存管理机制及调优手段？
3. 内存泄露是什么？如何避免？
3. 内存泄露是什么？如何避免？
4. Python 函数调用的时候参数的传递方式是值传递还是引用传递？
4. Python 函数调用的时候参数的传递方式是值传递还是引用传递？
5. 对缺省参数的理解？
5. 对缺省参数的理解？
6. 为什么函数名字可以当做参数用？
6. 为什么函数名字可以当做参数用？
7. Python 中 pass 语句的作用是什么？
7. Python 中 pass 语句的作用是什么？
8. 面向对象中super的作用？
8. 面向对象中super的作用？
9. json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？
9. json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？
10. 什么是断言？应用场景？
10. 什么是断言？应用场景？
11. 有用过with statement吗？它的好处是什么？
11. 有用过with statement吗？它的好处是什么？
12. 简述 Python 在异常处理中，else 和 finally 的作用分别是什么？
12. 简述 Python 在异常处理中，else 和 finally 的作用分别是什么？
13. map 函数和 reduce 函数？
13. map 函数和 reduce 函数？
14. 递归函数停止的条件？
14. 递归函数停止的条件？
15. 回调函数，如何通信的？
15. 回调函数，如何通信的？
16. setattr，getattr，delattr函数使用详解？
16. setattr，getattr，delattr函数使用详解？
17. 请描述抽象类和接口类的区别和联系？
17. 请描述抽象类和接口类的区别和联系？
18. 请描述方法重载与方法重写？
18. 请描述方法重载与方法重写？
19. 什么是 lambda 函数？ 有什么好处？
19. 什么是 lambda 函数？ 有什么好处？
20. 单例模式的应用场景有哪些？
20. 单例模式的应用场景有哪些？
21. 什么是闭包？
21. 什么是闭包？
22. 什么是装饰器？
22. 什么是装饰器？
23. 函数装饰器有什么作用？
23. 函数装饰器有什么作用？
24. 是否使用过functools中的函数？其作用是什么？
24. 是否使用过functools中的函数？其作用是什么？
25. 生成器、迭代器的区别
25. 生成器、迭代器的区别
26. 多线程交互，访问数据，如果访问到了就不访问了，怎么避免重读？
26. 多线程交互，访问数据，如果访问到了就不访问了，怎么避免重读？
27. Python 中 yield 的用法？
27. Python 中 yield 的用法？
28. 谈下 python 的 GIL
28. 谈下 python 的 GIL
29. Python 中的可变对象和不可变对象？
29. Python 中的可变对象和不可变对象？
30. 一句话解释什么样的语言能够用装饰器？
30. 一句话解释什么样的语言能够用装饰器？
31. Python 中 is 和==的区别？
31. Python 中 is 和==的区别？
32. 谈谈你对面向对象的理解？
32. 谈谈你对面向对象的理解？
33. Python 里 match 与 search 的区别？
33. Python 里 match 与 search 的区别？
34. 用 Python 匹配 HTML g tag 的时候， 和 有什么区别？
34. 用 Python 匹配 HTML g tag 的时候， 和 有什么区别？
35. Python 中的进程与线程的使用场景？
35. Python 中的进程与线程的使用场景？
36. 解释一下并行（parallel）和并发（concurrency）的区别？
36. 解释一下并行（parallel）和并发（concurrency）的区别？
37. 如果一个程序需要进行大量的 IO 操作，应当使用并行还是并发？
37. 如果一个程序需要进行大量的 IO 操作，应当使用并行还是并发？
38. 如果程序需要进行大量的逻辑运算操作，应当使用并行还是并发？
38. 如果程序需要进行大量的逻辑运算操作，应当使用并行还是并发？
39. 在 Python 中可以实现并发的库有哪些？
39. 在 Python 中可以实现并发的库有哪些？
40. Python 如何处理上传文件？
40. Python 如何处理上传文件？
41. 请列举你使用过的 Python 代码检测工具？
41. 请列举你使用过的 Python 代码检测工具？
42. python 程序中文输出问题怎么解决？
42. python 程序中文输出问题怎么解决？
43. Python 如何 copy 一个文件？
43. Python 如何 copy 一个文件？
44. 如何用Python删除一个文件？
44. 如何用Python删除一个文件？
45. 如何用 Python 来发送邮件？
45. 如何用 Python 来发送邮件？
46. 当退出 Python 时，是否释放全部内存？
46. 当退出 Python 时，是否释放全部内存？
47. 什么是猴子补丁？
47. 什么是猴子补丁？
Python进阶

ㅤ普通",
Python 中类方法、类实例方法、静态方法有何区别？,"类方法：是类对象的方法，在定义时需要在上方使用“@classmethod”进行装饰，形参为 cls，表示类对象，类对象和实例对象都可调用
类实例方法：是类实例化对象的方法，只有实例对象可以调用，形参为 self，指代对象本身
静态方法：是一个任意函数，在其上方使用“@staticmethod”进行装饰，可以用对象直接调用，静态方法实际上跟该类没有太大关系
Python进阶

ㅤ普通",
Python 的内存管理机制及调优手段？,"内存管理机制：引用计数、垃圾回收、内存池。
引用计数
引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加 1， 当其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。
垃圾回收
(1) 引用计数
引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 的某
个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如
某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0，
那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了
(2)标记清除
如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被
回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引
用摘掉，就会得出这两个对象的有效计数。
(3) 分代回收
从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统
中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾
回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额
外操作。
举个例子：
当某些内存块 M 经过了 3 次垃圾收集的清洗之后还存活时，我们就将内存块 M 划到一个集合 A 中去，而新分配的内存都划分到集合 B 中去。当垃圾收集开始工作时，大多数情况都只对集合 B 进行垃圾回收，而对集合 A 进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合 B 中的某些内存块由于存活时间长而会被转移到集合 A 中，当然，集合 A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。
内存池
(1) Python 的内存机制呈现金字塔形状，-1，-2 层主要有操作系统进行操作
(2) 第 0 层是 C 中的 malloc，free 等内存分配和释放函数进行操作
(3)第 1 层和第 2 层是内存池，有 Python 的接口函数 PyMem_Malloc 函数实现，当对象小于
256K 时有该层直接分配内存
(4) 第 3 层是最上层，也就是我们对 Python 对象的直接操作
Python 在运行期间会大量地执行 malloc 和 free 的操作，频繁地在用户态和核心态之间进行切换，这将严重影响 Python 的执行效率。为了加速 Python 的执行效率，Python 引入了一个内存池机制，用于管理对小块内存的申请和释放。
Python 内部默认的小块内存与大块内存的分界点定在 256 个字节，当申请的内存小于 256 字节时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于 256 字节时，PyObject_Malloc 的行为将蜕化为 malloc 的行为。当然，通过修改 Python 源代码，我们可以改变这个默认值，从而改变 Python 的默认内存管理行为。
Python进阶

ㅤ普通",
内存泄露是什么？如何避免？,"由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。
内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。导致程序运行速度减慢甚至系统崩溃等严重后果。
del() 函数的对象间的循环引用是导致内存泄漏的主凶。
不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。
通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息。
可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为 0 来判断是否内存
泄漏。
Python进阶

ㅤ普通",
Python 函数调用的时候参数的传递方式是值传递还是引用传递？,"Python 的参数传递有：位置参数、默认参数、可变参数、关键字参数。函数的传值到底是值传递还是引用传递，要分情况：
不可变参数用值传递
像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象
可变参数是引用传递的
比如像列表，字典这样的对象是通过引用传递、和 C 语言里面的用指针传递数组很相似，可变对象能在函数内部改变。
Python进阶

ㅤ普通",
对缺省参数的理解？,"缺省参数指在调用函数的时候没有传入参数的情况下，调用默认的参数，在调用函数的同时赋值时，所传入的参数会替代默认参数。
*args 是不定长参数，他可以表示输入参数是不确定的，可以是任意多个。
**kwargs 是关键字参数，赋值的时候是以键 = 值的方式，参数是可以任意多对在定义函数的时候
不确定会有多少参数会传入时，就可以使用两个参数。
补充
*args
如果你之前学过 C 或者 C++，看到星号的第一反应可能会认为这个与指针相关，然后就开始方了，其实放宽心，Python 中是没有指针这个概念的。
在 Python 中我们使用星号收集位置参数，请看下面的例子：
上述例子中，函数的参数有两个，但是我们在输出的时候赋给函数的参数个数不仅仅是两个，让我们来运行这个代码，得到如下的结果：
从上面我们可以看出，参数 x 得到的值是 1，参数 args 得到的是一个元组 (2,3,4,5,6) ，由此我们可以得出，如果输入的参数个数不确定，其它的参数全部通过 *args 以元组的方式由 arg 收集起来。
为了更能明显的看出 *args，我们下面用一个简单的函数来表示：
接下来我传入不同的值，通过参数 *args 得到的结果我们来看一下：
不管是什么，都可以一股脑的塞进元组里，即使只有一个值，也是用元组收集，所以还记得在元组里一个元素的时候的形式吗？元组中如果只有一个元素，该元素的后面要有一个逗号。
那么如果不给 *args 传值呢？
答案就是这时候 *args 收集到的是一个空的元组。
最后提醒一点的是，当使用星号的时候，不一定要把元组参数命名为 args，但这个是 Python 中的一个常见做法。
****kwargs**
使用两个星号是收集关键字参数，可以将参数收集到一个字典中，参数的名字是字典的 “键”，对应的参数的值是字典的 “值”。请看下面的例子：
由例子可以看出，在函数内部，kwargs 是一个字典。
看到这的时候，可能聪明的你会想，参数不是具有不确定型吗？如何知道参数到底会用什么样的方式传值？其实这个很好办，把 *args 和 **kwargs 综合起来就好了啊，请看下面的操作：
如此这般，我们就可以应对各种各样奇葩无聊的参数请求了。当然在这还是要说的是，这里的关键字参数命名不一定要是 kwargs，但这个是通常做法。
Python进阶

ㅤ普通",
为什么函数名字可以当做参数用？,"Python 中一切皆对象，函数名是函数在内存中的空间，也是一个对象。
Python进阶

ㅤ普通",
Python 中 pass 语句的作用是什么？,"在编写代码时只写框架思路，具体实现还未编写就可以用 pass 进行占位，使程序不报错，不会进行任何操作。
Python进阶

ㅤ普通",
面向对象中super的作用？,"super() 函数是用于调用父类(超类)的一个方法。
super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。
MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。
作用：
根据 mro 的顺序执行方法
主动执行 Base 类的方法
Python进阶

ㅤ普通",
是否使用过functools中的函数？其作用是什么？,"Python的functools模块用以为可调用对象（callable objects）定义高阶函数或操作。
简单地说，就是基于已有的函数定义新的函数。
所谓高阶函数，就是以函数作为输入参数，返回也是函数。
Python进阶

ㅤ普通",
json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？,"Python进阶

ㅤ普通",
什么是断言？应用场景？,"assert断言——声明其布尔值必须为真判定，发生异常则为假。
设置一个断言目的就是要求必须实现某个条件。
Python进阶

ㅤ普通",
有用过with statement吗？它的好处是什么？,"with语句的作用是通过某种方式简化异常处理，它是所谓的上下文管理器的一种
用法举例如下：
当你要成对执行两个相关的操作的时候，这样就很方便，以上便是经典例子，with语句会在嵌套的代码执行之后，自动关闭文件。
这种做法的还有另一个优势就是，无论嵌套的代码是以何种方式结束的，它都关闭文件。
如果在嵌套的代码中发生异常，它能够在外部exception handler catch异常前关闭文件。
如果嵌套代码有return/continue/break语句，它同样能够关闭文件。
Python进阶

ㅤ普通",
简述 Python 在异常处理中，else 和 finally 的作用分别是什么？,"如果一个 Try – exception 中，没有发生异常，即 exception 没有执行，那么将会执行 else 语句的内容。反之，如果触发了 Try – exception（异常在 exception 中被定义），那么将会执行exception
中的内容，而不执行 else 中的内容。
如果 try 中的异常没有在 exception 中被指出，那么系统将会抛出 Traceback(默认错误代码）,并且终止程序，接下来的所有代码都不会被执行，但如果有 Finally 关键字，则会在程序抛出 Traceback 之前（程序最后一口气的时候），执行 finally 中的语句。这个方法在某些必须要结束的操作中颇为有用，如释放文件句柄，或释放内存空间等。
Python进阶

ㅤ普通",
map 函数和 reduce 函数？,"(1) 从参数方面来讲：
map()包含两个参数，第一个参数是一个函数，第二个是序列（列表 或元组）。其中，函数（即 map 的第一个参数位置的函数）可以接收一个或多个参数。
reduce()第一个参数是函数，第二个是序列（列表或元组）。但是，其函数必须接收两个参数。
(2) 从对传进去的数值作用来讲：
map()是将传入的函数依次作用到序列的每个元素，每个元素都是独自被函数“作用”一次 。
reduce()是将传人的函数作用在序列的第一个元素得到结果后，把这个结果继续与下一个元素作用（累积计算）。
补充 Python 特殊函数
lambda 函数
lambda 是一个可以只用一行就能解决问题的函数，让我们先看下面的例子：
在上面的这个例子中，函数 add() 充当了一个中间角色，当然上面的例子也可以如下实现：
首先我要说，上面的列表解析式其实是很好用的，但是我偏偏要用 lambda 这个函数代替 add(x) ：
在这里的 lamb 就相当于 add(x) ，lamb = lambda x : x+1 就相当于 add(x) 里的代码块。下面再写几个应用 lambda 的小例子：
由上面的例子我们可以总结一下 lambda 函数的具体使用方法：lambda 后面直接跟变量，变脸后面是冒号，冒号后面是表达式，表达式的计算结果就是本函数的返回值。
在这里有一点需要提醒的是，虽然 lambda 函数可以接收任意多的参数并且返回单个表达式的值，但是 lambda 函数不能包含命令且包含的表达式不能超过一个。如果你需要更多复杂的东西，你应该去定义一个函数。
lambda 作为一个只有一行的函数，在你具体的编程实践中可以选择使用，虽然在性能上没什么提升，但是看着舒服呀。
map 函数
我们在上面讲 lambda 的时候用的例子，其实 map 也可以实现，请看下面的操作：
map 是 Python 的一个内置函数，它的基本格式是：map(func, seq)。
func 是一个函数对象，seq 是一个序列对象，在执行的时候，seq 中的每个元素按照从左到右的顺序依次被取出来，塞到 func 函数里面，并将 func 的返回值依次存到一个列表里。
对于 map 要主要理解以下几个点就好了：
1.对可迭代的对象中的每一个元素，依次使用 fun 的方法（其实本质上就是一个 for 循环）。
2.将所有的结果返回一个 map 对象，这个对象是个迭代器。
我们接下来做一个简单的小题目：将两个列表中的对应项加起来，把结果返回在一个列表里，我们用 map 来做，如果你做完了，请往下看：
你看上面，是不是很简单？其实这个还看不出 map 的方便来，因为用 for 同样也不麻烦，要是你有这样的想法的话，那么请看下面：
你看三个呢？是不是用 for 的话就稍显麻烦了？那么我们在想如果是 四个，五个乃至更多呢？这就显示出 map 的简洁优雅了，并且 map 还不和 lambda 一样对性能没有什么提高，map 在性能上的优势也是杠杠的。
filter 函数
filter 翻译过来的意思是 “过滤器”，在 Python 中，它也确实是起到的是过滤器的作用。这个解释起来略微麻烦，还是直接上代码的好，在代码中体会用法是我在所有的文章里一直在体现的：
上面的例子其实和下面的代码是等价的：
然后我们再来写一个例子体会一下：
reduce 函数
我在之前的文章中很多次都说过，我的代码都是用 Python3 版本的。在 Python3 中，reduce 函数被放到 functools 模块里，在 Python2 中还是在全局命名空间。
同样我先用一个例子来跑一下，我们来看看怎么用：
reduce 函数的第一个参数是一个函数，第二个参数是序列类型的对象，将函数按照从左到右的顺序作用在序列上。如果你还不理解的话，我们下面可以对比一下它和 map 的区别：
对比上面的两个例子，就知道两者的区别，map 相当于是上下运算的，而 reduce 是从左到右逐个元素进行运算。
Python进阶

ㅤ普通",
递归函数停止的条件？,"递归的终止条件一般定义在递归函数内部，在递归调用前要做一个条件判断，根据判断的结果选择是继续调用自身，还是 return;返回终止递归。
终止的条件：
(1) 判断递归的次数是否达到某一限定值
(2) 判断运算的结果是否达到某个范围等，根据设计的目的来选择
Python进阶

ㅤ普通",
回调函数，如何通信的？,"回调函数是把函数的指针(地址)作为参数传递给另一个函数，将整个函数当作一个对象，赋值给调用的函数。
Python进阶

ㅤ普通",
setattr，getattr，delattr函数使用详解？,"1.setattr(self,name,value)：如果想要给 name 赋值的话，就需要调用这个方法。
2.getattr(self,name)：如果 name 被访问且它又不存在，那么这个方法将被调用。
3.delattr(self,name)：如果要删除 name 的话，这个方法就要被调用了。
下面我们用例子来演示一下：
上面的例子中类 Sample 只有两个方法，下面让我们实例化一下：
s.x 这个实例属性本来是不存在的，但是由于类中有了 getattr(self,name) 方法，当发现属性 x 不存在于对象的 dict 中时，就调用了 getattr，也就是所谓的「拦截成员」。
同理，给对象的属性赋值的时候，调用了 setattr(self,name,value) 方法，这个方法中有 self.dict[name] = value，通过这个就将属性和数据存到了对象 dict 中。如果再调用这个属性的话，会成为下面这样：
出现这种结果的原因是它已经存在于对象的 dict 中了。
看了上面的两个，你是不是觉得上面的方法很有魔力呢？这就是「黑魔法」，但是它具体有什么应用呢？我们接着来看：
上面是我根据一个很有名的例子改编的，你可以先想一下结果，想完以后可以接着往下看：
这段代码运行的结果如上面所示，作为一个强迫证的码农，对于这种可以改进的程序当然不能容忍。我们在上面介绍的特殊方法，我们一定要学以致用，虽然重新写的不一定比原来的好，但我们还是要尝试去用：
我们来看一下运行的结果：
我们可以看到，除了类的写法变了以外，调用的方式没有变，结果也没有变。
Python进阶

ㅤ普通",
请描述抽象类和接口类的区别和联系？,"(1) 抽象类
规定了一系列的方法，并规定了必须由继承类实现的方法。由于有抽象方法的存在，所以抽象类不能实例化。可以将抽象类理解为毛坯房，门窗、墙面的样式由你自己来定，所以抽象类与作为基类的普通类的区别在于约束性更强。
(2) 接口类
与抽象类很相似，表现在接口中定义的方法，必须由引用类实现，但他与抽象类的根本区别在于用途：与不同个体间沟通的规则（方法），你要进宿舍需要有钥匙，这个钥匙就是你与宿舍的接口，你的同室也有这个接口，所以他也能进入宿舍，你用手机通话，那么手机就是你与他人交流的接口。
(3) 区别和关联
接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类中可以有非抽象方法。抽象类是声明方法的存在而不去实现它的类。
接口可以继承，抽象类不行。
接口定义方法，没有实现的代码，而抽象类可以实现部分方法。
接口中基本数据类型为 static 而抽类象不是。
接口可以继承，抽象类不行。
可以在一个类中同时实现多个接口。
接口的使用方式通过 implements 关键字进行，抽象类则是通过继承 extends 关键字进行。
Python进阶

ㅤ普通",
请描述方法重载与方法重写？,"(1)方法重载
是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。重载是让类以统一的方式处理不同类型数据的一种手段。
(2) 方法重写
子类不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。
Python进阶

ㅤ普通",
什么是 lambda 函数？ 有什么好处？,"lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数
1、lambda 函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用，连名字都很随意的情况下
2、匿名函数，一般用来给 filter， map 这样的函数式编程服务
3、作为回调函数，传递给某些应用，比如消息处理
补充
lambda 是一个可以只用一行就能解决问题的函数，让我们先看下面的例子：
在上面的这个例子中，函数 add() 充当了一个中间角色，当然上面的例子也可以如下实现：
首先我要说，上面的列表解析式其实是很好用的，但是我偏偏要用 lambda 这个函数代替 add(x) ：
在这里的 lamb 就相当于 add(x) ，lamb = lambda x : x+1 就相当于 add(x) 里的代码块。下面再写几个应用 lambda 的小例子：
由上面的例子我们可以总结一下 lambda 函数的具体使用方法：lambda 后面直接跟变量，变脸后面是冒号，冒号后面是表达式，表达式的计算结果就是本函数的返回值。
在这里有一点需要提醒的是，虽然 lambda 函数可以接收任意多的参数并且返回单个表达式的值，但是 lambda 函数不能包含命令且包含的表达式不能超过一个。如果你需要更多复杂的东西，你应该去定义一个函数。
lambda 作为一个只有一行的函数，在你具体的编程实践中可以选择使用，虽然在性能上没什么提升，但是看着舒服呀。
Python进阶

ㅤ普通",
单例模式的应用场景有哪些？,"单例模式应用的场景一般发现在以下条件下：
（1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。
（2）控制资源的情况下，方便资源之间的互相通信。如线程池等。 1.网站的计数器 2.应用配置 3.多线程池 4.数据库配置，数据库连接池 5.应用程序的日志应用….
补充
01.单例设计模式
「单例设计模式」估计对很多人来说都是一个陌生的概念，其实它就环绕在你的身边。比如我们每天必用的听歌软件，同一时间只能播放一首歌曲，所以对于一个听歌的软件来说，负责音乐播放的对象只有一个；再比如打印机也是同样的道理，同一时间打印机也只能打印一份文件，同理负责打印的对象也只有一个。
结合说的听歌软件和打印机都只有唯一的一个对象，就很好理解「单例设计模式」。

  单例设计模式确保一个类只有一个实例，并提供一个全局访问点。

「单例」就是单个实例，我们在定义完一个类的之后，一般使用「类名()」的方式创建一个对象，而单例设计模式解决的问题就是无论执行多少遍「类名()」，返回的对象内存地址永远是相同的。
02.__new__ 方法
当我们使用「类名()」创建对象的时候，Python 解释器会帮我们做两件事情：第一件是为对象在内存分配空间，第二件是为对象进行初始化。初始化（init）我们已经学过了，那「分配空间」是哪一个方法呢？就是我们这一小节要介绍的 new 方法。
那这个 new 方法和单例设计模式有什么关系呢？单例设计模式返回的对象内存地址永远是相同的，这就意味着在内存中这个类的对象只能是唯一的一份，为达到这个效果，我们就要了解一下为对象分配空间的 new 方法。
明确了这个目的以后，接下来让我们看一下 new 方法。new 方法在内部其实做了两件时期：第一件事是为「对象分配空间」，第二件事是「把对象的引用返回给 Python 解释器」。当 Python 的解释器拿到了对象的引用之后，就会把对象的引用传递给 init 的第一个参数 self，init 拿到对象的引用之后，就可以在方法的内部，针对对象来定义实例属性。
这就是 new 方法和 init 方法的分工。
总结一下就是：之所以要学习 new 方法，就是因为需要对分配空间的方法进行改造，改造的目的就是为了当使用「类名()」创建对象的时候，无论执行多少次，在内存中永远只会创造出一个对象的实例，这样就可以达到单例设计模式的目的。
03.重写 __new__ 方法
在这里我用一个 new 方法的重写来做一个演练：首先定义一个打印机的类，然后在类里重写一下 new 方法。通过对这个方法的重写来强化一下 new 方法要做的两件事情：在内存中分配内存空间 & 返回对象的引用。同时验证一下，当我们使用「类名()」创建对象的时候，Python 解释器会自动帮我们调用 new 方法。
首先我们先定义一个打印机类 Printer，并创建一个实例：
接下来就是重写 new 方法，在此之前，先说一下注意事项，只要⚠️了这几点，重写 new 就没什么难度：
重写 new 方法一定要返回对象的引用，否则 Python 的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法；
new 是一个静态方法，在调用时需要主动传递 cls 参数。
上述代码对 new 方法进行了重写，我们先来看一下输出结果：
上述的结果打印出了 new 方法和 init 方法里的内容，同时还打印了类的内存地址，顺序正好是我们在之前说过的。new 方法里的三行代码正好做了在本小节开头所说的三件事：
instance = super().new(cls)：为对象分配内存空间（因为 new 本身就有为对象分配内存空间的能力，所以在这直接调用父类的方法即可）；
return instance：返回对象的引用。
04.设计单例模式
说了这么多，接下来就让我们用单例模式来设计一个单例类。乍一看单例类看起来比一般的类更唬人，但其实就是差别在一点：单例类在创建对象的时候，无论我们调用多少次创建对象的方法，得到的结果都是内存中唯一的对象。
可能到这有人会有疑惑：怎么知道用这个类创建出来的对象是同一个对象呢？其实非常的简单，我们只需要多调用几次创建对象的方法，然后输出一下方法的返回结果，如果内存地址是相同的，说明多次调用方法返回的结果，本质上还是同一个对象。
上面是一个一般类的多次调用，打印的结果如下所示：
可以看出，一般类中多次调用的内存地址不同（即 printer1 和 printer2 是两个完全不同的对象），而单例设计模式设计的单例类 Printer()，要求是无论调用多少次创建对象的方法，控制台打印出来的内存地址都是相同的。
那么我们该怎么实现呢？其实很简单，就是多加一个「类属性」，用这个类属性来记录「单例对象的引用」。
为什么要这样呢？其实我们一步一步的来想，当我们写完一个类，运行程序的时候，内存中其实是没有这个类创建的对象的，我们必须调用创建对象的方法，内存中才会有第一个对象。在重写 new 方法的时候，我们用 instance = super().new(cls) ，为对象分配内存空间，同时用 istance 类属性记录父类方法的返回结果，这就是第一个「对象在内存中的返回地址」。当我们再次调用创建对象的方法时，因为第一个对象已经存在了，我们直接把第一个对象的引用做一个返回，而不用再调用 super().new(cls) 分配空间这个方法，所以就不会在内存中为这个类的其它对象分配额外的内存空间，而只是把之前记录的第一个对象的引用做一个返回，这样就能做到无论调用多少次创建对象的方法，我们永远得到的是创建的第一个对象的引用。
这个就是使用单例设计模式解决在内存中只创建唯一一个实例的解决办法。下面我就根据上面所说的，来完成单例设计模式。
上述代码很简短，首先给类属性复制为 None，在 new 方法内部，如果 instance 为 None，证明第一个对象还没有创建，那么就为第一个对象分配内存空间，如果 instance 不为 None，直接把类属性中保存的第一个对象的引用直接返回，这样在外界无论调用多少次创建对象的方法，得到的对象的内存地址都是相同的。
下面我们运行一下程序，来看一下结果是不是能印证我们的说法：
上述输出的两个结果可以看出地址完全一样，这说明 printer1 和 printer2 本质上是相同的一个对象。
Python进阶

ㅤ普通",
什么是闭包？,"我们都知道在数学中有闭包的概念，但此处我要说的闭包是计算机编程语言中的概念，它被广泛的使用于函数式编程。
关于闭包的概念，官方的定义颇为严格，也很难理解，在《Python语言及其应用》一书中关于闭包的解释我觉得比较好 — 闭包是一个可以由另一个函数动态生成的函数，并且可以改变和存储函数外创建的变量的值。乍一看，好像还是比较很难懂，下面我用一个简单的例子来解释一下：
毋庸置疑，第一段程序是可以运行成功的，a = 1 定义的变量在函数里可以被调用，但是反过来，第二段程序则出现了报错。
在函数 fun() 里可以直接使用外面的 a = 1，但是在函数 fun1() 外面不能使用它里面所定义的 b = 1，如果我们根据作用域的关系来解释，是没有什么异议的，但是如果在某种特殊情况下，我们必须要在函数外面使用函数里面的变量，该怎么办呢？
我们先来看下面的例子：
如果你看过昨天的文章，你一定觉得的很眼熟，上述的本质就是我们昨天所讲的嵌套函数。
在函数 fun() 里面，有 a = 1 和 函数 fun1() ,它们两个都在函数 fun() 的环境里面，但是它们两个是互不干扰的，所以 a 相对于 fun1() 来说是自由变量，并且在函数 fun1() 中应用了这个自由变量 — 这个 fun1() 就是我们所定义的闭包。
闭包实际上就是一个函数，但是这个函数要具有 1.定义在另外一个函数里面(嵌套函数)；2.引用其所在环境的自由变量。
上述例子通过闭包在 fun() 执行完毕时，a = 1依然可以在 f() 中，即 fun1() 函数中存在，并没有被收回，所以 print(f()) 才得到了结果。
当我们在某些时候需要对事务做更高层次的抽象，用闭包会相当舒服。比如我们要写一个二元一次函数，如果不使用闭包的话相信你可以轻而易举的写出来，下面让我们来用闭包的方式完成这个一元二次方程：
上面的函数中，f = fun(1,2,3) 定义了一个一元二次函数的函数对象，x^2 + 2x + 3，如果要计算 x = 2 ，该一元二次函数的值，只需要计算 f(2) 即可，这种写法是不是看起来更简洁一些。
Python进阶

ㅤ普通",
什么是装饰器？,"「装饰器」作为 Python 高级语言特性中的重要部分，是修改函数的一种超级便捷的方式，适当使用能够有效提高代码的可读性和可维护性，非常的便利灵活。
「装饰器」本质上就是一个函数，这个函数的特点是可以接受其它的函数当作它的参数，并将其替换成一个新的函数（即返回给另一个函数）。
可能现在这么看的话有点懵，为了深入理解「装饰器」的原理，我们首先先要搞明白「什么是函数对象」，「什么是嵌套函数」，「什么是闭包」。关于这三个问题我在很久以前的文章中已经写过了，你只需要点击下面的链接去看就好了，这也是面试中常问的知识哦：
零基础学习 Python 之函数对象
零基础学习 Python 之函数对象
零基础学习 Python 之嵌套函数
零基础学习 Python 之嵌套函数
零基础学习 Python 之闭包
零基础学习 Python 之闭包
装饰器
搞明白上面的三个问题，其实简单点来说就是告诉你：函数可以赋值给变量，函数可嵌套，函数对象可以作为另一个函数的参数。
首先我们来看一个例子，在这个例子中我们用到了前面列出来的所有知识：
上述代码的执行结果如下所示：
上面的程序中，这个就是 first 函数接收了 man 函数作为参数，并将 man 函数以一个新的函数进行替换。看到这你有没有发现，这个和我在文章刚开始时所说的「装饰器」的描述是一样的。既然这样的话，那我们就把上述的代码改造成符合 Python 装饰器的定义和用法的样子，具体如下所示：
上面这段代码和之前的代码的作用一模一样。区别在于之前的代码直接“明目张胆”的使用 first 函数去封装 man 函数，而上面这个是用了「语法糖」来封装 man 函数。至于什么是语法糖，不用细去追究，你就知道是类似「@first」这种形式的东西就好了。
在上述代码中「@frist」在 man 函数的上面，表示对 man 函数使用 first 装饰器。「@」 是装饰器的语法，「first」是装饰器的名称。
下面我们再来看一个复杂点的例子，用这个例子我们来更好的理解一下「装饰器」的使用以及它作为 Python 语言高级特性被人津津乐道的部分：
上述实现了一个特殊的栈，特殊在多了检查当前用户是否为 admin 这步判断，如果当前用户不是 admin，则抛出异常。上面的代码中将检查当前用户的身份写成了一个独立的函数 check_admin，在 push 和 pop 中只需要调用这个函数即可。这种方式增强了代码的可读性，减少了代码冗余，希望大家在编程的时候可以具有这种意识。
下面我们来看看上述代码用装饰器来写成的效果：
PS：可能很多人对 *args 和 **kwargs 不太熟悉，详情请戳下面的链接：
Python 拓展之 *args & **kwargs
Python 拓展之 *args & **kwargs
对比一下使用「装饰器」和不使用装饰器的两种写法，乍一看，好像使用「装饰器」以后代码的行数更多了，但是你有没有发现代码看起来好像更容易理解了一些。在没有装饰器的时候，我们先看到的是 check_admin 这个函数，我们得先去想这个函数是干嘛的，然后看到的才是对栈的操作；而使用装饰器的时候，我们上来看到的就是对栈的操作语句，至于 check_admin 完全不会干扰到我们对当前函数的理解，所以使用了装饰器可读性更好了一些。
就和我在之前的文章中所讲的「生成器」那样，虽然 Python 的高级语言特性好用，但也不能乱用。装饰器的语法复杂，通过我们在上面缩写的装饰器就可以看出，它写完以后是很难调试的，并且使用「装饰器」的程序的速度会比不使用装饰器的程序更慢，所以还是要具体场景具体看待。
Python进阶

ㅤ普通",
函数装饰器有什么作用？,"装饰器本质上是一个 Python 函数，它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能。装饰器的返回值也是一个函数的对象，它经常用于有切面需求的场景。 比如：插入日志、性能测试、事务处理、缓存、权限的校验等场景 有了装饰器就可以抽离出大量的与函数功能本身无关的雷同代码并发并继续使用。
Python进阶

ㅤ普通",
是否使用过functools中的函数？其作用是什么？,"Python的functools模块用以为可调用对象（callable objects）定义高阶函数或操作。
简单地说，就是基于已有的函数定义新的函数。
所谓高阶函数，就是以函数作为输入参数，返回也是函数。
Python进阶

ㅤ普通",
生成器、迭代器的区别,"迭代器是一个更抽象的概念，任何对象，如果它的类有 next 方法和 iter 方法返回自己本身，对于 string、list、dict、tuple 等这类容器对象，使用 for 循环遍历是很方便的。在后台 for 语句对容器对象调用 iter()函数，iter()是 python 的内置函数。iter()会返回一个定义了 next()方法的迭代器对象，它在容器中逐个访问容器内元素，next()也是 python 的内置函数。在没有后续元素时，next()会抛出一个 StopIteration 异常。
生成器（Generator）是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，只是在需要返回数据的时候使用 yield 语句。每次 next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）
区别：生成器能做到迭代器能做的所有事,而且因为自动创建了 iter()和 next()方法,生成器显得特别简洁,而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法,当发生器终结时,还会自动抛出 StopIteration 异常。
Python进阶

ㅤ普通",
多线程交互，访问数据，如果访问到了就不访问了，怎么避免重读？,"创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁，在多线程访问数据的时候先查看数据是否已经在已访问的列表中，若已存在就直接跳过。
Python进阶

ㅤ普通",
Python 中 yield 的用法？,"yield 就是保存当前程序执行状态。你用 for 循环的时候，每次取一个元素的时候就会计算一次。用yield 的函数叫 generator，和 iterator 一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间。generator每次计算需要上一次计算结果，所以用 yield，否则一 return，上次计算结果就没了。
补充
在 Python 中，定义生成器必须要使用 yield 这个关键词，yield 翻译成中文有「生产」这方面的意思。在 Python 中，它作为一个关键词，是生成器的标志。接下来我们来看一个例子：
上面是写了一个很简单的 f 函数，代码块是 3 个 yield 发起的语句，下面让我们来看看如何使用它：
上述操作可以看出，我们调用函数得到了一个生成器（generator）对象。
在上面我们看到了 iter() 和 next()，虽然我们在函数体内没有显示的写 iter() 和 next()，仅仅是写了 yield，但它就已经是「迭代器」了。既然如此，那我们就可以进行如下操作：
从上面的简单操作可以看出：含有 yield 关键词的函数 f() 是一个生成器对象，这个生成器对象也是迭代器。所以就有了这样的定义：把含有 yield 语句的函数称为生成器，生成器是一种用普通函数语法定义的迭代器。
通过上面的例子可以看出，这个生成器（即迭代器）在定义的过程中并没有昨天讲的迭代器那样写 iter()，而是只用了 yield 语句，之后一个普普通通的函数就神奇的成了生成器，同样也具备了迭代器的特性。
yield 语句的作用，就是在调用的时候返回相应的值。下面我来逐行的解释一下上面例子的运行过程：
1.fa = f()：fa 引用生成器对象。
2.fa.next()：生成器开始执行，遇到了第一个 yield，然后返回后面的 0，并且挂起（即暂停执行）。
3.fa.next()：从上次暂停的位置开始，继续向下执行，遇到第二个 yield，返回后面的值 1，再挂起。
4.fa.next()：重复上面的操作。
5.fa.next()：从上次暂停的位置开始，继续向下执行，但是后面已经没有 yield 了，所以 next() 发生异常。
Python进阶

ㅤ普通",
谈下 python 的 GIL,"GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。
多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大
Python进阶

ㅤ普通",
Python 中的可变对象和不可变对象？,"不可变对象，该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。
可变对象，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。
Python 中，数值类型（int 和 float）、字符串 str、元组 tuple 都是不可变类型。而列表 list、字典 dict、集合 set 是可变类型。
Python进阶

ㅤ普通",
一句话解释什么样的语言能够用装饰器？,"函数可以作为参数传递的语言，可以使用装饰器
Python进阶

ㅤ普通",
Python 中 is 和==的区别？,"is 判断的是 a 对象是否就是 b 对象，是通过 id 来判断的。
==判断的是 a 对象的值是否和 b 对象的值相等，是通过 value 来判断的。
Python进阶

ㅤ普通",
谈谈你对面向对象的理解？,"面向对象是相对于面向过程而言的。
面向过程语言是一种基于功能分析的、以算法为中心的程序设计方法
面向对象是一种基于结构分析的、以数据为中心的程序设计思想。在面向对象语言中有一个有很重要东西，叫做类。面向对象有三大特性：封装、继承、多态。
Python进阶

ㅤ普通",
Python 里 match 与 search 的区别？,"match()函数只检测 RE 是不是在 string 的开始位置匹配
search()会扫描整个 string 查找匹配
也就是说 match()只有在 0 位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回 none。
Python进阶

ㅤ普通",
用 Python 匹配 HTML g tag 的时候，<.*> 和 <.*?> 有什么区别？,"<.*>是贪婪匹配，会从第一个“<”开始匹配，直到最后一个“>”中间所有的字符都会匹配到，中间可能会包含“<>”。
<.*?>是非贪婪匹配，从第一个“<”开始往后，遇到第一个“>”结束匹配，这中间的字符串都会匹配到，但是
不会有“<>”。
Python进阶

ㅤ普通",
Python 中的进程与线程的使用场景？,"多进程适合在 CPU 密集型操作(cpu 操作指令比较多，如位数多的浮点运算)。
多线程适合在 IO 密集型操作(读写数据操作较多的，比如爬虫)。
Python进阶

ㅤ普通",
解释一下并行（parallel）和并发（concurrency）的区别？,"并行（parallel）是指同一时刻，两个或两个以上时间同时发生。
并发（parallel）是指同一时间间隔（同一段时间），两个或两个以上时间同时发生。
Python进阶

ㅤ普通",
如果一个程序需要进行大量的 IO 操作，应当使用并行还是并发？,"并发
Python进阶

ㅤ普通",
如果程序需要进行大量的逻辑运算操作，应当使用并行还是并发？,"并行
Python进阶

ㅤ普通",
在 Python 中可以实现并发的库有哪些？,"线程
进程
协程
threading
Python进阶

ㅤ普通",
Python 如何处理上传文件？,"Python 中使用 GET 方法实现上传文件，下面就是用 Get 上传文件的例子，client 用来发 Get 请求，server 用来收请求。
请求端代码
服务端代码
Python进阶

ㅤ普通",
请列举你使用过的 Python 代码检测工具？,"移动应用自动化测试 Appium
OpenStack 集成测试 Tempest
自动化测试框架 STAF
自动化测试平台 TestMaker
JavaScript 内存泄露检测工具 Leak Finder
Python 的 Web 应用验收测试 Splinter
即插即用设备调试工具 UPnP-Inspector
Python进阶

ㅤ普通",
python 程序中文输出问题怎么解决？,"方法一
用encode和decode，如：
方法二
在文件开头加上
Python进阶

ㅤ普通",
Python 如何 copy 一个文件？,"shutil 模块有一个 copyfile 函数可以实现文件拷贝
Python进阶

ㅤ普通",
如何用Python删除一个文件？,"使用 os.remove(filename) 或者 os.unlink(filename)
Python进阶

ㅤ普通",
如何用 Python 来发送邮件？,"python实现发送和接收邮件功能主要用到poplib和smtplib模块。
poplib用于接收邮件，而smtplib负责发送邮件。
Python进阶

ㅤ普通",
当退出 Python 时，是否释放全部内存？,"不是。
循环引用其它对象或引用自全局命名空间的对象的模块，在Python退出时并非完全释放。另外，也不会释放C库保留的内存部分。
Python进阶

ㅤ普通",
什么是猴子补丁？,"在运行期间动态修改一个类或模块。
运行结果为：
Python进阶

ㅤ普通",
