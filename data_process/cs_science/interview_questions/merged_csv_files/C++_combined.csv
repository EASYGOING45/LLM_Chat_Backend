什么是C++ STL？,"C++ STL从广义来讲包括了三类：算法，容器和迭代器。
C++STL"
什么时候需要用hash_map，什么时候需要用map?,"总体来说，hash_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小无关，属于常数级别;而 map 的查找速度是 log(n) 级别。
并不一定常数就比 log(n) 小，hash 还有 hash 函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑 hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map 可能会让你陷入尴尬，特别是当你的 hash_map 对象特别多时，你就更无法控制了。而且 hash_map 的构造速度较慢。
现在知道如何选择了吗？权衡三个因素:  查找速度,  数据量,  内存使用  。
C++STL"
STL中hashtable的底层实现？,"STL中的hashtable使用的是开链法解决hash冲突问题，如下图所示。

hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作
在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。
C++STL"
vector 底层原理及其相关面试题,"vector底层是一个动态数组，包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。
当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。
当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。
因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了。

reserve是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以提高效率，其次还可以减少多次要拷贝数据的问题。reserve只是保证vector中的空间大小（capacity）最少达到参数所指定的大小n。reserve()只有一个参数。
resize()可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变。resize()可以有多个参数。
size表示当前vector中有多少个元素（finish – start），而capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage – start）。
vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用。
当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。
当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it);。
vec.clear()：清空内容，但是不释放内存。
vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。
vec.shrink_to_fit()：请求容器降低其capacity和size匹配。
vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。
根据查阅的资料显示，考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2倍的方式扩容，或者以1.5倍的方式扩容。
以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间：

C++STL"
list 底层原理及其相关面试题,"list的底层是一个双向链表，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。
list不支持随机存取，适合需要大量的插入和删除，而不关心随即存取的应用场景。

C++STL"
deque底层原理及其相关面试题,"deque是一个双向开口的连续线性空间（双端队列），在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。

vector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。
list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。
需要从首尾两端进行插入或删除操作的时候需要选择deque。
C++STL"
Vector如何释放空间?,"由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。
如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。
C++STL"
如何在共享内存上使用STL标准库？,"1)  想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。
我们没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。
当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。
一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。
2) 假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？
一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。
进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。
C++STL"
map插入方式有哪几种？,"1) 用insert函数插入pair数据，
2) 用insert函数插入value_type数据
3) 在insert函数中使用make_pair()函数
4) 用数组方式插入数据
C++STL"
map 、set、multiset、multimap 底层原理及其相关面试题,"map 、set、multiset、multimap的底层实现都是红黑树，epoll模型的底层数据结构也是红黑树，linux系统中CFS进程调度算法，也用到红黑树。

红黑树的特性：
根结点是黑色；
每个叶结点是黑的；
如果一个结点是红的，则它的两个儿子均是黑色；
每个结点到其子孙结点的所有路径上包含相同数目的黑色结点。
红黑树详解具体看这篇：别再问我什么是红黑树了
别再问我什么是红黑树了
对于STL里的map容器，count方法与find方法，都可以用来判断一个key是否出现，mp.count(key) > 0统计的是key出现的次数，因此只能为0/1，而mp.find(key) != mp.end()则表示key存在。
set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。
map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以map默认是按key排序的），map中元素的key不允许重复，multimap可以重复。
map和set的增删改查速度为都是logn，是比较高效的。
因为存储的是结点，不需要内存拷贝和内存移动。
因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。
因为在map和set内部存储的已经不是元素本身了，而是包含元素的结点。也就是说map内部使用的Alloc并不是map<Key, Data, Compare, Alloc>声明的时候从参数中传入的Alloc。
C++STL"
unordered_map、unordered_set 底层原理及其相关面试题,"unordered_map的底层是一个防冗余的哈希表（采用除留余数法）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存。
使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数（一般使用除留取余法），也叫做散列函数），使得每个元素的key都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照key为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。
但是，不能够保证每个元素的key与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 一般可采用拉链法解决冲突：

构造函数：unordered_map 需要hash函数，等于函数;map只需要比较函数(小于函数).
存储结构：unordered_map 采用hash表存储，map一般采用红黑树(RB Tree) 实现。因此其memory数据结构是不一样的。
总体来说，unordered_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑unordered_map 。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，unordered_map 可能会让你陷入尴尬，特别是当你的unordered_map 对象特别多时，你就更无法控制了，而且unordered_map 的构造速度较慢。
C++STL"
迭代器的底层机制和失效的问题,"迭代器是连接容器和算法的一种重要桥梁，通过迭代器可以在不了解容器内部原理的情况下遍历容器。它的底层实现包含两个重要的部分：萃取技术和模板偏特化。
萃取技术（traits）可以进行类型推导，根据不同类型可以执行不同的处理流程，比如容器是vector，那么traits必须推导出其迭代器类型为随机访问迭代器，而list则为双向迭代器。
例如STL算法库中的distance函数，distance函数接受两个迭代器参数，然后计算他们两者之间的距离。显然对于不同的迭代器计算效率差别很大。比如对于vector容器来说，由于内存是连续分配的，因此指针直接相减即可获得两者的距离；而list容器是链式表，内存一般都不是连续分配，因此只能通过一级一级调用next()或其他函数，每调用一次再判断迭代器是否相等来计算距离。vector迭代器计算distance的效率为O(1),而list则为O(n),n为距离的大小。
使用萃取技术（traits）进行类型推导的过程中会使用到模板偏特化。模板偏特化可以用来推导参数，如果我们自定义了多个类型，除非我们把这些自定义类型的特化版本写出来，否则我们只能判断他们是内置类型，并不能判断他们具体属于是个类型。
当函数，类或者一些封装的通用算法中的某些部分会因为数据类型不同而导致处理或逻辑不同时，traits会是一种很好的解决方案。
输入迭代器：是只读迭代器，在每个被遍历的位置上只能读取一次。例如上面find函数参数就是输入迭代器。
输出迭代器：是只写迭代器，在每个被遍历的位置上只能被写一次。
前向迭代器：兼具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。但它不支持operator–，所以只能向前移动。
双向迭代器：很像前向迭代器，只是它向后移动和向前移动同样容易。
随机访问迭代器：有双向迭代器的所有功能。而且，它还提供了“迭代器算术”，即在一步内可以向前或向后跳跃任意位置， 包含指针的所有操作，可进行随机访问，随意移动指定的步数。支持前面四种Iterator的所有操作，并另外支持it + n、it – n、it += n、 it -= n、it1 – it2和it[n]等操作。
（1）插入操作
对于vector和string，如果容器内存被重新分配，iterators,pointers,references失效；如果没有重新分配，那么插入点之前的iterator有效，插入点之后的iterator失效；
对于deque，如果插入点位于除front和back的其它位置，iterators,pointers,references失效；当我们插入元素到front和back时，deque的迭代器失效，但reference和pointers有效；
对于list和forward_list，所有的iterator,pointer和refercnce有效。
（2）删除操作
对于vector和string，删除点之前的iterators,pointers,references有效；off-the-end迭代器总是失效的；
对于deque，如果删除点位于除front和back的其它位置，iterators,pointers,references失效；当我们插入元素到front和back时，off-the-end失效，其他的iterators,pointers,references有效；
对于list和forward_list，所有的iterator,pointer和refercnce有效。
对于关联容器map来说，如果某一个元素已经被删除，那么其对应的迭代器就失效了，不应该再被使用，否则会导致程序无定义的行为。
C++STL"
为什么vector的插入操作可能会导致迭代器失效？,"vector动态增加大小时，并不是在原空间后增加新的空间，而是以原大小的两倍在另外配置一片较大的新空间，然后将内容拷贝过来，并释放原来的空间。由于操作改变了空间，所以迭代器失效。
C++STL"
vector的reserve()和resize()方法之间有什么区别？,"首先，vector的容量capacity()是指在不分配更多内存的情况下可以保存的最多元素个数，而vector的大小size()是指实际包含的元素个数；
其次，vector的reserve(n)方法只改变vector的容量，如果当前容量小于n，则重新分配内存空间，调整容量为n；如果当前容量大于等于n，则无操作；
最后，vector的resize(n)方法改变vector的大小，如果当前容量小于n，则调整容量为n，同时将其全部元素填充为初始值；如果当前容量大于等于n，则不调整容量，只将其前n个元素填充为初始值。
C++STL"
标准库中有哪些容器？分别有什么特点？,"标准库中的容器主要分为三类：顺序容器、关联容器、容器适配器。
C++STL"
15万字C++开发面试手册出炉,"不想看介绍的可以直接关注微信公众号 帅地玩编程，然后回复 1023 即可获取对应的 PDF 面试手册

对于 C++ 的学习，很多人可能学了之后，不知道自己处于哪个阶段，也不到究竟要学到哪个程度，帅地觉得，验证自己学得如何最好的面试，就是尝试去面试，而面试无非就是问你一些面试题，所以呢，帅地整理了这些 C++ 面试题，从 C++ 基础，集合，面向对象再到内存管理，并且附带了详细的答案，无论是想面试还是想看看自己学得如何，那么这份面试题，都值得你去学习。
当然，如果单单只会 C++，是很难进大公司的，所以计算机基础之类的也得学，这份手册还包括了Redis，计算机网络，操作系统，MySQL等通用基础知识。
这里提供两种阅读方式：PDF 阅读 和在线阅读
截个图给大家看看目录

无论是 C++ 还是其他基础知识，里面的面试题都整理的很全，例如咱们打开计算机网络

这本整理了大半月的面试手册，无套路送给大家！！！
总共 15 万的字数，微信搜索关注「帅地玩编程」，回复「1023」，即可获取最新版的 PDF 哦，扫码直达

关注后回复「1023」，即可获取最新版的 PDF 哦。
在线阅读会及时更新，大家可以从首页直接进去阅读

链接：https://www.iamshuaidi.com
https://www.iamshuaidi.com
C++STL
C++内存管理
C++基础"
容器内部删除一个元素,"1) 顺序容器（序列式容器，比如vector、deque）
erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；
It = c.erase(it);
2) 关联容器(关联式容器，比如map、set、multimap、multiset等)
erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；
c.erase(it++)
C++STL"
vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？,"1) 通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。
2) map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某人值插入这个map。
3) erase()函数，只能删除内容，不能改变容量大小;
erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器。
C++STL"
map中[ ]与find的区别？,"1) map的下标运算符[ ]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。
2) map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。
C++STL"
STL内存优化？,"STL内存管理使用二级内存配置器。
(1) 第一级配置器：
第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。一级空间配置器分配的是大于128字节的空间，如果分配不成功，调用句柄释放一部分内存，如果还不能分配成功，抛出异常。
第一级配置器只是对malloc函数和free函数的简单封装，在allocate内调用malloc，在deallocate内调用free。同时第一级配置器的oom_malloc函数，用来处理malloc失败的情况。
(2) 第二级配置器：
第一级配置器直接调用malloc和free带来了几个问题：
如果分配的区块小于128bytes，则以内存池管理，第二级配置器维护了一个自由链表数组，每次需要分配内存时，直接从相应的链表上取出一个内存节点就完成工作，效率很高
自由链表数组：自由链表数组其实就是个指针数组，数组中的每个指针元素指向一个链表的起始节点。数组大小为16，即维护了16个链表，链表的每个节点就是实际的内存块，相同链表上的内存块大小都相同，不同链表的内存块大小不同，从8一直到128。如下所示，obj为链表上的节点，free_list就是链表数组。
内存分配：allocate函数内先判断要分配的内存大小，若大于128字节，直接调用第一级配置器，否则根据要分配的内存大小从16个链表中选出一个链表，取出该链表的第一个节点。若相应的链表为空，则调用refill函数填充该链表。默认是取出20个数据块。
填充链表 refill：若allocate函数内要取出节点的链表为空，则会调用refill函数填充该链表。refill函数内会先调用chunk_alloc函数从内存池分配一大块内存，该内存大小默认为20个链表节点大小，当内存池的内存也不足时，返回的内存块节点数目会不足20个。接着refill的工作就是将这一大块内存分成20份相同大小的内存块，并将各内存块连接起来形成一个链表。
内存池：chunk_alloc函数内管理了一块内存池，当refill函数要填充链表时，就会调用chunk_alloc函数，从内存池取出相应的内存。
C++STL"
频繁对vector调用push_back()对性能的影响和原因？,"在一个vector的尾部之外的任何位置添加元素，都需要重新移动元素。而且，向一个vector添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移到新的空间。
C++STL"
静态链接和动态链接有什么区别？,"优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接；
动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；
优点在于多个程序可以共享同一个动态库，节省资源；
缺点在于由于运行时加载，可能影响程序的前期执行性能。
C++基础"
变量的声明和定义有什么区别,"变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。
说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。
C++基础"
简述#ifdef、#else、#endif和#ifndef的作用,"利用#ifdef、#endif将某程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。
在子程序前加上标记，以便于追踪和调试。
应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。
「注意」：虽然不用条件编译命令而直接用if语句也能达到要求，但那样做目标程序长（因为所有语句都编译），运行时间长（因为在程序运行时间对if语句进行测试）。而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。
C++基础"
写出int 、bool、 float 、指针变量与 “零值”比较的if 语句,"首先给个提示：题目中要求的是零值比较，而非与0进行比较，在C++里“零值”的范围可就大了，可以是0， 0.0 ， FALSE或者“空指针”。
下面是答案。
详细解释
int：int 是整型，可以直接和 0 比较。
bool：根据布尔类型的语义，零值为假（记为FALSE），任何非零值都是真（记为TRUE）。TRUE 的值究竟是什么并没有统一的标准。
例如Visual C++ 将TRUE 定义为1，而Visual Basic 则将TRUE 定义为 -1。所以我们不可以将布尔变量直接与TRUE、FALSE 或者1、0 进行比较
float：千万要留意，无论是float 还是double 类型的变量，都有精度限制，都不可以用==”或!=与任何数字比较，应该设法转化成>=或<=`形式。
其中EPSINON 是允许的误差（即精度）
指针：指针变量的零值就是NULL
C++基础"
结构体可以直接赋值吗,"声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。
「注意」：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间。
C++基础"
sizeof 和strlen 的区别,C++基础
C 语言的关键字 static 和 C++ 的关键字 static 有什么区别,"在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。
「注意」：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。
C++基础"
volatile有什么作用,"「注意」：虽然volatile在嵌入式方面应用比较多，但是在PC软件的多线程中，volatile修饰的临界变量也是非常实用的。
C++基础"
一个参数可以既是const又是volatile吗,"可以，用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。
注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。
C++基础"
全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？,C++基础
简述strcpy、sprintf 与memcpy 的区别,"「注意」：strcpy、sprintf 与memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来 选择合适的函数实现拷贝功能。
C++基础"
对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？,"应该使用inline内联函数，即编译器将inline内联函数内的代码替换到函数被调用的地方。
优点：
缺点：
C++基础"
什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？,"智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间。
智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。
分为auto_ptr、unique_ptr、shared_ptr和weak_ptr四种，各自的特点：
在C++11中被摒弃，其主要问题在于：
对于unique_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值；
对于shared_ptr，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源；
对于weak_ptr，解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数。
C++基础"
shared_ptr是如何实现的？,C++基础
右值引用有什么作用？,"右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数
C++基础"
悬挂指针与野指针有什么区别？,C++基础
请解析((void ()( ) )0)( )的含义,C++基础
指针和引用的区别,C++基础
typedef 和define 有什么区别,"「注意」：typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。
C++基础"
简述队列和栈的异同,"队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是 “后进先出”。
「注意」：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分 配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员 分配释放， 若程序员不释放，程序结束时可能由OS 回收。分配方式类似于链表。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。
C++基础"
设置地址为0x67a9 的整型变量的值为0xaa66,"「注意」：这道题就是强制类型转换的典型例子，绝大部份情况下，地址长度和整型数据的长度是一样的(此时的整型指的是 long)， 即一个整型数据可以强制转换成地址指针类型，只要有意义即可。
C++基础"
结构体和类的区别,"「注意」：虽然C的结构体和C++的类有很大的相似度，但是类是实现面向对象的基础。而结构体只可以简单地理解为类的前身。
C++基础"
简述指针常量与常量指针的区别,"「注意」：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。
C++基础"
如何避免“野指针”,C++基础
句柄和指针的区别和联系是什么？,"句柄和指针其实是两个截然不同的概念。Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32bit的uint。指针则标记某个物理内存地址，两者是不同的概念。
C++基础"
说一说extern“C”,"extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。
这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern “C”就是其中的一个策略。
C++基础"
"对c++中的smart pointer四个智能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr的理解","C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。
智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。
采用所有权模式。
此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！
unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。
采用所有权模式。
编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。
另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：
其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。
「注意」：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：
shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。
shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
成员函数：
use_count 返回引用计数的个数
unique 返回是否是独占所有权( use_count 为 1)
swap 交换两个 shared_ptr 对象(即交换所拥有的对象)
reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptrsp(new int(1)); sp 与 sp.get()是等价的
weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。
可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。
「注意」：不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();
C++基础"
C++的顶层const和底层const ？,C++基础
C++中类成员的访问权限,"C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员
C++面向对象"
多态的实现有哪几种？,"多态分为静态多态和动态多态。其中，静态多态是通过重载和模板技术实现的，在编译期间确定；动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定。
C++面向对象"
动态绑定是如何实现的？,"当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针vptr，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。
C++面向对象"
动态多态有什么作用？有哪些必要条件？,"动态多态的作用：
动态多态的必要条件：
C++面向对象"
纯虚函数有什么作用？如何实现？,"定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。
实现方式是在虚函数声明的结尾加上= 0即可。
C++面向对象"
虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？,"虚函数表是针对类的，类的所有对象共享这个类的虚函数表，因为每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不同，但都指向同一虚函数表。
C++面向对象"
为什么基类的构造函数不能定义为虚函数？,"虚函数的调用依赖于虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。
C++面向对象"
为什么基类的析构函数需要定义为虚函数？,"为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。
C++面向对象"
构造函数和析构函数能抛出异常吗？,C++面向对象
如何让一个类不能实例化？,"将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为private。
C++面向对象"
多继承存在什么问题？如何消除多继承中的二义性？,"在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；
消除同名二义性的方法：
当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；
消除路径二义性的方法：
C++面向对象"
如果类A是一个空类，那么sizeof(A)的值为多少？,"sizeof(A)的值为1，因为编译器需要区分这个空类的不同实例，分配一个字节，可以使这个空类的不同实例拥有独一无二的地址。
C++面向对象"
覆盖和重载之间有什么区别？,C++面向对象
拷贝构造函数和赋值运算符重载之间有什么区别？,"一般情况下，类中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数。
C++面向对象"
对虚函数和多态的理解,"多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。
C++面向对象"
请你来说一下C++中struct和class的区别,"在C++中，class和struct做类型定义如下区别：
C++保留struct关键字，主要有如下原因
C++面向对象"
说说C++的四种强制类型转换运算符,"1、reinterpret_cast
reinterpret_cast< type-id > (expression)
type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。
2、const_cast
const_cast (expression)
该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：
3、static_cast
static_cast < type-id > (expression)
该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：
注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。
4、dynamic_cast
有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全
dynamic_cast (expression)
该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*
如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用
dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）
dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全
举个例子：
从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。
C++面向对象"
简述类成员函数的重写、重载和隐藏的区别,"（1）重写和重载主要有以下几点不同。
（2）隐藏和重写、重载有以下几点不同。
「注意」：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完 全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。
C++面向对象"
类型转换分为哪几种？各自有什么样的特点？,"const_cast：用于去除const或volatile属性；
dynamic_cast：用于子类和父类之间的安全转换，可以实现向上向下转换，因为编译器默认向上转换总是安全的，而向下转换时，dynamic_cast具有类型检查的功能；
dynamic_cast转换失败时，对于指针会返回目标类型的nullptr，对于引用会返回bad_cast异常；
reinterpret_cast：用于不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型之间的转换。
C++面向对象"
RTTI是什么？其原理是什么？,"RTTI即运行时类型识别，其功能由两个运算符实现：
C++面向对象"
说一说c++中四种cast转换,"C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast
1、const_cast
2、static_cast
3、dynamic_cast
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
4、reinterpret_cast
5、为什么不使用C的强制转换？
C++面向对象"
C++的空类有哪些成员函数,"「注意」：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是 空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。
C++面向对象"
模板函数和模板类的特例化,"「引入原因」
编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化
「定义」对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上
（1）模板函数特例化
必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参，举例如下：
「本质」特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。
「注意」模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。
（2）类模板特例化
原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template<>表示是一个特例化版本，例如：
「类模板的部分特例化」
不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)
「特例化类中的部分成员」
可以特例化类中的部分成员函数而不是整个类，举个例子：
C++面向对象"
为什么析构函数一般写成虚函数,"由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。举个例子：
将基类的析构函数声明为虚函数：
C++面向对象"
拷贝初始化和直接初始化，初始化和赋值的区别?,"要点就是拷贝初始化和直接初始化调用的构造函数是不一样的，但是当类进行复制时，类会自动生成一个临时的对象，然后再进行拷贝初始化。
C++面向对象"
new/delete和malloc/free之间有什么关系？,"「注意」：delete和free被调用后，内存不会立即回收，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是由于没有重新对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况。因此，释放完内存后，应该讲该指针指向NULL。
C++内存管理"
delete与delete []有什么区别？,"如果反过来使用，即对于单个对象使用delete []，对于对象数组使用delete，其行为是未定义的；
所以，最恰当的方式就是如果用了new，就用delete；如果用了new []，就用delete []。
C++内存管理"
内存块太小导致malloc和new返回空指针，该怎么处理？,"对于new来说，默认抛出异常，所以可以使用try...catch...代码块的方式：
还可以使用set_new_handler函数的方式：
在这种方式里，如果new不能满足内存分配请求，no_more_memory会被反复调用，所以new_handler函数必须完成以下事情：
C++内存管理"
内存泄漏的场景有哪些？,"内存泄漏的场景：
没有将基类的析构函数定义为虚函数。
判断和定位内存泄漏的方法：在Linux系统下，可以使用valgrind、mtrace等内存泄漏检测工具。
C++内存管理"
内存的分配方式有几种？,C++内存管理
堆和栈有什么区别？,C++内存管理
静态内存分配和动态内存分配有什么区别？,C++内存管理
如何构造一个类，使得只能在堆上或只能在栈上分配内存？,C++内存管理
浅拷贝和深拷贝有什么区别？,"浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存；而深拷贝会创造一个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象。
C++内存管理"
字节对齐的原则是什么？,C++内存管理
结构体内存对齐问题,"c++11以后引入两个关键字 alignas与 [alignof]。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式。
但是alignas在某些情况下是不能使用的，具体见下面的例子:
alignas将内存对齐调整为4个字节。所以sizeof(Info2)的值变为了8。
若alignas小于自然对齐的最小单位，则被忽略。
确定结构体中每个元素大小可以通过下面这种方法:
这种处理方式是alignas处理不了的。
C++内存管理"
在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？,"不能。
malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。malloc /free的操作对象都是必须明确大小的。
而且不能用在动态类上。new 和delete会自动进行类型检查和，也不需要自己明确内存大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。
当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。
C++内存管理"
