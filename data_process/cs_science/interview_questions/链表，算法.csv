问题,回答,所属分类
链表专题简介,"在这个专题，我大概会给出 20 道左右的链表题型吧，如果你把我写的这 20 道题都理解 + 代码敲出来了，那么应付面试，是搓搓有余的。
如果是在面试，链表的考察应该是非常频繁的，并且考来考去都是那几道题，例如链表反转，链表中间节点，链表倒数第二个节点，链表成环。
但是呢，作为一名想要学习算法的小伙伴，我认为我们不能止步于此，而是要多做几道，这样会让你更加深刻去理解链表，并且在未来，遇到任何题，都能够顺手拈来。
必须要说明的是，这部分的题，我的解答并不会很详细哈，基本就是说一下大致的思路，然后就给出题解了，目前是用 Java 来写，后续会填补上 python 和 C++，当然，如果你愿意给帅地提供这些代码，帅地会不胜感激。
帅地的愿景就是，把该文章的教程，打造成全网质量最高的编程学习网站，所以会尽最大努力去保证每篇文章的质量，也欢迎你提出意见，和我一起维护这个网站
链表",
链表训练3：如何优雅着反转单链表,"反转单链表。例如链表为：
1->2->3->4
反转后为
4->3->2->1
如果链表的长度为 N, 时间复杂度达到 O(N), 额外空间复杂度达到 O(1)
方法1
这道题还是挺简单的，当我们在反转一个节点的时候，把一个节点的后驱改为指向它前驱就可以了。这里需要注意的点就是，当你把当前节点的后驱指向前驱的时候，这个时候链表会被截断，也就是说后面的节点和当前节点分开了，所以我们需要一个变量来保存当前节点的后驱，以访丢失。
具体代码如下：
代码如下
方法二
这道题也可以用递归来做，假设 方法 reverse() 的功能是将单链表进行逆转。采用递归的方法时，我们可以不断着对子链表进行递归。例如对于如下的链表：

我们对子链表 2->3->4 进行递归，即
Node newList = reverse(head.next)。递归之后的结果如下：

逆转之后子链表 2->3->变为了 4->3->2。
注意，我刚才假设 reverse() 的功能就是对链表进行逆转。不过此时节点 1 仍然是指向节点 2 的。这个时候，我们再把节点1 和 2逆转一下，然后 1 的下一个节点指向 null 就可以了。如图：

递归的结束条件就是：当子链表只有一个节点，或者为 null 时，递归结束。代码如下：
题目：反转部分链表节点
题目：给定一个单向链表的头结点head,以及两个整数from和to ,在单项链表上把第from个节点和第to个节点这一部分进行反转
列如：
1->2->3->4->5->null,from=2,to=4
结果：1->4->3->2->5->null
列如：
1->2->3->null from=1,to=3
结果为3->2->1->null
1、如果链表长度为N，时间复杂度要求为O（N),额外空间复杂度要求为O（1）
2、如果不满足1<=from<=to<=N,则不调整
可以自己动手做一下或者想一下，我这里直接给出答案了
另外，链表反转这道题一定要掌握递归版本的，因为递归版本是最不容易出错的，这道题的考察频率也是挺高的
如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….
https://www.iamshuaidi.com
链表",
链表训练5：三种方法带你优雅判断回文链表,"给定一个链表的头节点 head, 请判断该链表是否为回文结构。
例如：
1->2->1，返回 true.
1->2->2->1, 返回 true。
1->2->3，返回 false。
如果链表的长度为 N, 时间复杂度达到 O(N)。
方法1
我们可以利用栈来做辅助，把链表的节点全部入栈，在一个一个出栈与链表进行对比，例如对于链表 1->2->3->2->2，入栈后如图:

然后再逐一出栈与链表元素对比。
这种解法比较简单，时间复杂度为 O(n), 空间复杂度为 O(n)。
代码如下
方法二
真的需要全部入栈吗？其实我们也可以让链表的后半部分入栈就可以了，然后把栈中的元素与链表的前半部分对比，例如 1->2->3->2->2 后半部分入栈后如图：

然后逐个出栈，与链表的前半部分(1->2)对比。这样做的话空间复杂度会减少一半。
代码如下：
方法三：空间复杂度为 O(1)。
上道题我们有作过链表的反转的，没看过的可以看一下勒：【链表问题】如何优雅着反转单链表]，我们可以把链表的后半部分进行反转，然后再用后半部分与前半部分进行比较就可以了。这种做法额外空间复杂度只需要 O(1), 时间复杂度为 O(n)。
【链表问题】如何优雅着反转单链表
代码如下:
这道题被问的概率也是挺高的，就算代码写不出，也得至少知道思路
思考：如果给你的是一个环形链表，并且指定了头节点，那么该如何判断是否为回文链表呢？

  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….

链表",
链表训练6：将单向链表按某值划分成左边小，中间相等，右边大的形式,"给定一个单向链表的头结点head,节点的值类型是整型，再给定一个整数privot。实现一个调整链表的函数，将链表调整为左部分都是值小于privot的节点，中间部分都是值等于privot的节点，右部分都是大于privot的节点。且对某部分内部节点的顺序不做要求 
例如:链表9-0-4-5-1，pivot=3。 
调整后是1-0-4-9-5，
也可以是0-1-9-5-4
如果链表的长度为 N, 时间复杂度达到 O(N)。
这道题在思路上还是比较简单的，但是在实现上还是有一些细节需要主要的。
本题对某部分的内部节点不做要求，一种很简单的方法就是用一个数组来存链表的节点，然后像类似于快速排序的分割函数那样，按照某个值把他们进行划分。
不过这样做的话，空间复杂度为 O(N)。我们也可以采取使用3个指针，把原链表依次划分成三个部分的链表，然后再把他们合并起来，这种做法不但空间复杂度为 O(1), 而且内部节点的顺序也是和原链表一样的。虽然思路简单，但在代码实现上也是有很多细节需要注意的，有时间的话希望大家动手打下码。
代码如下
思考：如果给你的是一个环形链表，让你来划分，又该如何实现呢？
如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….
https://www.iamshuaidi.com
链表",
链表训练7：复制含有随机指针节点的链表,"如果链表的长度为 N, 时间复杂度达到 O(N)。
尉：★★☆☆
方法一：使用额外的存储空间
这道题的难点在于我们需要定位好随机指针，一个比较简单的解法就是把原节点与复制的节点关联起来，可以使用哈希表把他们关联起来。
首先把副节点全部创建出来，然后把原节点与对应的副节点用哈希表关联起来。关联的时候原节点作为key，副节点作为value。例如对于链表 1->2->3->null。创建副节点 1′, 2′, 3’。然后用哈希表关联起来：
之后在把所有副节点连接成一个链表。在连接的时候，我们 可以通过哈希表很容易这找到对应的随机节点。
代码如下
这种方法的时间复杂度为 O(n), 空间复杂度也为 O(n)。
方法2
其实我们也可以不需要哈希表来辅助，也就是说 ，我们是可以做到空间复杂度为 O(1)的，我们可以把复制的副节点插入到原链表中去，这样也能把原节点与副节点进行关联，进而
定位到随机节点。例如，对于链表 1->2->3->null。首先生成副节点 1′, 2′, 3。然后把副节点插入到原节点的相邻位置，即把原链表变成 1->1′->2->2′->3->3′->null。
这样我们也可以在连接副节点的时候，找到相应的随机节点。例如 1 的随机节点是 3，则 1′ 的随机节点是 3’。显然，1节点的随机节点的下一个节点就是 1’的随机节点。具体代码如下：
采用这种方法的时候，由于随机节点有可能是空指针，随意写代码的时候要注意。
思考：如果是有两个随机指针呢？又该如何处理呢？三个呢？

  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….

链表",
链表训练8：将单链表的每K个节点之间逆序,"给定一个单链表的头节点head, 实现一个调整单链表的函数，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。
例如：
链表:1->2->3->4->5->6->7->8->null, K = 3。
调整后：3->2->1->6->5->4->7->8->null。其中 7，8不调整，因为不够一组。
如果链表的长度为 N, 时间复杂度达到 O(N)。
尉：★★☆☆
对于这道题，如果你不知道怎么逆序一个单链表，那么可以看一下我之前写的【链表问题】如何优雅着反转单链表
【链表问题】如何优雅着反转单链表
这道题我们可以用递归来实现，假设方法reverseKNode()的功能是将单链表的每K个节点之间逆序。reverse()方法的功能是将一个单链表逆序。
那么对于下面的这个单链表，其中 K = 3。

我们把前K个节点与后面的节点分割出来：

temp指向的剩余的链表，可以说是原问题的一个子问题。我们可以调用reverseKNode()方法将temp指向的链表每K个节点之间进行逆序。再调用reverse()方法把head指向的那3个节点进行逆序，结果如下：

接着，我们只需要把这两部分给连接起来就可以了。最后的结果如下：

如果不大理解，看下代码可能就比较好理解了。
代码如下
当然，这道题一个很简单的做法就是利用栈来辅助，每K个节点入栈就把这K个节点出栈连接成一个链表，之后剩余再在进栈.....
不过这种做法的额外空间复杂度是O(K)。
思考：如果这是一个环形单链表呢？该如何实现呢？

  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….

链表",
链表训练9：将搜索二叉树转换成双向链表,"对于二叉树的节点来说，有本身的值域，有指向左孩子和右孩子的两个指针；对双向链表的节点来说，有本身的值域，有指向上一个节点和下一个节点的指针。在结构上，两种结构有相似性，现有一棵搜索二叉树，请将其转为成一个有序的双向链表。
　
节点定义：
例如：

这棵二查搜索树转换后的双向链表从头到尾依次是 1～9。对于每一个节点来说，原来的 right 指针等价于转换后的 next 指针，原来的 left 指针等价于转换后的 last 指针，最后返回转换后的双向链表的头节点。
如果链表的长度为 N, 时间复杂度达到 O(N)。
尉：★★☆☆
方法一：采用队列辅助
如果用一个队列来辅助的话，还是挺容易。采用中序遍历的方法，把二叉树的节点全部放进队列，之后在逐一弹出来连接成双向链表。
代码如下
这种方法的时间复杂度为 O(n), 空间复杂度也为 O(n)。
方法2：通过递归的方式
在之前打卡的9道题中，几乎超过一般都用到了递归，如果这些题目使用的递归大家都理解了，并且能够自己独立写出代码了，那么我相信大家对递归的思想、使用已经有一定的熟练性。
我们假设函数conver的功能就是把二叉树变成双向链表，例如对于这种一棵二叉树：

经过conver转换后变成这样：

注意，转换之后，把最右边节点的right指针指向了最左边的节点的。
对于下面这样一颗二叉树：

采用conver函数分别对左右子树做处理，结果如下：

之后，再把他们连接起来

了解了基本原理之后，直接看代码吧。
时间复杂度为O(n),空间复杂度为O(h)，其中h是二叉树的高度。
原理虽然不难，但写起代码，还是有挺多细节需要注意的，所以一直强调，有时间的话，一定要自己手打一遍代码，有时你以为自己懂了，可能在写代码的时候，发现自己并没有懂，一写就出现很多bug。

  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，帅地正在疯狂更新中….

链表",
