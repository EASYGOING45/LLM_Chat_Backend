问题,回答,所属分类
Java 中常用的容器有哪些？,"常见容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表

Vection的非线程安全操作
Java集合",
ArrayList 和 LinkedList 的区别？,"ArrayList：底层是基于数组实现的，查找快，增删较慢；
LinkedList：底层是基于链表实现的。确切的说是循环双向链表（JDK1.6 之前是双向循环链表、JDK1.7 之后取消了循环），查找慢、增删快。LinkedList 链表由一系列表项连接而成，一个表项包含 3 个部分：元素内容、前驱表和后驱表。链表内部有一个 header 表项，既是链表的开始也是链表的结尾。header 的后继表项是链表中的第一个元素，header 的前驱表项是链表中的最后一个元素。
ArrayList 的增删未必就是比 LinkedList 要慢：
如果增删都是在末尾来操作【每次调用的都是 remove() 和 add()】，此时 ArrayList 就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比 LinkedList 要快的。
如果删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上，ArrayList 的消耗主要是在移动和复制上（底层调用的是 arraycopy() 方法，是 native 方法）。LinkedList 的遍历速度是要慢于 ArrayList 的复制移动速度的如果数据量有百万级的时，还是 ArrayList 要快。
Java集合",
ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？,"RandomAccess 接口只是一个标志接口，只要 List 集合实现这个接口，就能支持快速随机访问。通过查看 Collections 类中的 binarySearch() 方法，可以看出，判断 List 是否实现 RandomAccess 接口来实行indexedBinarySerach(list, key) 或 iteratorBinarySerach(list, key)方法。再通过查看这两个方法的源码发现：实现 RandomAccess 接口的 List 集合采用一般的 for 循环遍历，而未实现这接口则采用迭代器，即 ArrayList 一般采用 for 循环遍历，而 LinkedList 一般采用迭代器遍历；
ArrayList 用 for 循环遍历比 iterator 迭代器遍历快，LinkedList 用 iterator 迭代器遍历比 for 循环遍历快。所以说，当我们在做项目时，应该考虑到 List 集合的不同子类采用不同的遍历方式，能够提高性能。
Java集合",
ArrayList 的扩容机制？,"推荐阅读：
https://juejin.im/post/5d42ab5e5188255d691bc8d6
Java集合",
Array 和 ArrayList 有何区别？什么时候更适合用 Array？,"什么时候更适合使用 Array：
Java集合",
HashMap 的实现原理/底层数据结构？JDK1.7 和 JDK1.8,"JDK1.7：Entry数组 + 链表
JDK1.8：Node 数组 + 链表/红黑树，当链表上的元素个数超过 8 个并且数组长度 >= 64 时自动转化成红黑树，节点变成树节点，以提高搜索效率和插入效率到 O(logN)。Entry 和 Node 都包含 key、value、hash、next 属性。
Java集合",
HashMap 的 put 方法的执行过程？,"当我们想往一个 HashMap 中添加一对 key-value 时，系统首先会计算 key 的 hash 值，然后根据 hash 值确认在 table 中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依次比较其 key 的 hash 值。如果两个 hash 值相等且 key 值相等(e.hash = = hash && ((k = e.key) = = key || key.equals(k)))，则用新的 Entry 的 value 覆盖原来节点的 value。如果两个 hash 值相等但 key 值不等 ，则进行插入操作。
不过呢，插入操作在 JDK1.7 和 JDK1.8 是有所不同的，JDK1.7 底层采用数组+链表，插入时采用头插法，JDK1.8，底层采用数组 + 链表 / 红黑树，并且把头插法改成了尾插法，主要是为了减少线程安全的问题，另外，当链表长度大于8，且数组长度大于64时，会把链表转化为红黑树处理，这个时候，就无关是头插还是尾插了，得按照红黑树的规则来插了。
Java集合",
HashMap 的 get 方法的执行过程？,"通过 key 的 hash 值找到在 table 数组中的索引处的 Entry，然后返回该 key 对应的 value 即可。
在这里能够根据 key 快速的取到 value 除了和 HashMap 的数据结构密不可分外，还和 Entry 有莫大的关系。HashMap 在存储过程中并没有将 key，value 分开来存储，而是当做一个整体 key-value 来处理的，这个整体就是Entry 对象。同时 value 也只相当于 key 的附属而已。在存储的过程中，系统根据 key 的 HashCode 来决定 Entry 在 table 数组中的存储位置，在取的过程中同样根据 key 的 HashCode 取出相对应的 Entry 对象（value 就包含在里面）。
Java集合",
HashMap 的 resize 方法的执行过程？,"有两种情况会调用 resize 方法：
扩容时会调用 resize，即 size > threshold 时，table 数组大小翻倍。
每次扩容之后容量都是翻倍。扩容后要将原数组中的所有元素找到在新数组中合适的位置。
当我们把 table[i] 位置的所有 Node 迁移到 newtab 中去的时候：这里面的 node 要么在 newtab 的 i 位置（不变），要么在 newtab 的 i + n 位置。也就是我们可以这样处理：把 table[i] 这个桶中的 node 拆分为两个链表 l1 和 l2：如果 hash & n = = 0，那么当前这个 node 被连接到 l1 链表；否则连接到 l2 链表。这样下来，当遍历完 table[i] 处的所有 node 的时候，我们得到两个链表 l1 和 l2，这时我们令 newtab[i] = l1，newtab[i + n] = l2，这就完成了 table[i] 位置所有 node 的迁移（rehash），这也是 HashMap 中容量一定的是 2 的整数次幂带来的方便之处。
Java集合",
HashMap 的 size 为什么必须是 2 的整数次方？,Java集合,
HashMap 的 get 方法能否判断某个元素是否在 map 中？,"HashMap 的 get 函数的返回值不能判断一个 key 是否包含在 map 中，因为 get 返回 null 有可能是不包含该 key，也有可能该 key 对应的 value 为 null。因为 HashMap 中允许 key 为 null，也允许 value 为 null。
Java集合",
HashMap 与 HashTable 的区别是什么？,"HashTable的补充：
HashTable 和 HashMap 的实现原理几乎一样，差别无非是
HashTable 不允许 key 和 value 为 null；
HashTable 是线程安全的。但是 HashTable 线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。
Java集合",
HashMap 与 ConcurrentHashMap 的区别是什么?,"HashMap 不是线程安全的，而 ConcurrentHashMap 是线程安全的。
ConcurrentHashMap 采用锁分段技术，将整个Hash桶进行了分段segment，也就是将这个大的数组分成了几个小的片段 segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁，这样做明显减小了锁的粒度。
Java集合",
HashTable 和 ConcurrentHashMap 的区别？,"HashTable 和 ConcurrentHashMap 相比，效率低。 Hashtable 之所以效率低主要是使用了 synchronized 关键字对 put 等操作进行加锁，而 synchronized 关键字加锁是对整张 Hash 表的，即每次锁住整张表让线程独占，致使效率低下，而 ConcurrentHashMap 在对象中保存了一个 Segment 数组，即将整个 Hash 表划分为多个分段；
而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行 put 操作时首先根据 hash 算法定位到元素属于哪个 Segment，然后对该 Segment 加锁即可，因此， ConcurrentHashMap 在多线程并发编程中可是实现多线程 put操作。
Java集合",
ConcurrentHashMap 的实现原理是什么？,"数据结构
JDK 7：中 ConcurrentHashMap 采用了数组 + Segment + 分段锁的方式实现。
JDK 8：中 ConcurrentHashMap 参考了 JDK 8 HashMap 的实现，采用了数组 + 链表 + 红黑树的实现方式来设计，内部大量采用 CAS 操作。
ConcurrentHashMap 采用了非常精妙的”分段锁”策略，ConcurrentHashMap 的主干是个 Segment 数组。
Segment 继承了 ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在 ConcurrentHashMap，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，并发环境下，对于不同 Segment 的数据进行操作是不用考虑锁竞争的。就按默认的 ConcurrentLevel 为 16 来讲，理论上就允许 16 个线程并发执行。
所以，对于同一个 Segment 的操作才需考虑线程同步，不同的 Segment 则无需考虑。Segment 类似于 HashMap，一个 Segment 维护着一个HashEntry 数组：
HashEntry 是目前我们提到的最小的逻辑处理单元了。一个 ConcurrentHashMap 维护一个 Segment 数组，一个 Segment 维护一个 HashEntry 数组。因此，ConcurrentHashMap 定位一个元素的过程需要进行两次 Hash 操作。第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。
Java集合",
HashSet 的实现原理？,"HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复。因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。
Java集合",
HashSet 怎么保证元素不重复的？,"元素值作为的是 map 的 key，map 的 value 则是 PRESENT 变量，这个变量只作为放入 map 时的一个占位符而存在，所以没什么实际用处。其实，这时候答案已经出来了：HashMap 的 key 是不能重复的，而这里HashSet 的元素又是作为了 map 的 key，当然也不能重复了。
Java集合",
LinkedHashMap 的实现原理?,"LinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header，这个 header 不是放在 Table 里，它是额外独立出来的。LinkedHashMap 通过继承 hashMap 中的 Entry，并添加两个属性 Entry before，after 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。
LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。
Java集合",
Iterator 怎么使用？有什么特点？,"迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。Java 中的 Iterator 功能比较简单，并且只能单向移动：　　
Java集合",
Iterator 和 ListIterator 有什么区别？,"Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。
Java集合",
Iterator 和 Enumeration 接口的区别？,"与 Enumeration 相比，Iterator 更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。否则会抛出 ConcurrentModificationException 异常。这其实就是 fail-fast 机制。具体区别有三点：
Java集合",
fail-fast 与 fail-safe 有什么区别？,"Iterator 的 fail-fast 属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util 包中的所有集合类都被设计为 fail-fast 的，而 java.util.concurrent 中的集合类都为 fail-safe 的。当检测到正在遍历的集合的结构被改变时，fail-fast 迭代器抛出ConcurrentModificationException，而 fail-safe 迭代器从不抛出 ConcurrentModificationException。
Java集合",
Collection 和 Collections 有什么区别？,"Collection：是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素。它的直接继承接口有 List，Set 和 Queue。
Collections：是不属于 Java 的集合框架的，它是集合类的一个工具类/帮助类。此类不能被实例化， 服务于 Java 的 Collection 框架。它包含有关集合操作的静态多态方法，实现对各种集合的搜索、排序、线程安全等操作。
Java集合",
Java集合,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里： Java集合面试题阅读指南
 Java集合面试题阅读指南
Java集合",
Java集合面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. Java 中常用的容器有哪些？
1. Java 中常用的容器有哪些？
2. ArrayList 和 LinkedList 的区别？
2. ArrayList 和 LinkedList 的区别？
3. ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？
3. ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？
4. ArrayList 的扩容机制？
4. ArrayList 的扩容机制？
5. Array 和 ArrayList 有何区别？什么时候更适合用 Array？
5. Array 和 ArrayList 有何区别？什么时候更适合用 Array？
6. HashMap 的实现原理/底层数据结构？JDK1.7 和 JDK1.8
6. HashMap 的实现原理/底层数据结构？JDK1.7 和 JDK1.8
7. HashMap 的 put 方法的执行过程？
7. HashMap 的 put 方法的执行过程？
8. HashMap 的 get 方法的执行过程？
8. HashMap 的 get 方法的执行过程？
9. HashMap 的 resize 方法的执行过程？
9. HashMap 的 resize 方法的执行过程？
10. HashMap 的 size 为什么必须是 2 的整数次方？
10. HashMap 的 size 为什么必须是 2 的整数次方？
11. HashMap 多线程死循环问题？
11. HashMap 多线程死循环问题？
12. HashMap 的 get 方法能否判断某个元素是否在 map 中？
12. HashMap 的 get 方法能否判断某个元素是否在 map 中？
13. HashMap 与 HashTable 的区别是什么？
13. HashMap 与 HashTable 的区别是什么？
14. HashMap 与 ConcurrentHashMap 的区别是什么?
14. HashMap 与 ConcurrentHashMap 的区别是什么?
15. HashTable 和 ConcurrentHashMap 的区别？
15. HashTable 和 ConcurrentHashMap 的区别？
16. ConcurrentHashMap 的实现原理是什么？
16. ConcurrentHashMap 的实现原理是什么？
17. HashSet 的实现原理？
17. HashSet 的实现原理？
18. HashSet 怎么保证元素不重复的？
18. HashSet 怎么保证元素不重复的？
19. LinkedHashMap 的实现原理?
19. LinkedHashMap 的实现原理?
20. Iterator 怎么使用？有什么特点？
20. Iterator 怎么使用？有什么特点？
21. Iterator 和 ListIterator 有什么区别？
21. Iterator 和 ListIterator 有什么区别？
22. Iterator 和 Enumeration 接口的区别？
22. Iterator 和 Enumeration 接口的区别？
23. fail-fast 与 fail-safe 有什么区别？
23. fail-fast 与 fail-safe 有什么区别？
24. Collection 和 Collections 有什么区别？
24. Collection 和 Collections 有什么区别？
 Java面试题分类阅读指南（必看）
 Java面试题分类阅读指南（必看）
 操作系统面试题阅读指南（必看）
 操作系统面试题阅读指南（必看）
阅读指南（必看）
阅读指南（必看）
MySQL面试题阅读指南（必看）
MySQL面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
 Redis面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
消息队列和Zookeeper面试题阅读指南（必看）
持续更新～持续更新～持续更新～
记得收藏呀
Java集合",
JDK1.8之后，HashMap头插法改为尾插法？,"1.头插法在并发下有致命问题，就是可能形成数据环，get 数据时死循环，而在 1.8 之前因为处理 hash 冲突的方式是用链表存放数据，使用头插法可以提升一定效率。
但是在 1.8 之后这个效率提升就可有可无了，链表长度超过 7 就要考虑升级红黑树了，所以哪怕进行尾插遍历次数也会很有限，效率影响不大。
2.就是因为 1.8 之后数据结构的变动，当链表长度达到阈值，升级为红黑树后头插法就不适用了，因为构建红黑树需要进行比对更新序列，也就不能去说是头插法还是尾插了
Java集合",
