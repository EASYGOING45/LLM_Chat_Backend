问题,回答,所属分类
解释下什么是面向对象？面向对象和面向过程的区别？,"面向对象是一种基于面向过程的编程思想，是向现实世界模型的自然延伸，这是一种“万物皆对象”的编程思想。由执行者变为指挥者，在现实生活中的任何物体都可以归为一类事物，而每一个个体都是一类事物的实例。面向对象的编程是以对象为中心，以消息为驱动。
区别:
（1）编程思路不同：面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。
（2）封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。
（3）面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势很明显
Java基础
Java面试题",
面向对象的三大特性？分别解释下？,"（1）封装：通常认为封装是把数据和操作数据的方法封装起来，对数据的访问只能通过已定义的接口。
（2）继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类/基类），得到继承信息的被称为子类（派生类）。
（3）多态：分为编译时多态（方法重载）和运行时多态（方法重写）。要实现多态需要做两件事：一是子类继承父类并重写父类中的方法，二是用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为。
几点补充
1）子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。因为在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象；
（2）子类可以拥有自己属性和方法；
（3）子类可以用自己的方式实现父类的方法。（重写）
Java基础
Java面试题",
JDK、JRE、JVM 三者之间的关系？,"JDK（Java Development Kit）：是 Java 开发工具包，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。
JRE（ Java Runtime Environment）：是 Java 的运行环境，包含 JVM 标准实现及 Java 核心类库。
JVM（Java Virtual Machine）：是 Java 虚拟机，是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。所有的 Java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行。
Java基础
Java面试题",
重载和重写的区别？,"（1）重载：编译时多态、同一个类中同名的方法具有不同的参数列表、不能根据返回类型进行区分【因为：函数调用时不能指定类型信息，编译器不知道你要调哪个函数】；
（2）重写（又名覆盖）：运行时多态、子类与父类之间、子类重写父类的方法具有相同的返回类型、更好的访问权限。
Java基础
Java面试题",
Java 中是否可以重写一个 private 或者 static 方法？,"Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。
Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用， 如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。

  静态方法补充：静态的方法可以被继承，但是不能重写。如果父类和子类中存在同样名称和参数的静态方法，那么该子类的方法会把原来继承过来的父类的方法隐藏，而不是重写。通俗的讲就是父类的方法和子类的方法是两个没有关系的方法，具体调用哪一个方法是看是哪个对象的引用；这种父子类方法也不在存在多态的性质。

Java基础
Java面试题",
构造方法有哪些特性？,"（1）名字与类名相同；
（2）没有返回值，但不能用 void 声明构造函数；
（3）成类的对象时自动执行，无需调用。
Java基础
Java面试题",
在 Java 中定义一个不做事且没有参数的构造方法有什么作用？,"Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。
因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是：在父类里加上一个不做事且没有参数的构造方法。
Java基础
Java面试题",
Java 中创建对象的几种方式？,"1、使用 new 关键字；
2、使用 Class 类的 newInstance 方法，该方法调用无参的构造器创建对象（反射）：Class.forName.newInstance()；
3、使用 clone() 方法；
4、反序列化，比如调用 ObjectInputStream 类的 readObject() 方法。
Java基础
Java面试题",
抽象类和接口有什么区别？,"1）抽象类中可以定义构造函数，接口不能定义构造函数；
（2）抽象类中可以有抽象方法和具体方法，而接口中只能有抽象方法（public abstract）；
（3）抽象类中的成员权限可以是 public、默认、protected（抽象类中抽象方法就是为了重写，所以不能被 private 修饰），而接口中的成员只可以是 public（方法默认：public abstrat、成员变量默认：public static final）；
（4）抽象类中可以包含静态方法，而接口中不可以包含静态方法；
JDK 8 中的改变：
1、在 JDK1.8中，允许在接口中包含带有具体实现的方法，使用 default 修饰，这类方法就是默认方法。
2、抽象类中可以包含静态方法，在 JDK1.8 之前接口中不能包含静态方法，JDK1.8 以后可以包含。之前不能包含是因为，接口不可以实现方法，只可以定义方法，所以不能使用静态方法（因为静态方法必须实现）。现在可以包含了，只能直接用接口调用静态方法。JDK1.8 仍然不可以包含静态代码块。
Java基础
Java面试题",
静态变量和实例变量的区别？,"静态变量：是被 static 修饰的变量，也称为类变量，它属于类，因此不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；静态变量可以实现让多个对象共享内存。
实例变量：属于某一实例，需要先创建对象，然后通过对象才能访问到它。
Java基础
Java面试题",
12、short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？,"对于 short s1 = 1; s1 = s1 + 1; 来说，在 s1 + 1 运算时会自动提升表达式的类型为 int ，那么将 int 型值赋值给 short 型变量，s1 会出现类型转换错误。
对于 short s1 = 1; s1 += 1; 来说，+= 是 Java 语言规定的运算符，Java 编译器会对它进行特殊处理，因此可以正确编译。
Java基础
Java面试题",
Integer 和 int 的区别？,"（1）int 是 Java 的八种基本数据类型之一，而 Integer 是 Java 为 int 类型提供的封装类；
（2）int 型变量的默认值是 0，Integer 变量的默认值是 null，这一点说明 Integer 可以区分出未赋值和值为 0 的区分；
（3）Integer 变量必须实例化后才可以使用，而 int 不需要。
Integer 和 int 的比较延伸：
1、由于 Integer 变量实际上是对一个 Integer 对象的引用，所以两个通过 new 生成的 Integer 变量永远是不相等的，因为其内存地址是不同的；
2、Integer 变量和 int 变量比较时，只要两个变量的值是相等的，则结果为 true。因为包装类 Integer 和基本数据类型 int 类型进行比较时，Java 会自动拆包装类为 int，然后进行比较，实际上就是两个 int 型变量在进行比较；
3、非 new 生成的 Integer 变量和 new Integer() 生成的变量进行比较时，结果为 false。因为非 new 生成的 Integer 变量指向的是 Java 常量池中的对象，而 new Integer() 生成的变量指向堆中新建的对象，两者在内存中的地址不同；
4、对于两个非 new 生成的 Integer 对象进行比较时，如果两个变量的值在区间 [-128, 127] 之间，则比较结果为 true，否则为 false。Java 在编译 Integer i = 100 时，会编译成 Integer i = Integer.valueOf(100)，而 Integer 类型的 valueOf 的源码如下所示：
从上面的代码中可以看出：Java 对于 [-128, 127] 之间的数会进行缓存，比如：Integer i = 127，会将 127 进行缓存，下次再写 Integer j = 127 的时候，就会直接从缓存中取出，而对于这个区间之外的数就需要 new 了。
Boolean：全部缓存
Byte：全部缓存（Byte 的数值范围是 -128～127）
Character：<= 127 缓存
Short：-128 — 127 缓存
Long：-128 — 127 缓存
Integer：-128 — 127 缓存
Float：没有缓存
Doulbe：没有缓存
Java基础
Java面试题",
装箱和拆箱的区别,"自动装箱是 Java 编译器在基本数据类型和对应得包装类之间做的一个转化。比如：把 int 转化成 Integer，double 转化成 Double 等等。反之就是自动拆箱。
原始类型：boolean、char、byte、short、int、long、float、double
封装类型：Boolean、Character、Byte、Short、Integer、Long、Float、Double
Java基础
Java面试题",
switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？,"在 switch(expr 1) 中，expr1 只能是一个整数表达式或者枚举常量。而整数表达式可以是 int 基本数据类型或者 Integer 包装类型。由于，byte、short、char 都可以隐式转换为 int，所以，这些类型以及这些类型的包装类型也都是可以的。而 long 和 String 类型都不符合 switch 的语法规定，并且不能被隐式的转换为 int 类型，所以，它们不能作用于 switch 语句中。不过，需要注意的是在 JDK1.7 版本之后 switch 就可以作用在 String 上了。
Java基础
Java面试题",
16、final、finally、finalize 的区别,"final：用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、被其修饰的类不可继承；
finally：异常处理语句结构的一部分，表示总是执行；
finallize：Object类的一个方法，在垃圾回收时会调用被回收对象的finalize
Java基础
Java面试题",
== 和 equals 的区别？,"= =：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。
equals 方法：用来比较两个对象的内容是否相等。注意：equals 方法不能用于比较基本数据类型的变量。如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址（很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等）。
Java基础
Java面试题",
两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？,"两个对象的 hashCode() 相同，equals() 不一定为 true。因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等【散列冲突】。
Java基础
Java面试题",
为什么重写 equals() 就一定要重写 hashCode() 方法？,"这个问题应该是有个前提，就是你需要用到 HashMap、HashSet 等 Java 集合，用不到哈希表的话，其实仅仅重写 equals() 方法也可以。而工作中的场景是常常用到 Java 集合，所以 Java 官方建议重写 equals() 就一定要重写 hashCode() 方法。
对于对象集合的判重，如果一个集合含有 10000 个对象实例，仅仅使用 equals() 方法的话，那么对于一个对象判重就需要比较 10000 次，随着集合规模的增大，时间开销是很大的。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的 hashCode 不相同，也不再需要调用 equals() 方法，从而大大减少了 equals() 比较次数。
所以从程序实现原理上来讲的话，既需要 equals() 方法，也需要 hashCode() 方法。那么既然重写了 equals()，那么也要重写 hashCode() 方法，以保证两者之间的配合关系。
hashCode（）与equals（）的相关规定：
1、如果两个对象相等，则 hashCode 一定也是相同的；
2、两个对象相等，对两个对象分别调用 equals 方法都返回 true；
3、两个对象有相同的 hashCode 值，它们也不一定是相等的；
4、因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖；
5、hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。
Java基础
Java面试题",
& 和 && 的区别？,"Java 中 && 和 & 都是表示与的逻辑运算符，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算结果才为 true，否则为 false。
&&：有短路功能，当第一个表达式的值为 false 的时候，则不再计算第二个表达式；
&：不管第一个表达式结果是否为 true，第二个都会执行。除此之外，& 还可以用作位运算符：当 & 两边的表达式不是 Boolean 类型的时候，& 表示按位操作。
Java基础
Java面试题",
Java 中的参数传递时传值呢？还是传引用？,"Java 的参数是以值传递的形式传入方法中，而不是引用传递。
当传递方法参数类型为基本数据类型（数字以及布尔值）时，一个方法是不可能修改一个基本数据类型的参数。
当传递方法参数类型为引用数据类型时，一个方法将修改一个引用数据类型的参数所指向对象的值。即使 Java 函数在传递引用数据类型时，也只是拷贝了引用的值罢了，之所以能修改引用数据是因为它们同时指向了一个对象，但这仍然是按值调用而不是引用调用。
Java基础
Java面试题",
Java 中的 Math.round(-1.5) 等于多少？,"等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。
两个二进制数异或结果是这两个二进制数差的绝对值。表达式如下：a^b = |a-b|。
两个二进制 a 与 b 异或，即 a 和 b 两个数按位进行运算。如果对应的位相同，则为 0（相当于对应的算术相减），如果不同即为 1（相当于对应的算术相加）。由于二进制每个位只有两种状态，要么是 0，要么是 1，则按位异或操作可表达为按位相减取值相对值，再按位累加。
Java基础
Java面试题",
如何实现对象的克隆？,"（1）实现 Cloneable 接口并重写 Object 类中的 clone() 方法；
（2）实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。
Java基础
Java面试题",
深克隆和浅克隆的区别？,"（1）浅克隆：拷贝对象和原始对象的引用类型引用同一个对象。浅克隆只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅克隆。
（2）深克隆：拷贝对象和原始对象的引用类型引用不同对象。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse() 和 JSON.stringify()，但是此方法无法复制函数类型）。
补充：
深克隆的实现就是在引用类型所在的类实现 Cloneable 接口，并使用 public 访问修饰符重写 clone 方法。
Java 中定义的 clone 没有深浅之分，都是统一的调用 Object 的 clone 方法。为什么会有深克隆的概念？是由于我们在实现的过程中刻意的嵌套了 clone 方法的调用。也就是说深克隆就是在需要克隆的对象类型的类中重新实现克隆方法 clone()。
Java基础
Java面试题",
什么是 Java 的序列化，如何实现 Java 的序列化？,"对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序。从字节流创建对象的相反的过程称为反序列化。而创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化。序列化是为了解决在对象流进行读写操作时所引发的问题。
序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，只是用于标注该对象是可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个 ObjectOutputStream 对象，接着使用 ObjectOutputStream 对象的 writeObject(Object obj) 方法可以将参数为 obj 的对象写出，要恢复的话则使用输入流。
Java基础
Java面试题",
什么情况下需要序列化？,"（1）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；
（2）当你想用套接字在网络上传送对象的时候；
（3）当你想通过 RMI 传输对象的时候。
Java基础
Java面试题",
Java基础,"为了方便维护，校对错误等，目前改为只提供一种阅读方式，看这里： Java基础面试题阅读指南
 Java基础面试题阅读指南
Java基础",
Java基础面试题阅读指南,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. 解释下什么是面向对象？面向对象和面向过程的区别？
1. 解释下什么是面向对象？面向对象和面向过程的区别？
2. 面向对象的三大特性？分别解释下？
2. 面向对象的三大特性？分别解释下？
3. JDK、JRE、JVM 三者之间的关系？
3. JDK、JRE、JVM 三者之间的关系？
4. 重载和重写的区别？
4. 重载和重写的区别？
5. Java 中是否可以重写一个 private 或者 static 方法？
5. Java 中是否可以重写一个 private 或者 static 方法？
6. 构造方法有哪些特性？
6. 构造方法有哪些特性？
7. 在 Java 中定义一个不做事且没有参数的构造方法有什么作用？
7. 在 Java 中定义一个不做事且没有参数的构造方法有什么作用？
8. Java 中创建对象的几种方式？
8. Java 中创建对象的几种方式？
9. 抽象类和接口有什么区别？
9. 抽象类和接口有什么区别？
10. 静态变量和实例变量的区别？
10. 静态变量和实例变量的区别？
11. 12、short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？
11. 12、short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？
12. Integer 和 int 的区别？
12. Integer 和 int 的区别？
13. 装箱和拆箱的区别
13. 装箱和拆箱的区别
14. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？
14. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？
15. 16、final、finally、finalize 的区别
15. 16、final、finally、finalize 的区别
16.  和 equals 的区别？
16.  和 equals 的区别？
17. 两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？
17. 两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？
18. 为什么重写 equals() 就一定要重写 hashCode() 方法？
18. 为什么重写 equals() 就一定要重写 hashCode() 方法？
19. & 和 && 的区别？
19. & 和 && 的区别？
20. Java 中的参数传递时传值呢？还是传引用？
20. Java 中的参数传递时传值呢？还是传引用？
21. Java 中的 Math.round(-1.5) 等于多少？
21. Java 中的 Math.round(-1.5) 等于多少？
22. 如何实现对象的克隆？
22. 如何实现对象的克隆？
23. 深克隆和浅克隆的区别？
23. 深克隆和浅克隆的区别？
24. 什么是 Java 的序列化，如何实现 Java 的序列化？
24. 什么是 Java 的序列化，如何实现 Java 的序列化？
25. 什么情况下需要序列化？
25. 什么情况下需要序列化？
26. Java 的泛型是如何工作的 ? 什么是类型擦除 ?
26. Java 的泛型是如何工作的 ? 什么是类型擦除 ?
27. 什么是泛型中的限定通配符和非限定通配符 ?
27. 什么是泛型中的限定通配符和非限定通配符 ?
28. List< ? extends T > 和 List < ? super T > 之间有什么区别 ?
28. List< ? extends T > 和 List < ? super T > 之间有什么区别 ?
29. Java 中的反射是什么意思？有哪些应用场景？
29. Java 中的反射是什么意思？有哪些应用场景？
30. 反射的优缺点？
30. 反射的优缺点？
31. Java 中的动态代理是什么？有哪些应用？
31. Java 中的动态代理是什么？有哪些应用？
32. 怎么实现动态代理？
32. 怎么实现动态代理？
33. static 关键字的作用？
33. static 关键字的作用？
34. super 关键字的作用？
34. super 关键字的作用？
35. finally 块中的代码什么时候被执行？
35. finally 块中的代码什么时候被执行？
36. finally 是不是一定会被执行到？
36. finally 是不是一定会被执行到？
37. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
37. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
38. try-catch-finally 中那个部分可以省略？
38. try-catch-finally 中那个部分可以省略？
39. Error 和 Exception 的区别？
39. Error 和 Exception 的区别？
40. 运行时异常与受检异常有何异同？
40. 运行时异常与受检异常有何异同？
41. throw 和 throws 的区别？
41. throw 和 throws 的区别？
42. 常见的异常类有哪些？
42. 常见的异常类有哪些？
43. 主线程可以捕获到子线程的异常吗？
43. 主线程可以捕获到子线程的异常吗？
44. 字节和字符的区别？
44. 字节和字符的区别？
45. String 为什么要设计为不可变类？
45. String 为什么要设计为不可变类？
46. String、StringBuilder、StringBuffer 的区别？
46. String、StringBuilder、StringBuffer 的区别？
47. String 字符串修改实现的原理？
47. String 字符串修改实现的原理？
48. String str = “i” 与 String str = new String(“i”) 一样吗？
48. String str = “i” 与 String str = new String(“i”) 一样吗？
49. String 类的常用方法都有那些？
49. String 类的常用方法都有那些？
50. final 修饰 StringBuffer 后还可以 append 吗？
50. final 修饰 StringBuffer 后还可以 append 吗？
51. Java 中的 IO 流的分类？说出几个你熟悉的实现类？
51. Java 中的 IO 流的分类？说出几个你熟悉的实现类？
52. 字节流和字符流有什么区别？
52. 字节流和字符流有什么区别？
53. BIO、NIO、AIO 有什么区别？
53. BIO、NIO、AIO 有什么区别？
Java基础",
20万字Java开发面试手册出炉,"对于编程学习，很多人可能学了之后，不知道自己处于哪个阶段，也不到究竟要学到哪个程度，帅地觉得，验证自己学得如何最好的面试，就是尝试去面试，而面试无非就是问你一些面试题，所以呢，帅地整理了一整套 Java 后端面试题。
当然，不仅仅包含 Java 技术栈，还有计算机网络，操作系统，MySQL 等等，并且附带了详细的答案，无论是想面试还是想看看自己学得如何，都值得一看。
这里提供两种阅读方式：PDF 阅读 和在线阅读
给大家看一下目录

总共 20 万的字数，微信搜索关注「帅地玩编程」，回复「010」，即可获取最新版的 PDF 哦，扫码直达

另外，也提供了在线阅读的模式，也就是在帅地的个人网站阅读

直达链接：https://www.iamshuaidi.com
https://www.iamshuaidi.com
Java基础
Java字符串
Java异常
Java集合
SpringMVC面试题",
