问题,回答,所属分类
如何判断一个数是否在40亿个整数中？,"题目：我有40亿个整数，再给一个新的整数，我需要判断新的整数是否在40亿个整数中，你会怎么做？











【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。


小史忙拉着吕老师问，为什么我说分8次加载数据，面试官会说太慢了呢？
吕老师：哈哈，从磁盘加载数据是磁盘io操作，是非常慢的，你每次都要加载这么大的数据，还要8次，我估计你找一个数的时间可以达到分钟甚至小时级了。

小史：那如果是你，你会怎么办呢？
吕老师：其实面试官已经提示得比较明显了，他说给你一批机器，就是暗示你可以用分布式算法。你把数据分散在8台机器上，然后来一个新的数据，8台机器一起找，最后再汇总结果就行了。

小史：这样的话能快多少？
吕老师：这样应该能达到秒级。小史，你可以自己分析分析。
小史：我想想……哦，这样做的话，因为每台机器都可以一次性把数据读入内存，在比较的时候不用来回加载数据了，所以可以节省加载数据的开销！这真是个好办法。
【更好方案】
吕老师：其实这并不是最好方法，我这还有一种毫秒级的方法，想不想知道啊？
小史：当然想啊，快教教我。

小史：哦，对哦，这样我就申请40亿个位就好了，新的数转换成一个位，然后判断一下这个位是0还是1就行了。
吕老师：小史啊，考虑问题要考虑清楚啊，如果是40亿个位，那么这40亿个位哪些是0，哪些是1呢？来了一个新的数，怎么判断是否在40亿个位之中？

小史：我想想，对啊，40亿个位，40亿个数，那么每个位都是1，这。。。
吕老师：其实你可以想想，32位int的范围，总共就是2的32次方，大概42亿多点。所以你可以申请2的32次方个位。
小史：意思是我把整个整数范围都覆盖了，哦，对哦。这样一来，就可以做了，1代表第一个位，2代表第二个位，2的32次方代表最后一个位。40亿个数中，存在的数就在相应的位置1，其他位就是0。

吕老师：没错，那来了一个新的数呢？
小史：新的数就去找相应的位，比如来了一个1234，就找一下第1234位，如果是1就存在，是0就不存在啦。
吕老师：没错，那么这样的话，需要多大内存呢？
小史：我想想啊，2的32次方个位，相当于2的29次方个字节，哇，才500MB，真是节省了不少内存呢。

小史：这么厉害的算法，你是怎么想到的？

吕老师：其实这是一种非常有名的大数据算法，叫位图法，英文名叫bitmap。顾名思义，就是用位来表示状态，从而节省空间。明天正好我有一节课，就讲位图法，你可以来听一听。
【吕老师的课】
第二天，吕老师开始上课，他一开始就抛出了小史遇到的面试题。
吕老师：同学们，这道题是BAT公司的一道面试题，大家有什么思路吗？
话音刚落，蛋哥就站起来回答。蛋哥是吕老师最得意的门生，以思维活跃著称。

蛋哥：我觉得可以这样。首先，32位int的范围是42亿，40亿整数中肯定有一些是连续的，我们可以先对数据进行一个外部排序，然后用一个初始的数和一个长度构成一个数据结构，来表示一段连续的数，举个例子。
如果数据是1 2 3 4 6 7……这种的，那么可以用(1,4)和(6,2)来表示，这样一来，连续的数都变成了2个数表示。
来了一个新数之后，就用二分法进行查找了。
这样一来，最差情况就是2亿多的断点，也就是2亿多的结构体，每个结构体8个字节，大概16亿字节，1.6GB，在内存中可以放下。

吕老师：嗯，非常好，不仅给出了方案，还能主动分析空间和可行性。
小史听完后深感佩服，问题的解决方法绝对不止一种，只要肯动脑筋，即使没有学过bitmap算法，也能有别的方法来解决问题。
【课后】
下课后，小史又找到吕老师。


吕老师：但是你的理解能力还是很强的，很多东西一听就懂，这可不是谁都能做到的。
算法面试
面试现场",
如何实现可以获取最小值的栈？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT。

今天他又去BAT中的一家面试了。
简单的自我介绍后，面试官给了小史一个问题。

题目：我现在需要实现一个栈，这个栈除了可以进行普通的push、pop操作以外，还可以进行getMin的操作，getMin方法被调用后，会返回当前栈的最小值，你会怎么做呢？你可以假设栈里面存的都是int整数。


























【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。





【异常情况处理】

吕老师：面试官已经提出了你的异常处理有点问题，当栈内为空的时候，你返回-1，但是如果用户push过-1，那么你返回-1的时候，是用户push进来的值，还是栈为空，就不得而知了。



小史咬咬牙：那就再定义一个类，里面包括一个int的data和一个boolean的isSuccess，正常情况下isSuccess是true，栈为空的话，isSuccess是false。这样就能区分开了吧？


小史突然一拍大腿：对哦，我可以用一个包装类Integer来定义返回值，如果是空，就代表栈为空就行了。它和int的区别就是它多了一个null，正好用来返回异常情况。

吕老师：嗯，越来越好，但是还是有点问题。你并没有站在使用者的角度考虑问题。使用你这个栈的人，在pop的时候，他并不知道可能返回null，如果他不做判断，后面的代码就可能抛出空指针了。




吕老师发来一个表情。




吕老师：没错，最关键的是，你显式抛出异常，如果使用者不捕获，那么编译就会报错，这样就把错误暴露在编译阶段，并且不需要和任何人商量所谓的特殊返回值了。


【算法优化】


吕老师一眼看穿了小史的心思。





小史想了想：明白了，我可以在push的时候判断一下，如果比最小值还大，就不加入辅助栈。pop的时候，如果不是最小值，辅助栈就不出栈。这样一来，辅助栈就不会有大量重复元素了。

小史：push的时候进行判断，如果数值比当前最小值大，就不动mins栈了，这样mins栈中不会保存大量冗余的最小值。pop的时候同样进行判断，只有pop出的数就是当前最小值的时候，才让mins出栈。



小史：如果push一个和最小值相等的元素，还是要入mins栈。不然当这个最小值pop出去的时候。data中还会有一个最小值元素，而mins中却已经没有最小值元素了。





小史：mins栈中改存最小值在data数组中的索引。这样一来，当push了与最小值相同元素的时候，就不需要动mins栈了。而pop的时候，pop出的元素的索引如果不是mins栈顶元素，mins也不出栈。同时，获取最小值的时候，需要拿到mins栈顶元素作为索引，再去data数组中找到相应的数作为最小值。


理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：


【小史的疑惑】
吃饭的时候，小史提出了心中埋藏已久的疑惑。


吕老师：数据结构和算法的设计是一个程序员的内功，工作时虽然用不到这么细，但是你在学习其他知识的底层原理的时候，到处都是数据结构和算法。



  如果喜欢本网站{https://www.iamshuaidi.com), 那么可以把该网站分享给其他人，这可以激励加速更新哦，也欢迎来留言催更，关注公众号「程序员内功修炼」，回复「读者」即可加入高质量读者群

算法面试
面试现场",
为什么要分稳定排序和非稳定排序？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他去了一家互联网小巨头公司面试了。
没想到面试并不像想象中的顺利。
【遇见吕老师】



【面试现场】







小史：原始数据，a2和a4的位置都是3。对于稳定排序来说，排序后的序列，a2一定还是在a4前面。但是对于非稳定排序来说，就不一定了，可能排完序之后，a4反而在a2的前面了。



题目：既然最后都是有序序列，为什么还要分稳定和非稳定的排序呢？

半分钟过去了。




【请教大神】



吕老师：笔试主要问是什么，而面试主要问为什么。


【吕老师的课】
吕老师一上课就把问题抛了出来。

话音刚落，蛋哥就站了起来。

蛋哥：咱们每次考试完成后，都会按照分数进行排序。分高的自然就是第一名。分数相同的同学怎么办呢？那就是按照上次的分数来分高低。上次分高的排在前面。

蛋哥：这个时候就应该用稳定排序，在上次排好序的序列上，再针对这次的分数进行排序。稳定排序的结果能保证这次相同分数的人，上次分高的在前面。

蛋哥：再比如我们班的同学，已经按照学号排好序了。现在要按照身高排序。如果是稳定排序排好之后，身高相同的同学，还是按照学号顺序的。

吕老师：没错，其实就是有两个排序关键字的时候，稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数。
小史听完后，觉得很惭愧，其实这些场景自己也遇到过，早该想到的。
【课后】
课后小史又找到吕老师。


吕老师：你看的东西很多，是你学到了很多知识。但是这些知识之间的关联，需要你进行深入思考才能得到的。找到知识之间的联系，找到知识和实际场景之间的联系，多想想为什么，才能做到融会贯通。
算法面试
面试现场",
如何找到字符串中的最长回文子串？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他又去一家互联网小巨头公司面试了。
【面试现场】







小史：只要先对比第一个字符和倒数第一个字符，再对比第二个字符和倒数第二个字符，以此类推。如果都相等，那就是回文串了。

题目：给你一个字符串，找出里面最长的回文子串。
例如
输入abcdcef，那么输出应该是cdc
输入adaelele，输出应该是elele





半分钟过去了。



小史：可以遍历整个字符串，把每个字符和字符间的空隙当作回文的中心，然后向两边扩展来找到最长回文串。
小史这次抢着分析时间和空间复杂度。



一分钟过去了。




【请教大神】
小史回到学校，把面试情况和吕老师说了一下。


吕老师：比如cabadabae用中心扩展的算法，我已经知道了第三位为中心的aba和第5位为中心的abadaba是回文，那么在判断第7位为中心的回文串的时候，有什么已知信息吗？


小史：已知第5位为中心的abadaba是回文，由回文的特性，就能够知道2-4位和6-8位对称，而又知道第3位为中心的aba是回文，所以2-4位是回文。这样的话，6-8位肯定是回文。





小史拿着笔在纸上画了半天，突然大叫一声。

小史：由于之前的计算已经知道了第5位为中心的abadaba是回文，而第4位为中心的a的回文长度是1，所以第6位为中心的回文长度只能是1，不用再去扩展判断了。





小史：以第7位为中心的回文串的计算，由之前分析已经知道最小长度是3了，但是还是需要进行扩展，因为第9位是什么根据之前的信息无法得知，需要扩展进行探索。


小史：而以第6位为中心的回文串的计算，并不需要进行探索了，因为根据之前第5位为回文中心串的信息和第4位为回文中心串的信息已经可以推断第6位为回文中心串的长度只能为1。










小史：当然可以。
1、首先，我们要记录下目前已知的回文串能够覆盖到的最右边的地方，就像案例中的第8位
2、同时，覆盖到最右边的回文串所对应的回文中心也要记录，就像案例中的第5位
3、以每一位为中心的回文串的长度也要记录，后面进行推断的时候能用到，就像案例中用到的以第3位为中心的回文和第4位为中心的回文
4、对于新的中心，我们判断它是否在右边界内，若在，就计算它相对右边界回文中心的对称位置，从而得到一些信息，同时，如果该中心需要进行扩展，则继续扩展就行。
【编码实现】


小史：回文的中心有可能是两个字符中间，这种情况没有考虑到啊。





小史：
1、先对字符串进行预处理，两个字符之间加上特殊符号#
2、然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整）
3、每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度
4、判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界
5、最后得到最长回文之后，去掉其中的特殊符号即可


理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
PlalindromeString.java
Main.java
运行结果：

【时间空间分析】










算法面试
面试现场",
如何在500w个单词中统计特定前缀的单词有多少个?,"如何在500w个单词中统计特定前缀的单词有多少个？

今天小史去了一家在线英语培训公司面试了。
简单的自我介绍后，面试官给了小史一个问题。

题目：我有500w个单词，你帮忙设计一个数据结构来进行存储，存好之后，我有两个需求。
1、来了一个新的单词，需要判断是否在这500w个单词中
2、来了一个单词前缀，给出500w个单词中有多少个单词是该前缀
小史这次没有不假思索就给出回答，他学会了深沉。


小史回忆起吕老师之前教他的 bitmap 算法。

小史心想：bitmap可以判断一个数是否在40亿个int32数中，其核心是每一个数映射成一个位，同时申请的bit位数覆盖了整个int32的值域。
小史在纸上算了半天，终于开口了。



小史：好的，我用bitmap来做第一问。我把每一个字符串映射成一个位。比如，a是第1位，b是第2位，z是第26位，aa是第27位，ab是第28位，以此类推。英文一共26个字母，我算了一下，6个字符长度的单词总共有26的6次方个，需要占26的6次方个位，大概300M









小史：建立数据结构的时候，排序需要花掉nlg(n)，排序时字符串比较花掉m，时间一共mnlg(n)。查找的话用二分，就是mlg(n)了。空间是mn。


一分钟过去了。




【请教大神】
回到学校，小史把面试情况和吕老师说了一下。

s

吕老师：你想想，a到z这26个字母中，可能只有a和i两个是单词，其他都不是，所以你的bitmap大量空间都被浪费了。这种情况你搞个hashset没准还更省一点。



【树形结构解难题】







小史：哦，这确实是节省了空间，如果要找单词interest，那么就找根节点了，如果是找单词interesting，那么就从根节点往下走，再把沿路的字母们都拼起来就行了。







（注：这里说的in不是单词，指的是in不是500w单词中的单词）
吕老师还没说完，小史就打断了他。








找单词interest：

找前缀为inter的所有单词：

遍历以前缀节点为根结点的一棵树，就能统计出前缀为inter的所有单词有多少个。
【字典树】












小史：节点中增加一个变量用于计数，在添加节点的时候，就把相应的计数+1



理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DictionaryTree.java
Main.java
运行结果
【字典树的应用】


小史：我想想啊，大量字符串的统计和查找应该就可以用字典树吧？字符串前缀的匹配也可以用，像咱们搜索常见的autoComplete控件是不是就可以用？




算法面试
面试现场",
如何在10亿数中找出前1000大的数？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

之前小史在BAT三家的面试中已经挂了两家，今天小史去了BAT中的最后一家面试了。
简单的自我介绍后，面试官给了小史一个问题。
【面试现场】

题目：如何在10亿数中找出前1000大的数？







小史：我可以用分治法，这有点类似快排中partition的操作。随机选一个数t，然后对整个数组进行partition，会得到两部分，前一部分的数都大于t，后一部分的数都小于t。


小史：如果说前一部分总数大于1000个，那就继续在前一部分进行partition寻找。如果前一部分的数小于1000个，那就在后一部分再进行partition，寻找剩下的数。





小史：首先，partition的过程，时间是o(n)。我们在进行第一次partition的时候需要花费n，第二次partition的时候，数据量减半了，所以只要花费n/2，同理第三次的时候只要花费n/4，以此类推。而n+n/2+n/4+…显然是小于2n的，所以这个方法的渐进时间只有o(n)

（注：这里的时间复杂度计算只是简化计算版，真正严谨的数学证明可以参考算法导论相关分析。）



半分钟过去了。







小史一时慌了神。

他回忆起了之前吕老师给他讲解bitmap时的一些细节。突然有了一个想法。




小史在纸上画了画。













理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
TopN.java
Main.java
运行结果：
（注：由于1000个数字符过多，超了微信文章限制，结果进行了省略，大家可以本地运行查看结果）
面试官看了一下。

小史熟练地介绍起了自己的项目，由于准备充分，小史聊起来游刃有余。面试官问的几个问题也进行了详细的解释。


小史走后，面试官在系统中写下了面试评语：

【遇见吕老师】
小史回到学校哼着歌走在校园的路上，正好碰到吕老师。


小史把面试情况和吕老师说了一下。


小史：感悟还挺深的。虽然平时做过topN的问题，知道分治法时间更少。但是碰到具体问题的时候还是要具体分析，这种大数据量的情况下反而用堆会更快。


算法面试
面试现场",
如何编程获得最多的年终红包奖？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天小史又去了一家互联网小巨头公司面试了。
【面试现场】












小史眉头一皱，发现事情并不简单。

题目：在数字矩阵中，从左上角到右下角，每次只能向右或向下，如何规划路径，能获得最大数字总和？
小史开始仔细分析问题，一时间竟想不到很好的方法。

小史心中反复默念题目，进行思考。

小史仔细回忆起了吕老师教他的华容道搜索算法。












【请教大神】
回到学校，小史把面试情况和吕老师说了一下。






吕老师：红色和蓝色两条路都能到达中间的100这个点，但是很明显，红色的路拿到的奖金更多。所以蓝色的路，后面不管再怎么走，都不可能拿到最大的奖金数了。


吕老师：假设蓝色路径再往后走出一条绿色路径是最大奖金，那么我把蓝色路径替换成红色路径，红色加绿色得到的奖金就比蓝色加绿色得到的多呀。


【记忆化搜索】







小史：哦，我明白了，这样我每搜到一个点，都可以和这个数比较，如果比它大，就更新这个数，继续搜，如果比它小，就不搜了，直接剪枝。





理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DeepFirstSearch.java
Main.java
运行结果
【记忆广搜】



吕老师：记忆深搜确实可以剪枝，但是假如有人刻意安排数字，把较小的数都安排在你先搜的路径上，那么你的计算量还是不会减少太多。


小史：还有这么坏的人呢？不过你这样一说我到想起来，深搜确实缺少一种“全局观”，可能第一条路搜完了，再来看第二条路，发现更好，结果第一条路全白搜了。





理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
BreadthFirstSearch.java
Main.java
运行结果
【动态规划】

吕老师：小史，代码写得不错，咱们再来看看广搜的过程，其实就是在搜索的过程中从左上到右下计算出了best(i,j)，所以为啥我们不能直接算出best(i,j)呢？






理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DynamicProgramming.java
Main.java
运行结果
【动态规划解析】






吕老师：状态的定义要满足几个点，第一，问题的答案是某种状态，或者可由状态进行推导。第二，当前状态可以由之前的状态推导而来。

【状态压缩】






小史：哦，我知道了，这道题，如果按照斜线方向来计算，只需要保留一条斜线的状态，就能计算出下一条斜线。所以之前的状态就不需要保留了。



理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：
DpCompressed.java
Main.java
运行结果




算法面试
面试现场",
如何编程解决朋友圈个数问题？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天小史去了一家社交小巨头公司面试了。
【面试现场】









面试官：举个例子，比如现在有5个宠物，分别是小猫1，小猫2，小猫3，小狗1，小狗2。再告诉你小猫1和小狗1是好朋友，小猫2和小狗1是好朋友，小猫3和小狗2是好朋友。这样它们之间就形成了2个朋友圈。










小史：先对宠物们编号，然后一对好友关系就用一个bitmap来存。判断两个bitmap之间是否有交集，只需要进行与操作。而融合的话只需要进行并操作。





小史在纸上画了半天进行思考。一分钟过去了。

小史：我好像知道了，可以在遍历好友关系的同时，把他们进行合并，我用双向链表来做。初始时，每个宠物都是一个单独的节点，而一对好友关系过来的时候，先判断两个节点是否在同一个链表中，如果不在，就把两个节点所在的链表头尾相连，形成一个新链表。



一分钟过去了。




【请教大神】
回到学校，小史把面试情况和吕老师说了一下。




















小史：这个我早就考虑到了，1和3是好朋友，并不是连接1和3，而是去找1的根和3的根，发现他们都是2，所以他们本来就在一个朋友圈，不需要相连。



【并查集】








小史：哦，对，堆也是一种树，但是它是二叉树，而且是完全二叉树，所以才能用数组存，并且用坐标的方式计算父亲孩子节点。


吕老师：今天的树同样可以用数组存，初始时刻数组中都是-1，当有两个节点需要合并时，只需要将其中一个数的根的值设为另一个数的根的下标就行。



小史在纸上划拉半天，终于有点明白了




理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了。
UnionFindSet.java
Main.java
运行结果
【基于树高度的合并优化】




吕老师：1和2是好朋友，2和3是好朋友，3和4是好朋友，4和5是好朋友







理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了。
UnionFindSetMergeOptimize.java
Main.java
运行结果
【路径压缩优化】








理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了。
UnionFindSetPathOptimize.java
Main.java
运行结果：
看着自己写的代码，小史还是忍不住赞叹。


算法面试
面试现场",
如何设计可自学习的五子棋AI？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

今天他去了一家国内人工智能巨头公司面试了。
简单的自我介绍后，面试官开始发问了。

【面试现场】




题目：如何设计可自学习的五子棋AI？












【请教大神】
小史回到学校，把面试的情况和计算机学院的吕老师说了一下。





【AlphaGO】









吕老师：一开始的AlphaGO是什么都不知道的，它是随机落子。但是它并不是random一个点，而是根据现场的情况和自身的算法，来落子，只是算法中的参数是随机的，所以落下的子也是随机的。







吕老师：这就要靠人去设计了，当然我们现在有一些比较成熟的神经网络模型，选好之后，所谓的训练啊，学习啊，其实都是在调节里面的参数。

【五子棋AI设计】

吕老师：首先我们来看你的算法，你会发现它的规则都是定死的，如果出现一种没有考虑到的情况，那么算法就不能进行堵截。



吕老师：哈哈，如果这样做的话，这种情况是无穷无尽的。而且五子棋的玩法比较简单，你还能设计出这样的规则，像围棋这种复杂的棋类，你可能没办法去设计这些规则了。




















小编注：关于这种算法的具体实现，由于篇幅较大就不在文章中具体展开了。想了解具体实现的朋友可以观看我在慕课网录制的免费视频教程：JS实现人机大战之五子棋（AI篇），地址：https://www.imooc.com/learn/644。
https://www.imooc.com/learn/644
【AI】






吕老师：小史，你看4个子的权重，你给10000，或者给50000，甚至给1个亿，对于其他值来说都是绝对高的值，所以最后效果应该是一样的。






吕老师：我们刚刚设计的这个五子棋算法，其实还是很简单，所以搜索空间并不大，如果是围棋这种复杂棋类，搜索空间将巨大无比，那就要采用非常先进的AI算法了，里面可能有成千上万个参数，训练起来计算量也是非常大，会有很多降维算法在里面，这些等你真正遇到，我再给你讲吧。


算法面试
面试现场",
为什么MySQL数据库要用B+树存储索引？,"小史是一个应届生，虽然学的是电子专业，但是自己业余时间看了很多互联网与编程方面的书，一心想进BAT互联网公司。

话说两个多月前，小史通过了A厂的一面，两个多月后的今天，小史终于等到了A厂的二面。
简单的自我介绍后，面试官看了看小史的简历，开始发问了。

【面试现场】


小史：没问题，这个项目前端用的react+webpack，后端用的nginx+SpringBoot+Redis+MySql，前后端分离的，最后用docker进行容器化部署。主要模块有师生系统、课程系统、成绩系统、选课系统等。





这个项目的架构和说辞，小史早已背得溜溜的。

小史：底层mysql是存储，redis是缓存，dao层操作mysql，cache层操作redis，service层处理业务逻辑，rest api层为前端提供rest接口。前端这边用react进行模块化，webpack打包部署。网关nginx进行负载均衡。mysql、redis、nginx和springboot应用都放在docker里部署。














题目：为什么MySQL数据库要用B+树存储索引？
小史听到这个题目，陷入了回忆。
【前段时间的饭局】
话说吕老师给小史讲完人工智能的一些知识后，他们一起回家吃小史姐姐做的饭去了。


【饭后】


吕老师：面试的时候一定是往深了问，不精通的话容易吃亏。不过面试时一般都是根据项目来问，项目中用到的技术，一定要多看看原理，特别是能和数据结构和算法挂钩的那部分。



小史：树的话，无非就是前中后序遍历、二叉树、二叉搜索树、平衡二叉树，更高级一点的有红黑树、B树、B+树，还有之前你教我的字典树。
【红黑树】

一听到红黑树，小史头都大了，开始抱怨了起来。

小史：红黑树看过很多遍了，但是每次都记不住，它的规则实在是太多了，光定义就有四五条规则，还有插入删除的时候，需要调整树，复杂得很

吕老师：小史，问你红黑树，并不是让你背诵它的定义，或者让你手写一个红黑树，而是想问问你它为什么这样设计，它的使用场景有哪些。















【B树】

















吕老师：小史，你要知道，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。

两个月前，小史面试没考虑内存情况差点挂了，传送门
传送门






【B+树】







吕老师：这也是和业务场景相关的，你想想，数据库中select数据，不一定只选一条，很多时候会选多条，比如按照id排序后选10条。

小史：我明白了，如果是多条的话，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。


【回到现场】


小史：这和业务场景有关。如果只选一个数据，那确实是hash更快。但是数据库中经常会选择多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。

小史：而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。

HR和小史简单地聊了聊基本情况，这次面试就结束了。
小史走后，面试官在系统中写下了面试评语：

几天后，小史收到了A厂的offer。


亲爱的场粉们，面试现场的第一季到这里就全部结束了，感谢大家的支持，我们一起期待小史后面的故事。
算法面试
面试现场",
游戏中的敏感词过滤是如何实现的？,"小秋今天去面试了，面试官问了一个与敏感词过滤算法相关的问题，然而小秋对敏感词过滤算法一点也没听说过。于是，有了下下事情的发生…..
面试官：玩过王者荣耀吧？了解过敏感词过滤吗？，例如在游戏里，如果我们发送“你在干嘛？麻痹演员啊你？”，由于“麻痹”是一个敏感词，所以当你把聊天发出来之后，我们会用“**”来代表“麻痹”这次词，所以发送出来的聊天会变成这样：“你在干嘛？**演员啊你？”。
小秋：听说过啊，在各大社区也经常看到，例如评论一个问题等，一些粗话经常被过滤掉了。
面试官：嗯，如果我给你一段文字，以及给你一些需要过滤的敏感词，你会怎么来实现这个敏感词过滤的算法呢？例如我给你一段字符串“abcdefghi”,以及三个敏感词”de”, “bca”, “bcf”。
小秋：（敏感词过来算法？？不就是字符串匹配吗？）我可以通过字符串匹配算法，例如在字符串”abcdefghi”在查找是否存在字串“de”，如果找到了就把”de“用”**”代替。通过三次匹配之后，接变成这样了：“abc ** fghi”。
面试官：可以说说你采用哪种字符串匹配算法吗？
小秋：最简单的方法就是采用两个for循环保留求解了，不过每次匹配的都时间复杂度为O(n*m)，我可以采用 KMP 字符串匹配算法，这样时间复杂度是 O(m+n)。

  n 表示字符串的长度，m 表示每个敏感词的长度。

面试官：这是一个方法，对于敏感词过滤，你还有其他方法吗？
小秋：（其他方法？说实话，我也觉得不是采用这种 KMP 算法来匹配的了，可是，之前也没去了解过敏感词，这下要凉）对敏感词过来之前也没了解过，暂时没想到其他方法。
面试官：了解过 trie 树吗？
小秋：（嘿嘿，数据结构这方法，我得争气点）了解过，我还用代码实现过。
面试官：可以说说它的特点吗？
小秋：trie 树也称为字典树、单词查找树，最大的特点就是共享字符串的公共前缀来达到节省空间的目的了。例如，字符串 “abc”和”abd”构成的 trie 树如下：

trie 树的根节点不存任何数据，每整个个分支代表一个完整的字符串。像 abc 和 abd 有公共前缀 ab，所以我们可以共享节点 ab。如果再插入 abf，则变成这样：

如果我再插入 bc，则是这样（bc 和其他三个字符串没有公共前缀）

面试官：那如果再插入 “ab” 这个字符串呢？
小秋：差点说了，每个分支的内部可能也含有完整的字符串，所以我们可以对于那些是某个字符串结尾的节点做一个标记，例如 abc, abd,abf 都包含了字符串 ab,所以我们可以在节点 b 这里做一个标记。如下（我用红色作为标记）：

面试官：可以说说 trie 树有哪些应用吗？
小秋：trie 最大的特点就是利用了字符串的公共前缀，像我们有时候在百度、谷歌输入某个关键字的时候，它会给我们列举出很多相关的信息

这种就是通过 trie 树来实现的。
小秋：（嗯？ trie 又称为单词查找树，好像可以用 trie 来实现刚才的敏感词匹配？面试官无缘无故提 trie 树难道别有用意？）
面试官：刚才的敏感词过滤，其实也可以采用 trie 来实现，你知道怎么实现吗？
小秋：（果然，面试官真是个好人啊，直接提示了，要是还不知道怎么实现，那不真凉？）我想想……..我知道了，我可以这样来实现：
先把你给我的三个敏感词：”de”, “bca”, “bcf” 建立一颗 trie 树，如下：

接着我们可以采用三个指针来遍历，我直接用上面你给你例子来演示吧。
1、首先指针 p1 指向 root，指针 p2 和 p3 指向字符串第一个字符

2、然后从字符串的 a 开始，检测有没有以 a 作为前缀的敏感词，直接判断 p1 的孩子节点中是否有 a 这个节点就可以了，显然这里没有。接着把指针 p2 和 p3 向右移动一格。

3、然后从字符串 b 开始查找，看看是否有以 b 作为前缀的字符串，p1 的孩子节点中有 b，这时，我们把 p1 指向节点 b，p2 向右移动一格，不过，p3不动。

4、判断 p1 的孩子节点中是否存在 p2 指向的字符c，显然有。我们把 p1 指向节点 c，p2 向右移动一格，p3不动。

5、判断 p1 的孩子节点中是否存在 p2 指向的字符d，这里没有。这意味着，不存在以字符b作为前缀的敏感词。这时我们把p2和p3都移向字符c，p1 还是还原到最开始指向 root。

6、和前面的步骤一样，判断有没以 c 作为前缀的字符串，显然这里没有，所以把 p2 和 p3 移到字符 d。

7、然后从字符串 d 开始查找，看看是否有以 d 作为前缀的字符串，p1 的孩子节点中有 d，这时，我们把 p1 指向节点 d，p2 向右移动一格，不过，p3和刚才一样不动。（看到这里，我猜你已经懂了）

8、判断 p1 的孩子节点中是否存在 p2 指向的字符e，显然有。我们把 p1 指向节点 e，并且，这里e是最后一个节点了，查找结束，所以存在敏感词de，即 p3 和 p2 这个区间指向的就是敏感词了，把 p2 和 p3 指向的区间那些字符替换成 *。并且把 p2 和 p3 移向字符 f。如下：

9、接着还是重复同样的步骤，知道 p3 指向最后一个字符。
面试官：可以说说时间复杂度吗？
小秋：如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。

  这里我说明一下，在实际的应用中，构建 trie 树的时间复杂度我觉得可以忽略，因为 trie 树我们可以在一开始就构建了，以后可以无数次重复利用的了。而刚才的 kmp 算法时间复杂度是 t *(m+n)，不过kmp需要维护 next 数组比较费空间，而且在实际情况中,敏感词的数量 t 是比较大，而 n 反而比较小的吧。

10、如果让你来 构建 trie 树，你会用什么数据结构来实现？
小秋：我一般使用 Java，我会采用 HashMap 来实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。
面试官：嗯，回去等通知吧。
今天主要将了 trie 树以及 trie 树的一些应用，还要就是如何通过 trie 树来实现敏感词的过滤，至于代码的实现，我这里就不给出了，在实现的时候，为了防止这种”麻 痹”或者“麻￥痹”等，我们也要对特殊字符进行过滤等，有兴趣的可以去实现一波。
算法面试
面试现场",
如何只用2GB内存从20/40/80亿个整数中找到出现次数最多的数,"这几天小秋去面试了，不过最近小秋学习了不少和位算法相关文章，对于算法题还是有点信心的，，，，于是，发现了如下对话。
面试官：如果我给你 2GB 的内存，并且给你 20 亿个 int 型整数，让你来找出次数出现最多的数，你会怎么做？
小秋：（嗯？怎么感觉和之前的那道判断一个数是否出现在这 40 亿个整数中有点一样？可是，如果还是采用 bitmap 算法的话，好像无法统计一个数出现的次数，只能判断一个数是否存在），我可以采用哈希表来统计，把这个数作为 key，把这个数出现的次数作为 value，之后我再遍历哈希表哪个数出现最多的次数最多就可以了。
面试官：你可以算下你这个方法需要花费多少内存吗？
小秋：key 和 value 都是 int 型整数，一个 int 型占用 4B 的内存，所以哈希表的一条记录需要占用 8B，最坏的情况下，这 20 亿个数都是不同的数，大概会占用 16GB 的内存。
面试官:你的分析是对的，然而我给你的只有 2GB 内存。
小秋：（感觉这道题有点相似，不过不知为啥，没啥思路，这下凉凉），目前没有更好的方法。
面试官：按照你那个方法的话，最多只能记录大概 2 亿多条不同的记录，2 亿多条不同的记录，大概是 1.6GB 的内存。
小秋：（嗯？面试官说这话是在提示我？）我有点思路了，我可以把这 20 亿个数存放在不同的文件，然后再来筛选。
面试题：可以具体说说吗？
小秋：刚才你说，我的那个方法，最多只能记录大概 2 亿多条的不同记录，那么我可以把这 20 亿个数映射到不同的文件中去，例如，数值在 0 至 2亿之间的存放在文件1中，数值在2亿至4亿之间的存放在文件2中….，由于 int 型整数大概有 42 亿个不同的数，所以我可以把他们映射到 21 个文件中去，如图

显然，相同的数一定会在同一个文件中，我们这个时候就可以用我的那个方法，统计每个文件中出现次数最多的数，然后再从这些数中再次选出最多的数，就可以了。
面试官：嗯，这个方法确实不错，不过，如果我给的这 20 亿个数数值比较集中的话，例如都处于 1~20000000 之间，那么你都会把他们全部映射到同一个文件中，你有优化思路吗？
小秋：那我可以先把每个数先做哈希函数映射，根据哈希函数得到的哈希值，再把他们存放到对应的文件中，如果哈希函数设计到好的话，那么这些数就会分布的比较平均。（关于哈希函数的设计，我就不说了，我这只是提供一种思路）
面试官：那如果我把 20 亿个数加到 40 亿个数呢？
小秋：（这还不简单，映射到42个文件呗）那我可以加大文件的数量啊。
面试官：那如果我给的这 40 亿个数中数值都是一样的，那么你的哈希表中，某个 key 的 value 存放的数值就会是 40 亿，然而 int 的最大数值是 21 亿左右，那么就会出现溢出，你该怎么办？
小秋：（那我把 int 改为 long 不就得了，虽然会占用更多的内存，那我可以把文件分多几份呗，不过，这应该不是面试官想要的答案），我可以把 value 初始值赋值为 负21亿，这样，如果 value 的数值是 21 亿的话，就代表某个 key 出现了 42 亿次了。

这里说明下，文件还是 21 个就够了，因为 21 个文件就可以把每个文件的数值种类控制在 2亿种了，也就是说，哈希表存放的记录还是不会超过 2 亿中。

面试官：反应挺快哈，那我如果把 40 亿增加到 80 亿呢？
小秋：（我靠，这变本加厉啊）………我知道了，我可以一边遍历一遍判断啊，如果我在统计的过程中，发现某个 key 出现的次数超过了 40 亿次，那么，就不可能再有另外一个 key 出现的次数比它多了，那我直接把这个 key 返回就搞定了。
面试官：行，此次面试到此结束，回去等通知吧。
今天这篇文章主要讲了大数据处理相关的一些问题，后面可能还会给大家找一些类似，但处理方式不同的题勒.
算法面试
面试现场",
