问题,回答,所属分类
告别递归算法，谈谈我的一些经验,"可能很多人在大一的时候，就已经接触了递归了，不过，我敢保证很多人初学者刚开始接触递归的时候，是一脸懵逼的，我当初也是，给我的感觉就是，递归太神奇了！
可能也有一大部分人知道递归，也能看的懂递归，但在实际做题过程中，却不知道怎么使用，有时候还容易被递归给搞晕。也有好几个人来问我有没有快速掌握递归的捷径啊。说实话，哪来那么多捷径啊，不过，我还是想写一篇文章，谈谈我的一些经验，或许，能够给你带来一些帮助。
为了兼顾初学者，我会从最简单的题讲起！
第一要素：明确你这个函数想要干什么
对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。
例如，我定义了一个函数
这个函数的功能是算 n 的阶乘。好了，我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。
第二要素：寻找递归结束条件
所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。
例如，上面那个例子，当 n = 1 时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1。完善我们函数内部的代码，把第二要素加进代码里面，如下
有人可能会说，当 n = 2 时，那我们可以直接知道 f(n) 等于多少啊，那我可以把 n = 2 作为递归的结束条件吗？
当然可以，只要你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件，所以下面这段代码也是可以的。
注意我代码里面写的注释，假设 n >= 2，因为如果 n = 1时，会被漏掉，当 n <= 2时，f(n) = n，所以为了更加严谨，我们可以写成这样：
第三要素：找出函数的等价关系式
第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。
例如，f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。
说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即
f(n) = n *  f(n-1)。

  这个等价关系式的寻找，可以说是最难的一步了，如果你不大懂也没关系，因为你不是天才，你还需要多接触几道题，我会在接下来的文章中，找一些递归题，让你慢慢熟悉起来。

找出了这个等价，继续完善我们的代码，我们把这个等价式写进函数里。如下：
至此，递归三要素已经都写进代码里了，所以这个 f(n) 功能的内部代码我们已经写好了。
这就是递归最重要的三要素，每次做递归的时候，你就强迫自己试着去寻找这三个要素。
还是不懂？没关系，我再按照这个模式讲一些题。

  有些有点小基础的可能觉得我写的太简单了，没耐心看？少侠，请继续看，我下面还会讲如何优化递归。当然，大佬请随意，可以直接拉动最下面留言给我一些建议，万分感谢！


  斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34….，即第一项 f(1) = 1,第二项 f(2) = 1…..,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。

1、第一递归函数功能
假设 f(n) 的功能是求第 n 项的值，代码如下：
2、找出递归结束的条件
显然，当 n = 1 或者 n = 2 ,我们可以轻易着知道结果 f(1) = f(2) = 1。所以递归结束条件可以为  n <= 2。代码如下：
第三要素：找出函数的等价关系式
题目已经把等价关系式给我们了，所以我们很容易就能够知道 f(n) = f(n-1) + f(n-2)。我说过，等价关系式是最难找的一个，而这个题目却把关系式给我们了，这也太容易，好吧，我这是为了兼顾几乎零基础的读者。
所以最终代码如下：
搞定，是不是很简单？

  零基础的可能还是不大懂，没关系，之后慢慢按照这个模式练习！好吧，有大佬可能在吐槽太简单了。


  一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

1、第一递归函数功能
假设 f(n) 的功能是求青蛙跳上一个n级的台阶总共有多少种跳法，代码如下：
2、找出递归结束的条件
我说了，求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。代码如下：
第三要素：找出函数的等价关系式
每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。
第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。
第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。
所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：
大家觉得上面的代码对不对？
答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入死循环。

  这里有人觉得 f(0) 应该是等于 1，等于 0 还是等于 1 不是很重要，此次我们就当作是 0 处理哈。

这也是我要和你们说的，关于递归结束条件是否够严谨问题，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：
有人可能会说，我不知道我的结束条件有没有漏掉怎么办？别怕，多练几道就知道怎么办了。
看到这里有人可能要吐槽了，这两道题也太容易了吧？？能不能被这么敷衍。少侠，别走啊，下面出道难一点的。

  下面其实也不难了，就比上面的题目难一点点而已，特别是第三步等价的寻找。


  反转单链表。例如链表为：1->2->3->4。反转后为 4->3->2->1

链表的节点定义如下：
虽然是 Java语言，但就算你没学过 Java，我觉得也是影响不大，能看懂。
还是老套路，三要素一步一步来。
1、定义递归函数功能
假设函数 reverseList(head) 的功能是反转但链表，其中 head 表示链表的头节点。代码如下：
2. 寻找结束条件
当链表只有一个节点，或者如果是空表的话，你应该知道结果吧？直接啥也不用干，直接把 head 返回呗。代码如下：
3. 寻找等价关系
这个的等价关系不像 n 是个数值那样，比较容易寻找。但是我告诉你，它的等价条件中，一定是范围不断在缩小，对于链表来说，就是链表的节点个数不断在变小，所以，如果你实在找不出，你就先对 reverseList(head.next) 递归走一遍，看看结果是咋样的。例如链表节点如下

我们就缩小范围，先对 2->3->4递归下试试，即代码如下
我们在第一步的时候，就已经定义了 reverseLis t函数的功能可以把一个单链表反转，所以，我们对 2->3->4反转之后的结果应该是这样：

我们把 2->3->4 递归成 4->3->2。不过，1 这个节点我们并没有去碰它，所以 1 的 next 节点仍然是连接这 2。
接下来呢？该怎么办？
其实，接下来就简单了，我们接下来只需要把节点 2 的 next 指向 1，然后把 1 的 next 指向 null,不就行了？，即通过改变 newList 链表之后的结果如下：

也就是说，reverseList(head) 等价于 reverseList(head.next) + 改变一下1，2两个节点的指向。好了，等价关系找出来了，代码如下(有详细的解释)：
这道题的第三步看的很懵？正常，因为你做的太少了，可能没有想到还可以这样，多练几道就可以了。但是，我希望通过这三道题，给了你以后用递归做题时的一些思路，你以后做题可以按照我这个模式去想。通过一篇文章是不可能掌握递归的，还得多练，我相信，只要你认真看我的这篇文章，多看几次，一定能找到一些思路！！

  我已经强调了好多次，多练几道了，所以呢，后面我也会找大概一些递归的练习题供大家学习，不过，我找的可能会有一定的难度。不会像今天这样，比较简单，所以呢，初学者还得自己多去找题练练，相信我，掌握了递归，你的思维抽象能力会更强！

接下来我讲讲有关递归的一些优化。
1. 考虑是否重复计算
告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。

  啥是子问题？ f(n-1),f(n-2)….就是 f(n) 的子问题了。

例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：

看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。
如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。
用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。
当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：
也就是说，使用递归的时候，必要
须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。
2. 考虑是否可以自底向上
对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。
不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n <=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。
对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道
f(1) = 1;
f(2) = 2;
那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下：
这种方法，其实也被称之为递推。
其实，递归不一定总是从上往下，也是有很多是从下往上的，例如 n = 1 开始，一直递归到 n = 1000，例如一些排序组合。对于这种从下往上的，也是有对应的优化技巧，不过，我就先不写了，后面再慢慢写。
说实话，对于递归这种比较抽象的思想，要把他讲明白，特别是讲给初学者听，还是挺难的，这也是我这篇文章用了很长时间的原因，不过，只要能让你们看完，有所收获，我觉得值得！
递归训练一：Leetcode 104.二叉树的最大深度
递归训练一：Leetcode 104.二叉树的最大深度
递归训练二：Leetcode 62.不同路径
递归训练二：Leetcode 62.不同路径
递归训练三：剑指 Offer 16. 数值的整数次方
递归训练三：剑指 Offer 16. 数值的整数次方
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
递归",
递归训练一：Leetcode 104.二叉树的最大深度,"给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]，
返回它的最大深度 3 。

  原题目链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree

https://leetcode-cn.com/problems/maximum-depth-of-binary-tree
这里我需要说一下，做二叉树相关的题，你需要的最少技能是，
1、得知道啥是二叉树
2、掌握二叉树的前中后序遍历 + 层序遍历
如果这些都不懂的，我建议你先去学一学。
1、从根节点开始，每下降一层，就将深度+1
2、用全局变量来记录下最大深度
3、每当达到叶子节点时就与全局变量进行比较和更新
1、若我们知道两个叶子节点的长度，那么我们就能通过两个叶子的最大深度再+1，得到根节点的最大深度。
2、而这种先知道两个子节点，再知道根节点恰好符合后序遍历的特点，具体看代码
1、使用队列来存放节点
2、一开始先知道当前层数的节点个数，然后根据个数出队，并对其孩子节点入队
递归训练二：Leetcode 62.不同路径
递归训练二：Leetcode 62.不同路径
递归训练三：剑指 Offer 16. 数值的整数次方
递归训练三：剑指 Offer 16. 数值的整数次方
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
递归",
递归训练二：Leetcode 62.不同路径,"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？


  这是 leetcode 的 62 号题：https://leetcode-cn.com/problems/unique-paths/

（1）找出递归关系式
首先这个问题的关键就是要找出递归之间的关系式，我们先定义函数 dfs(i，j) 的返回值是机器人从 (0, 0) 走到 (i, j) 时的所有路径数，
想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达
一种是从 (i-1, j) 这个位置走一步到达
一种是从(i, j – 1) 这个位置走一步到达
因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以递归关系式是 dfs(i, j) = dfs(i – 1, j) + dfs(i, j – 1)。
如果你不是特别明白，那么我建议你可以画一个图演示一下。
（2）找出初始值
显然，在 dfs(i, j) 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i – 1 或者 j – 1，就变成负数了，也就是说，i = 0 或者 j = 0 =是函数的边界，而且当 i = 0 或者 j = 0，代表机器人在做上面一行或者做有左边一列，此时的 dfs(i, j) = 1。
所以代码如下：
优化一下
大部分问题都可以用递归暴力做出来，但是绝大部分都是可以优化的，例如该问题就有很多被重复计算的地方，如果自己不大懂，那么你平时可以画一个图看一下，例如当 i = 4, j = 4 时，递归调用的图如下：

画红圈的地方，就是重复调用的地方，如果不进行剪枝，那么时间复杂度就是指数级别的了。
所以呢，我们可以用一个数组来存储计算的结果，例如我们可以用 arr[3] [3] 把 dfs (3, 3) 的计算结果保存起来，每次要计算 dfs(3, 3) 的时候，我们可以先判断 arr[3] [3] 是否有记录过了。
至于如何判断是否记录过，你可以刚开始的时候，给数组 arr 赋予一个特殊的值，代码如下
时间复杂度为 O(m * n)，空间复杂度为 (m * n)。
但其实这道题的最优解，应该是用动态规划来做，但是咱们这种的专题是递归，所以我就不讲动态规划相关的了。
递归训练一：Leetcode 104.二叉树的最大深度
递归训练一：Leetcode 104.二叉树的最大深度
递归训练三：剑指 Offer 16. 数值的整数次方
递归训练三：剑指 Offer 16. 数值的整数次方
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
递归",
递归训练三：剑指 Offer 16. 数值的整数次方,"实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。
pow(x, n)
示例 1：
示例 2：
示例 3：
提示：

  原题链接：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/

这道题是典型的快速幂算法，但这道题坑比较多，除了要区别 n 是正数还是负数，还要考虑 n 取反溢出的问题。
思路：假设求 7 ^ 11
若将 n 用二进制来表示，则有 11 = 1011
那么 7 ^ 11 可以看成是 7  ^ 11 = 7^1 * 7^2 * 7^0 *  7^8 = 7^1 * 7^2  *  7^8
故我们可以每次判断 n 的二进制数中的最后一位数字是否是 1
是的话结果就必须乘 x，若不是的话，就不处理。
不过不管是不是，x 每一轮都要翻倍。
解决快速幂后，就解决正负数的问题。
一开始没有考虑到 2^31 次方的问题（取相反数后也是 2^31 次方）
故需要用一个 long 类型来接收 n，然后再去取相反数。
先判断 n
（1）正数，不用做操作
（2）0，直接返回 0
（3）负数，转为正数并将 x 倒过来。
递归版本的代码如下
这里也顺便提供一下非递归版本的代码
递归训练一：Leetcode 104.二叉树的最大深度
递归训练一：Leetcode 104.二叉树的最大深度
递归训练二：Leetcode 62.不同路径
递归训练二：Leetcode 62.不同路径
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
递归训练四：Leetcode 4. 寻找两个正序数组的中位数
递归",
递归训练四：Leetcode 4. 寻找两个正序数组的中位数,"给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
示例 1：
示例 2：
示例 3：
示例 4：
示例 5：
提示：

  原题链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

这道题有一定难度，如果两个数组的长度和为奇数的话，那么这道题简单一些；但如果两个数组的长度和为偶数时，这道题的难度顿时上升了
为什么呢?因为你要求出两个数，然后再来求平均，而且主要，这两个数可能一个数是位于 arr1 数组，而一个数是位于 arr2 数组，这会导致我们的判断逻辑变的很复杂，不信的话，你可以去试试。

  当然，如果你用一个临时数组把两个数组合并起来，然后求它的中位数，这肯定简单，不过我们要的是时间复杂度为 O(log (m+n))算法，下面开始讲解。

那怎么办呢？实际上，这道题我们是可以进行一下转换，就是无论两个数组的长度和是奇数还是偶数，我们都求出第 （m+n+1)/2 小数以及第 （m+n+2)/2小数，然后求这两个数的平均数，就可以了。这样，我们就屏蔽了奇偶数的影响，会容易一点。
所以现在的问题转化为如何求两个有序数组的第 K 小数，这个也有一定难度，但比上面好多了。
下面我随便讲一下如何用递归来求：我们可以采用递归的方法不断缩小 K 的，把求第 K 小元素转化为第 (K-K/2) 小元素….我举个例子吧，比较容易理解。
我们假定 arr1 = [1, 2,3]，arr2 = [3,4,5,6]，K = 4。

这里令 K = K- 1(说明：这里我们假设K从 0 算起，也就是有第 0 小元素，相当于令 K = K – 1)

  如果不懂，你就先跟着我的思路走，之后再来想

再令
mid1 = K/2 = 1。
mid2 = K/2 = 1。

假如 arr2[mid2] > arr2[mid1]，那么我们要找的目标数是一定存在于 arr1[mid1+1…m] 和 arr2[0…mid2]中。而不可能存在于 arr1[0…mid1] 和 arr2[mid2+1…n] 之中。
那么问题转化为在数组 arr1[mid1+1…m]和数组 arr2[0…mid2] 寻找第（K-md1-1）小的元素，然后不断重复这个过程，直到 k < 1 或者 数组的左边界大于右边界（就是二分查找中的 left > right，那么递归就要结束了）
不过这里需要注意的是，有可能 k/2 的值是大于 m 或者 n 的，所以如果 k/2 > m 或者 n 的话，我们直接令 mid1 = m-1 或者 mid2 = n-1 就行了。
所以这道题的代码如下，下面有详细注释
对于这道题，还是挺难的，特别容易出错，如果你是新手，看不懂，那么可以先放着，后面在来看。
递归训练一：Leetcode 104.二叉树的最大深度
递归训练一：Leetcode 104.二叉树的最大深度
递归训练二：Leetcode 62.不同路径
递归训练二：Leetcode 62.不同路径
递归训练三：剑指 Offer 16. 数值的整数次方
递归训练三：剑指 Offer 16. 数值的整数次方
递归",
