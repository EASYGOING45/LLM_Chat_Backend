问题,回答,所属分类
记一次 shopee 面试：最小栈的最优解,"前阵子面试的时候，在 shopee 的一面中，问了我一道最小栈的问题，关于最小栈的问题，我以前是做过的，以为是送分题，最结果最优解没写出来，不过也脑补了一些优化，算是答的还行。下面我先大致描述下这道题，然后一步步给出最优解以及我在面试中是解法（面试中给出了几个优化，但想不出最优解）。题目如下：

实现一个这样的栈，这个栈除了可以进行普通的push、pop操作以外，还可以进行getMin的操作，getMin方法被调用后，会返回当前栈的最小值。栈里面存放的都是 int 整数，并且数值的范围是 [-100000, 100000]。要求所有操作的时间复杂度是 O(1)。
附加：如果空间复杂度也能O(1)的话可加分。

对于这道题，如果是要求时间复杂度为 O(1)，空间复杂度为 O(n) 或者 时间复杂度为 O(n)，空间复杂度为 O(1) 的话，还是相对比较简单一点的，不过我猜想仍然有部分同学不会，所以我下面都稍微讲解一下。不过如果要求时间复杂度和空间复杂度都是 O(1) 的话，就比较难了，反正我当时是没做出来，只给出了一些优化的思路。

时间复杂度 O(n) + 空间复杂度 O(1) 这个我不讲，因为这个很简单，就是获取最小栈的时候，每次都遍历一次栈，把最小栈返回去就可以了，估计也没有人会问你这个方法

这个要求其实也不难，我们可以用一个辅助栈来存放最小值。例如我们有两个栈 stack 和 helper，stack 是目标栈，helper 是辅助栈，用来存放最小值。每次 getMin 的时候，直接从 helper 栈顶获取即可。下面重点讲一下 push 操作。
每次进行 push 操作的时候，进行如下操作（假设要 push 的元素是 t）
1、对于 stack 栈，我们按照正常情况把元素 push 到栈顶就可以了。
2、然后要把元素 t push 到 helper 栈顶的时候，要先把 t 与 helper 栈顶的元素（假设是 a）进行比较，如果 t <= a，则把元素 t push 到 helper 的栈顶，如果 t > a，这个时候，我们不把 t push 进去，而是重复把 a push 到 helper 的栈顶。
我举个例子吧，例如我们要把数组 arr = {2, 1, 3} 都放入栈中，则存放过程如下：
1、首先 push 2。由于刚开始 stack 和 helper 都是空的，所以直接把 2 放入，此时目标栈和辅助栈的值如下：stack = {2}，helper = {2}。
2、接下来 push 1。由于 helper 栈顶元素比 1 大，所以直接把 1 放入 helper 的栈顶，此时：stack = {2, 1}，helper = {2, 1}。
3、接下来 push 3，由于 helper 栈顶元素比 3 小，所以重复把 栈顶的元素再次入栈，此时： stack = {2, 1, 3}，helper = {2, 1, 1}。
对于 pop 操作，直接把两个栈的栈顶元素删除即可，所以具体代码如下：
不过接着面试官问我，你这个空间复杂度是 O(n)，可以优化到空间复杂度为 O(1) 吗？
这时有点小紧张，因为我之前看的书和别人的讲解中，根本没看过时间和空间都是 O(1) 的解法，不过这道题中，有一个条件限制，就是数值的范围是 [-100000, 100000]，我知道，这个数值限制，一定是一个突破口，可是硬是没想出来要怎么利用，于是我就按照自己的理解，给出了如下的优化方案：
1、优化1
刚才我们在对 helper 进行 push 操作的时候，如果栈顶的元素较小，那么我们是重复把栈顶的元素重复 push 进去的，显然，这是一个单调栈，并且栈顶的元素只会越来越小，假如栈顶的元素很小的话，那么有可能会出现，helper 的栈中有很多一样的元素，例如 helper = {2, 1, 1, 1, 1, 1, 1, 0, 0, 0 , 0, 0, 0}。
为了解决这个问题，我们可以用一个数值，来表示此处有多少个连续的元素，例如上面的辅助栈中有 1 个 2，6 个 1，6 个 0，那么我们可以这样来表示：helper = {2, 1, 1, 6, 0, 6}。这样的话，辅助栈用到的空间可以小一点。

当然，也有可能用的更多了，例如栈中基本没有连续的元素，例如原本 helper = {3， 2， 1}，则会变成 helper = {3, 1, 2, 1, 1, 1}。当然，这是极端的情况。

2、优化2
面试官问我还能有其他方法吗？
显然，我上面的优化中，并没有用到数值范围 [-100000, 100000] 这个条件，所以肯定是不行的，该怎么用利用到这个条件呢？
这个时候我是想到了位运算，一个 int 是 32 位，我打算把它分割成两部分，前面 16 位来存放目标值，后面 16 位来存放最小栈。也就是说，我不需要辅助栈 helper 了，只需要一个 stack 就够了，然后用元素的后 16 位来充当 helper 辅助栈的功能。
例如对于最上面的例子 stack = {2, 1, 3}, helper = {2, 1, 1}。那么这里只需要用一个 stack 来存放就可以了。把元素分割成 两部分，前面 16 位存放 stack 里面的值，后面 16 位存放 helper 里面的值，即 stack = {(2,2), {1, 1}, (3, 1)}。然后每次取值的时候，在通过移位的方法来获取值。
想到了这个方法，虽然没有想出最优解，不过我看面试官还是有那么点小满意的，不过我这个方法的数值范围限制是 [-2^15, 2^15 - 1]，而题目的限制是 [-100000, 100000]，所以会溢出，所以行不通，不过至少提供了一种思路。当然我可以用 long 类型的来存放，不过 Long 所需要的空间是 int 的两倍，所以我觉得也不大行，还是没有达到 O(1)。
然后我自己也想不出啥方法了，后面去网上和群里问被人才找到解法。下面我稍微说下这个方法
这种方法的话，我们的 stack 栈中，不能存放原始数值，而是应该存放 差值，啥差值？就是存放栈顶与最小值的差值。我还是详细一点给大家讲一个案例吧，案例配合代码，应该还是挺好理解的，例如 arr = {2, 1, 3, 0}，那么把这些元素入栈时，stack 栈中元素以及最小值的变化如下

上面表格是 push 时，栈中数值的变化，然后再进行 getMin 和 pop 可以通过相应的判断获取，直接看我的代码实现吧，我会进行相应解释，挺好懂，代码如下：
如果没有进行数值范围限制，上面的方法能行吗？答是不行，因为数值没有限制的话，差值的计算可能会溢出。
虽然这道题总体不难，不过一道题的解法多种多样，我们千万不能止步于最简单的解法，而应该寻找最优解。后面我也会讲一些面试相关的题，并且每次讲的时候，都会给出详细的解答，从暴力一步步到最优。
校招面试
算法面试
面试现场",
记一道字节跳动面试：变形的链表反转,"前几天有个朋友去面试字节跳动，面试官问了他一道链表相关的算法题，不过他一时之间没做出来，就来问了我一下，感觉这道题还不错，拿来讲一讲。
这其实是一道变形的链表反转题，大致描述如下
给定一个单链表的头节点 head,实现一个调整单链表的函数，使得每K个节点之间为一组进行逆序，并且从链表的尾部开始组起，头部剩余节点数量不够一组的不需要逆序。（不能使用队列或者栈作为辅助）
例如：
链表:1->2->3->4->5->6->7->8->null, K = 3。那么 6->7->8，3->4->5，1->2各位一组。调整后：1->2->5->4->3->8->7->6->null。其中 1，2不调整，因为不够一组。
这道题的难点在于，是从链表的尾部开始组起的，而不是从链表的头部，如果是头部的话，那我们还是比较容易做的，因为你可以遍历链表，每遍历 k 个就拆分为一组来逆序。但是从尾部的话就不一样了，因为是单链表，不能往后遍历组起。不过这道题肯定是用递归比较好做，对递归不大懂的建议看我之前写的一篇文章为什么你学不会递归？告别递归，谈谈我的一些经验，这篇文章写了关于递归的一些套路。
为什么你学不会递归？告别递归，谈谈我的一些经验
在做这道题之前，我们不仿先来看看如果从头部开始组起的话，应该怎么做呢？例如：链表:1->2->3->4->5->6->7->8->null, K = 3。调整后：3->2->1->6->5->4->7->8->null。其中 7，8不调整，因为不够一组。
对于这道题，如果你不知道怎么逆序一个单链表，那么可以看一下我之前写的如何优雅着反转单链表
如何优雅着反转单链表
这道题我们可以用递归来实现，假设方法reverseKNode()的功能是将单链表的每K个节点之间逆序(从头部开始组起的哦);reverse()方法的功能是将一个单链表逆序。
那么对于下面的这个单链表，其中 K = 3。

我们把前K个节点与后面的节点分割出来：

temp指向的剩余的链表，可以说是原问题的一个子问题。我们可以调用reverseKNode()方法将temp指向的链表每K个节点之间进行逆序。再调用reverse()方法把head指向的那3个节点进行逆序，结果如下：


再次声明，如果对这个递归看不大懂的，建议看下我那篇递归的文章

接着，我们只需要把这两部分给连接起来就可以了。最后的结果如下：

代码如下：
这两道题可以说是及其相似的了，只是一道从头部开始组起，这道从头部开始组起的，也是 leetcode 的第 25 题。而面试的时候，经常会进行变形，例如这道字节跳动的题，它变成从尾部开始组起，可能你一时之间就不知道该怎么弄了。当然，可能有人一下子就反应出来，把他秒杀了。
其实这道题很好做滴，你只需要先把单链表进行一次逆序，逆序之后就能转化为从头部开始组起了，然后按照我上面的解法，处理完之后，把结果再次逆序即搞定。两次逆序相当于没逆序。
例如对于链表（其中 K = 3）

我们把它从尾部开始组起，每 K 个节点为一组进行逆序。步骤如下
1、先进行逆序

逆序之后就可以把问题转化为从头部开始组起，每 K 个节点为一组进行逆序。
2、处理后的结果如下

3、接着在把结果逆序一次，结果如下

代码如下
类似于这种需要先进行逆序的还要两个链表相加，这道题字节跳动的笔试题也有出过，如下图的第二题

这道题就需要先把两个链表逆序，再节点间相加，最后在合并了。
关于链表的算法题，在面试的时候听说是挺常考的，大家可以多注意注意，遇到不错的链表算法题，也欢迎扔给我勒。
校招面试
算法面试
面试现场",
记一次手撕算法面试：字节跳动的面试官把我四连击了,"字节跳动这家公司，应该是所有秋招的公司中，对算法最重视的一个了，每次面试基本都会让你手撕算法，今天这篇文章就记录下当时被问到的几个算法题，并且每个算法题我都详细着给出了最优解，下面再现当时的面试场景。看完一定让你有所收获
大部分情况下，面试官都会问一个不怎么难的问题，不过你千万别太开心，因为这道题往往可以拓展出更多有难度的问题，或者一道题看起来很简单，但是给出最优解，确实很不容易的。这道题是这样的

给定一个只包括 ‘(‘，’)’的字符串，判断字符串是否有效。注：空字符串属于有效字符串

第一眼看到这道题，我去，这么简单，稳了（因为一面的时候，刚刚被面试官怼过勇者斗恶龙的DP题，在 leetcdoe 属于 hard 级别）。

其实这道题的 leetcode 第 20 题的简化版，属于 easy 级别

于是我也不假思索直接用栈来解决了，相信 99% 都会用栈解决吧？这里我稍微说以下过程吧，步骤如下：
1、在遍历字符串的过程中，遇到 “(” 就让它入栈，遇到 “)” 就判断下栈里面有没有 “(” ：
2、当字符串遍历完成，判断栈是否为空，如果为空则表示字符串有效，否则无效。
为了兼顾小白，我该给你们画了个图演示，，，，我太良心了。

代码如下所示（Java，不过不是学Java也能看懂）
接着面试官说我这道题的空间复杂度是 O(n)，问我能优化一下吗？
说实话，如果你做过 leetcode 的第 20 题，可能你的脑子会被定向也不一定，因为那道题用栈来处理就是最优解的了。不过这道题属于简化版，其实可以把空间复杂度优化成 O(1)，大家可以想一下哦。
由于我们栈里面存放的都是同一种字符 ""("" ，其实我们可以用一个变量来取代栈的，这个变量就记录 ""("" 的个数，遇到 ""("" 变量就加 1，遇到 "")"" 变量就减 1，栈为空就相当于变量的值为 0。
当时脑子有点不知为啥，就马上相当这个方法了，于是一分钟就修改好了代码，如下：
这样子的话，时间复杂度为 O(n)，空间复杂度为 O(1)。
接着面试官就继续就这道题继续加大难度，问题改为如下

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。


其实这道题就是 leetcode 的原题，第 32 题，难度为 hard。

这道题由于我之前做过，微微一笑，假装用严肃的表情思考一下，然后马上给出了思路，刚开始我是用暴力法的。
1、暴力法
暴力法其实很简单，就是最开始把第一个字符当做最长有效括号的首字符来遍历字符串，接着把第二个字符当做最长有效括号的首字符来遍历字符串，接着把第三个字符......
例如对于 s =  ""( ) ) ( ( ) )""。
把第一个字符作为首字符，则 max = 2 （遇到第三个字符 ')' 就匹配不了了）
把第二个字符作为首字符，则 max = 0 （一开始就是 ')'，显然啥也匹配不了）
把第三个字符作为首字符，则 max = 0
把第四个字符作为首字符，则 max = 4
.....
这种做法的时间复杂度为 O(n^2)，空间复杂度为 O(1)

基本上面那道题一样，只是做了 n 次遍历。

接着面试官问，还能优化吗？
早就知道会问优化的了，我自己之前也做过这道题，于是假装思考了一下，马上给出了优化。
2、优化
这道题的优化版本我们仍然是用栈来做，不过入栈的时候，不是让 ""("" 入栈，而是让 ""("" 的下标入栈。步骤如下：
1、先把 -1 放入栈内。（至于为什么？看到后面你就知道了）
2、、对于遇到的每个 '(' ，我们将它的下标放入栈中。
3、对于遇到的每个 ‘)’ ，我们弹出栈顶的元素并将当前元素的下标与遇到的‘(’元素的下标作差，得出当前有效括号字符串的长度。
通过这种方法，我们继续计算有效子字符串的长度，并最终返回最长有效子字符串的长度。
看不懂？没事，我弄个例子画几个图，例如 s = ""( ) ) ( ( ) )""，并且用变量 max 来保存最长有效字符串的程度，i 表示当前字符串的下标
0、初始化：max = 0; i = 0。-1 放入栈内

1、i = 0，s[i] = '('，下标 i = 0  入栈

2、i = 1，s[i] = ')'，出栈; i - 栈顶元素 = 1 - (-1) = 2，此时 max = 2

3、i = 2，s[i] = ')'，出栈；这个时候要注意：由于 -1 出栈后，栈顶没有元素了，所以这个时候我们必须把 ')' 的下标入栈，相当于最开始的初始化。

4、i = 3，s[i] = '('，入栈;

5、i = 4，s[i] = '('，入栈;

6、i = 5，s[i] = ')'，出栈；i - 栈顶 = 5 - 3 = 2；此时 max = 2;

7、i = 6，s[i] = ')'，出栈；i - 栈顶 = 6 - 2 = 4；此时 max = 4;

8、遍历结束，最长有效括号为 4。
看不大懂？没事，看下代码加深理解勒，代码如下：
这种做法的时间复杂度为 O(n)，空间复杂度为 O(n)，能想到用栈来处理，算是很不错的了。
我以为我给出这个解法算是可以的了，面试官应该换一道题的了，然后，面试官又来了一句：还能再优化吗？。这个时候我陷入了沉思.......
看文章的各位大佬们可以想一想在空间上是否还能优化，因为在时间上是不可能优化的了。
想了一会，居然不可以用栈，优化的方案肯定是类似于上面那道题一样，用记录数量的变量来代替栈，然后就被我想出了，具体如下：
实际上，这道题仍然可以像上面那样，用变量来代替栈来优化，不过这个时候我们需要两个变量，我们假设变量为 left 和 right。
我们在从从左到右遍历字符串的过程中，用 left 记录 '(' 的数量，用 right 记录 ')' 的数量。并且在遍历的过程中：
1、如果 left == right，显然这个时候 right 个 ')' 都将一定能够得到匹配。所以当前的有效括号长度为 2 * right。然后更新 max。
2、如果 left < right，显然这个时候部分 ')' 一定得不到匹配，此时我们把 left 和 right 都置为 0。

当遍历完字符串，我们是否就得到最大长度的有效括号了呢？大家可以想一下
答是不可以的，我们还需要从右到左遍历计算一下。
为什么呢？
因为实际上 '(' 和 ')' 其实是等价的，为什么就不可以倒过来遍历计算呢？所以，千万别忽略了哈。
最后的代码如下：
这种做法的时间复杂度为 O(n)，空间复杂度为 O(1)。
说时候，最后一种方法还是比较难想到了，从这次面试中也可以看出，千万不要看一道题很简单，有些题要做出来很简单，但是，如果要以最优解的方式做出来，难度马上指数上升。。
如果你后面看不大懂，建议多看几遍哦，这道题考的频率还是挺高的，主要是可以做的方法多，每种方法的效率又不一样，不过我这里必须给你们的提醒，就是平时在做题的时候，一定要寻找最优解，而不是 ac 了就不管了，应该多看看别人的解法。
校招面试
算法面试
面试现场",
记一次阿里笔试：一行代码解决约瑟夫环问题的,"约瑟夫环问题算是很经典的题了，估计大家都听说过，然后我就在一次笔试中遇到了，下面我就用 3 种方法来详细讲解一下这道题，最后一种方法学了之后保证让你可以让你装逼。

问题描述：编号为 1-N 的 N 个士兵围坐在一起形成一个圆圈，从编号为 1 的士兵开始依次报数（1，2，3…这样依次报），数到 m 的 士兵会被杀死出列，之后的士兵再从 1 开始报数。直到最后剩下一士兵，求这个士兵的编号。

在大一第一次遇到这个题的时候，我是用数组做的，我猜绝大多数人也都知道怎么做。方法是这样的：
用一个数组来存放 1，2，3 … n 这 n 个编号，如图（这里我们假设n = 6, m = 3）

然后不停着遍历数组，对于被选中的编号，我们就做一个标记，例如编号 arr[2] = 3 被选中了，那么我们可以做一个标记，例如让 arr[2] = -1，来表示 arr[2] 存放的编号已经出局的了。

然后就按照这种方法，不停着遍历数组，不停着做标记，直到数组中只有一个元素是非 -1 的，这样，剩下的那个元素就是我们要找的元素了。我演示一下吧：

这种方法简单吗？思路简单，但是编码却没那么简单，临界条件特别多，每次遍历到数组最后一个元素的时候，还得重新设置下标为 0，并且遍历的时候还得判断该元素时候是否是 -1。感兴趣的可以动手写一下代码，用这种数组的方式做，千万不要觉得很简单，编码这个过程还是挺考验人的。
这种做法的时间复杂度是 O(n * m), 空间复杂度是 O(n);
学过链表的人，估计都会用链表来处理约瑟夫环问题，用链表来处理其实和上面处理的思路差不多，只是用链表来处理的时候，对于被选中的编号，不再是做标记，而是直接移除，因为从链表移除一个元素的时间复杂度很低，为 O(1)。当然，上面数组的方法你也可以采用移除的方式，不过数组移除的时间复杂度为 O(n)。所以采用链表的解决方法如下：
1、先创建一个环形链表来存放元素：

2、然后一边遍历链表一遍删除，直到链表只剩下一个节点，我这里就不全部演示了

代码如下：
核心代码
这种方法估计是最多人用的，时间复杂度为 O(n * m),空间复杂度是 O(n)。
还有更好的方法吗？答有，请往下看
其实这道题还可以用递归来解决，递归是思路是每次我们删除了某一个士兵之后，我们就对这些士兵重新编号，然后我们的难点就是找出删除前和删除后士兵编号的映射关系。
我们定义递归函数 f(n，m) 的返回结果是存活士兵的编号，显然当 n = 1 时，f(n, m) = 1。假如我们能够找出 f(n，m) 和 f(n-1，m) 之间的关系的话，我们就可以用递归的方式来解决了。我们假设人员数为 n, 报数到 m 的人就自杀。则刚开始的编号为
…
1
...
m - 2
m - 1
m
m + 1
m + 2
...
n
…
进行了一次删除之后，删除了编号为 m 的节点。删除之后，就只剩下 n - 1 个节点了，删除前和删除之后的编号转换关系为：
删除前     ---     删除后
…          ---      …
m - 2     ---     n - 2
m - 1    ---      n - 1
m         ----    无(因为编号被删除了)
m + 1     ---     1(因为下次就从这里报数了)
m + 2     ----     2
…         ----         …
新的环中只有 n - 1 个节点。且删除前编号为 m + 1, m + 2, m + 3 的节点成了删除后编号为 1， 2， 3 的节点。
假设 old 为删除之前的节点编号， new 为删除了一个节点之后的编号，则 old 与 new 之间的关系为 old = (new + m - 1) % n + 1。

注：有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1.
这样，我们就得出 f(n, m) 与 f(n - 1, m)之间的关系了，而 f(1, m) = 1.所以我们可以采用递归的方式来做。代码如下：

我去，两行代码搞定，而且时间复杂度是 O(n)，空间复杂度是O(1)，牛逼！那如果你想跟别人说，我想一行代码解决约瑟夫问题呢？答是没问题的，如下：
卧槽，以后面试官让你手写约瑟夫问题，你就扔这一行代码给它。
不过那次笔试时，并没有用递归的方法做，而是用链表的方式做，，，，，那时，不知道原来还能用一行代码搞定的，，，，欢迎各位大佬提供半行代码搞定的方法！
校招面试
算法面试
面试现场",
记一次阿里面试：面试挂在了 LRU 缓存算法设计上,"最近春招提前批也要打响了，我会在推送算法+计算机基础的文章下，尽快推一些面试相关的文章
大概是去年的三月份，在找春招实习的时候，面了一次阿里，然后第一面就是写算法题，然而万万没有想到的是，我居然挂在了 LRU 缓存算法上了，这可是我再熟悉不过的算法。。。。。。。今天就来分享一波，说不定，你也做不出！
一、勤于动脑，懒于行动的祸
当时做题的时候，自己想的太多了，感觉设计一个 LRU(Least recently used) 缓存算法，不会这么简单啊，于是理解错了题意（我也是服了，还能理解成这样，，，，），自己一波操作写了好多代码，后来卡住了，再去仔细看题，发现自己应该是理解错了，就是这么简单，设计一个 LRU 缓存算法。
不过这时时间就很紧了，按道理如果你真的对这个算法很熟，十分钟就能写出来了，但是，自己虽然理解 LRU 缓存算法的思想，也知道具体步骤，但之前却从来没有去动手写过，导致在写的时候，非常不熟练，也就是说，你感觉自己会 和你能够用代码完美着写出来是完全不是一回事。
所以在此提醒各位，如果可以，一定要自己用代码实现一遍自己自以为会的东西。千万不要觉得自己理解了思想，就不用去写代码了，独自撸一遍代码，才是真的理解了，而且面试的时候，需要你再记事本里打代码，不给你编译器的。。。。。。。
不过今天我带大家用代码来实现一遍 LRU 缓存算法，并且提供最优解，以后你在遇到这类型的题，保证你完美秒杀它。
设计并实现最近最少经用（LRU）缓存的数据结构。它应该支持以下操作：get 和 put。
get(key) – 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。
put(key, value) – 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，
使最近最少使用的项目无效。
进阶：
你是否可以在 O(1) 时间复杂度内执行两项操作？
示例：
我们要删的是最近最少使用的节点，一种比较容易想到的方法就是使用单链表这种数据结构来存储了。当我们进行 put 操作的时候，会出现以下几种情况：
1、如果要 put(key,value) 已经存在于链表之中了（根据key来判断），那么我们需要把链表中久的数据删除，然后把新的数据插入到链表的头部。、
2、如果要 put(key,value) 的数据没有存在于链表之后，我们我们需要判断下缓存区是否已满，如果满的话，则把链表尾部的节点删除，之后把新的数据插入到链表头部。如果没有满的话，直接把数据插入链表头部即可。
对于 get 操作，则会出现以下情况
1、如果要 get(key) 的数据存在于链表中，则把 value 返回，并且把该节点删除，删除之后把它插入到链表的头部。
2、如果要 get(key) 的数据不存在于链表之后，则直接返回 -1 即可。
大概的思路就是这样，不要觉得很简单，让你手写的话，十分钟你不一定手写的出来。具体的代码，为了不影响阅读，我在文章的最后面在放出来。
时间、空间复杂度分析
对于这种方法，put 和 get 都需要遍历链表查找数据是否存在，所以时间复杂度为 O(n)。空间复杂度为 O(1)。
在实际的应用中，当我们要去读取一个数据的时候，会先判断该数据是否存在于缓存器中，如果存在，则返回，如果不存在，则去别的地方查找该数据（例如磁盘），找到后在把该数据存放于缓存器中，在返回。
所以在实际的应用中，put 操作一般伴随着 get 操作，也就是说，get 操作的次数是比较多的，而且命中率也是相对比较高的，进而 put 操作的次数是比较少的，我们我们是可以考虑采用空间换时间的方式来加快我们的 get 的操作的。
例如我们可以用一个额外哈希表（例如HashMap）来存放 key-value，这样的话，我们的 get 操作就可以在 O(1) 的时间内寻找到目标节点，并且把 value 返回了。
然而，大家想一下，用了哈希表之后，get 操作真的能够在 O(1) 时间内完成吗？
用了哈希表之后，虽然我们能够在 O(1) 时间内找到目标元素，可以，我们还需要删除该元素，并且把该元素插入到链表头部啊，删除一个元素，我们是需要定位到这个元素的前驱的，然后定位到这个元素的前驱，是需要 O(n) 时间复杂度的。
最后的结果是，用了哈希表时候，最坏时间复杂度还是 O(1)，而空间复杂度也变为了 O(n)。
我们都已经能够在 O(1) 时间复杂度找到要删除的节点了，之所以还得花 O(n) 时间复杂度才能删除，主要是时间是花在了节点前驱的查找上，为了解决这个问题，其实，我们可以把单链表换成双链表，这样的话，我们就可以很好着解决这个问题了，而且，换成双链表之后，你会发现，它要比单链表的操作简单多了。
所以我们最后的方案是：双链表 + 哈希表，采用这两种数据结构的组合，我们的 get 操作就可以在 O(1) 时间复杂度内完成了。由于 put 操作我们要删除的节点一般是尾部节点，所以我们可以用一个变量 tai 时刻记录尾部节点的位置，这样的话，我们的 put 操作也可以在 O(1) 时间内完成了。
具体代码如下：
这里需要提醒的是，对于链表这种数据结构，头结点和尾节点是两个比较特殊的点，如果要删除的节点是头结点或者尾节点，我们一般要先对他们进行处理。
这里放一下单链表版本的吧
如果要时间，强烈建议自己手动实现一波。
校招面试
算法面试
面试现场",
记一次网易笔试：前缀和的应用,"8月3号参加了网易提前批的笔试，笔试时间 120 分钟，然后有 10 道选择题（20分）， 4 道编程题（80分）， 2 道主观题（20分）。可以说你编程题凉了那就基本凉了，其他做的再好也没有。所以时刻保持刷题还是很有必要。
这次网易的笔试题还是挺难，四道题都用到了不同的思想，可能你看了题目，然后看了别人的解析会感觉，咦，挺简单的，但是身处考场可能就完全不一样了，基本每道题给你的时间只有 20 分钟，而且还要我们自己处理输入、输出，由于平时大家刷 Leetcode 的时候都是自己给出个方法就可以了，无需考虑输入、输出，所以有些人对输入输出不是很熟悉，调试花了不少时间，所以我这里建议你一定要把标准输入、输出弄熟悉。
今天我要将的这道题是网易 8 月 3 号研发岗笔试的第一题，这道题涉及到前缀和的应用，所以我想借这道题给大家讲一讲前缀和相关的一些知识，以后大家遇到这道题，就可以快速秒杀了。
下面我描述下这道题，不过我给的描述是简化版的，实际上再做笔试题的时候，每道题的描述都巨长，一般都会根据实际场景来给出问题的，有些人可能阅读了十几分钟，然后不知道自己要干嘛，我这里给出最简化的版本。

有一个班级有 n 个人，给出 n 个元素，第 i 个元素代表 第 i 位同学的考试成绩，接下进行 m 次询问，每次询问给出一个数值 t ，表示第 t 个同学，然后需要我们输出第 t 个同学的成绩超过班级百分之几的人，百分数 p 可以这样算：p = (不超过第 t 个同学分数的人数 ) / n * 100%。输出的时候保留到小数点后 6 位，并且需要四舍五入。
输入描述：第一行输入两个数 n 和 m，两个数以空格隔开，表示 n 个同学和 m 次询问。第二行输入 n 个数值 ni，表示每个同学的分数，第三行输入 m 个数值mi，表示每次询问是询问第几个同学。（注意，这里 2<=n，m<=100000，0<=ni<=150，1<=mi<=n）
输出描述：输出 m 行，每一行输出一个百分数 p，代表超过班级百分之几的人。   
示例1：
输入 ：
3  2
50 60 70
1  2
输出
33.333333%
66.666667%

第一题大致是这样，不过不是和原题完全一样哈，再输入和输出有小许区别，以为你具体的输入输出我忘了。
那么这道题难吗？说实话不难，不过你可以先自己再脑子里想想怎么做比较好，或许在考场上 20 分钟你还真不一定做的出来。
有些人说，这还不简单，每次询问的时候，我都遍历一下所有人的成绩，这样的花时间复杂度是 O(n * m)，显然，如果你这样做，那么是一定通不过的，一定会超时。一般暴力法能够通过 20% ~ 30% 的测试用力，如果一道题 20 分的花，能拿到 4~6 分。如果你实在没思路，那么暴力也是个不错的选择。
1、二分法
这道题我是用二分法做的，就是先对所有人的成绩进行排序，不过排序的时候我们需要开一个新的数组来存储。然后每次查询的时候可以通过二分查找进行匹配，由于用到了排序，需要花 O(nlogn) 的时间，m 次查询花的时间大致为 O(mlogn)。所以平均时间复杂度可以算是 O((m+n)logn)。这个时间复杂度通过所有测试用例，代码如下(没学过java的也能看懂)：
不过这道题更好的做法是采用前缀和来做。题设中每个同学的分数不超过 150，不小于 0，那么我们可以用一个数组 arr，然后让 arr[i] 表示分数不超过 i 的人数。通过这种方式，我们可以把时间复杂度控制再 O(n+m)。直接看代码吧，会更好理解（这里我就不写输入的代码了，用a[]存放成绩，m[]存放m次询问）：
这种方法就叫做前缀和，用这种方法简单了很多。当然前缀和还有其他应用，例如：
如果给你一个数组 arr[]，然后进行 m 次询问，每次询问输入两个数 i，j（i <= j）。要求你输出 arr[i] ~ arr[j] 这个区间的和。这个时候就可以使用前缀和的方式了。

前缀和看起来还是挺简单的，不过再做题中，或许会有意想不到的作用，例如这次的笔试，所以今天给大家讲解一下。

最后我再问你一个和前缀和类似的问题，给你一串长度为n的数列a1,a2,a3......an，要求对a[i]~a[j]进行m次操作：

操作一：将a[L]~a[R]内的元素都加上P

操作二：将a[L]~a[R]内的元素都减去P

最后再给出一个询问求a[i]-a[j]内的元素之和。

这个你会怎么做呢？这个时候就涉及到差分的知识了，关于这个知识的应用，我会在后面的文章讲。大家也可以模仿前缀和的思路，想想这道题怎么做。
校招面试
算法面试
面试现场",
