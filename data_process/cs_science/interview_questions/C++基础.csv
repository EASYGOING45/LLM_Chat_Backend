问题,回答,所属分类
C++ 基础面试题阅读指南（必看）,"大家好，我是帅地。
为了方便大家复习，这些面试题的展示采取了右边面试题目，左边答案的方式，方便大家按需查看。
由于手机端不支持这种展示方式，当然，为了手机方便阅读，下面会贴出所有面试题答案链接，不过大家最好在 PC 电脑端阅读哈，相关面试题还会持续更新，尽量补充完善起来，建议收藏帅地的网站哦。
1. C和C++有什么区别？
1. C和C++有什么区别？
2. a和&a有什么区别？
2. a和&a有什么区别？
3. static关键字有什么作用？
3. static关键字有什么作用？
4. #define和const有什么区别？
4. #define和const有什么区别？
5. 静态链接和动态链接有什么区别？
5. 静态链接和动态链接有什么区别？
6. 变量的声明和定义有什么区别
6. 变量的声明和定义有什么区别
7. 简述#ifdef、#else、#endif和#ifndef的作用
7. 简述#ifdef、#else、#endif和#ifndef的作用
8. 写出int 、bool、 float 、指针变量与 “零值”比较的if 语句
8. 写出int 、bool、 float 、指针变量与 “零值”比较的if 语句
9. 结构体可以直接赋值吗
9. 结构体可以直接赋值吗
10. sizeof 和strlen 的区别
10. sizeof 和strlen 的区别
11. C 语言的关键字 static 和 C++ 的关键字 static 有什么区别
11. C 语言的关键字 static 和 C++ 的关键字 static 有什么区别
12. volatile有什么作用
12. volatile有什么作用
13. 一个参数可以既是const又是volatile吗
13. 一个参数可以既是const又是volatile吗
14. 全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？
14. 全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？
15. 简述strcpy、sprintf 与memcpy 的区别
15. 简述strcpy、sprintf 与memcpy 的区别
16. 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？
16. 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？
17. 什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？
17. 什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？
18. shared_ptr是如何实现的？
18. shared_ptr是如何实现的？
19. 右值引用有什么作用？
19. 右值引用有什么作用？
20. 悬挂指针与野指针有什么区别？
20. 悬挂指针与野指针有什么区别？
21. 动态多态有什么作用？有哪些必要条件？
21. 动态多态有什么作用？有哪些必要条件？
22. 请解析((void ()( ) )0)( )的含义
22. 请解析((void ()( ) )0)( )的含义
23. C语言的指针和引用和c++的有什么区别？
23. C语言的指针和引用和c++的有什么区别？
24. typedef 和define 有什么区别
24. typedef 和define 有什么区别
25. 指针常量与常量指针区别
25. 指针常量与常量指针区别
26. 简述队列和栈的异同
26. 简述队列和栈的异同
27. 设置地址为0x67a9 的整型变量的值为0xaa66
27. 设置地址为0x67a9 的整型变量的值为0xaa66
28. C语言的结构体和C++的有什么区别
28. C语言的结构体和C++的有什么区别
29. 简述指针常量与常量指针的区别
29. 简述指针常量与常量指针的区别
30. 如何避免“野指针”
30. 如何避免“野指针”
31. 句柄和指针的区别和联系是什么？
31. 句柄和指针的区别和联系是什么？
32. 说一说extern“C”
32. 说一说extern“C”
33. 对c++中的smart pointer四个智能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr的理解
33. 对c++中的smart pointer四个智能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr的理解
C++ 面向对象面试题阅读指南（必看）
C++ 面向对象面试题阅读指南（必看）
 C++ STL面试题阅读指南（必看）
 C++ STL面试题阅读指南（必看）
C++ 内存管理面试题阅读指南（必看
C++ 内存管理面试题阅读指南（必看
C++基础",
C和C++有什么区别？,C++基础,
a和&a有什么区别？,"假设数组int a[10]; int (*p)[10] = &a其中：
C++基础",
static关键字有什么作用？,C++基础,
#define和const有什么区别？,C++基础,
静态链接和动态链接有什么区别？,"优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接；
动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；
优点在于多个程序可以共享同一个动态库，节省资源；
缺点在于由于运行时加载，可能影响程序的前期执行性能。
C++基础",
变量的声明和定义有什么区别,"变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。
说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。
C++基础",
简述#ifdef、#else、#endif和#ifndef的作用,"利用#ifdef、#endif将某程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。
在子程序前加上标记，以便于追踪和调试。
应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。
「注意」：虽然不用条件编译命令而直接用if语句也能达到要求，但那样做目标程序长（因为所有语句都编译），运行时间长（因为在程序运行时间对if语句进行测试）。而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。
C++基础",
写出int 、bool、 float 、指针变量与 “零值”比较的if 语句,"首先给个提示：题目中要求的是零值比较，而非与0进行比较，在C++里“零值”的范围可就大了，可以是0， 0.0 ， FALSE或者“空指针”。
下面是答案。
详细解释
int：int 是整型，可以直接和 0 比较。
bool：根据布尔类型的语义，零值为假（记为FALSE），任何非零值都是真（记为TRUE）。TRUE 的值究竟是什么并没有统一的标准。
例如Visual C++ 将TRUE 定义为1，而Visual Basic 则将TRUE 定义为 -1。所以我们不可以将布尔变量直接与TRUE、FALSE 或者1、0 进行比较
float：千万要留意，无论是float 还是double 类型的变量，都有精度限制，都不可以用==”或!=与任何数字比较，应该设法转化成>=或<=`形式。
其中EPSINON 是允许的误差（即精度）
指针：指针变量的零值就是NULL
C++基础",
结构体可以直接赋值吗,"声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。
「注意」：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间。
C++基础",
sizeof 和strlen 的区别,C++基础,
C 语言的关键字 static 和 C++ 的关键字 static 有什么区别,"在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。
「注意」：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。
C++基础",
volatile有什么作用,"「注意」：虽然volatile在嵌入式方面应用比较多，但是在PC软件的多线程中，volatile修饰的临界变量也是非常实用的。
C++基础",
一个参数可以既是const又是volatile吗,"可以，用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。
注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。
C++基础",
全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？,C++基础,
简述strcpy、sprintf 与memcpy 的区别,"「注意」：strcpy、sprintf 与memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来 选择合适的函数实现拷贝功能。
C++基础",
对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？,"应该使用inline内联函数，即编译器将inline内联函数内的代码替换到函数被调用的地方。
优点：
缺点：
C++基础",
什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？,"智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间。
智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。
分为auto_ptr、unique_ptr、shared_ptr和weak_ptr四种，各自的特点：
在C++11中被摒弃，其主要问题在于：
对于unique_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值；
对于shared_ptr，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源；
对于weak_ptr，解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数。
C++基础",
shared_ptr是如何实现的？,C++基础,
右值引用有什么作用？,"右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数
C++基础",
悬挂指针与野指针有什么区别？,C++基础,
请解析((void ()( ) )0)( )的含义,C++基础,
指针和引用的区别,C++基础,
typedef 和define 有什么区别,"「注意」：typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。
C++基础",
简述队列和栈的异同,"队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是 “后进先出”。
「注意」：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分 配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员 分配释放， 若程序员不释放，程序结束时可能由OS 回收。分配方式类似于链表。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。
C++基础",
设置地址为0x67a9 的整型变量的值为0xaa66,"「注意」：这道题就是强制类型转换的典型例子，绝大部份情况下，地址长度和整型数据的长度是一样的(此时的整型指的是 long)， 即一个整型数据可以强制转换成地址指针类型，只要有意义即可。
C++基础",
结构体和类的区别,"「注意」：虽然C的结构体和C++的类有很大的相似度，但是类是实现面向对象的基础。而结构体只可以简单地理解为类的前身。
C++基础",
简述指针常量与常量指针的区别,"「注意」：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。
C++基础",
如何避免“野指针”,C++基础,
句柄和指针的区别和联系是什么？,"句柄和指针其实是两个截然不同的概念。Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32bit的uint。指针则标记某个物理内存地址，两者是不同的概念。
C++基础",
说一说extern“C”,"extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。
这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern “C”就是其中的一个策略。
C++基础",
"对c++中的smart pointer四个智能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr的理解","C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。
智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。
采用所有权模式。
此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！
unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。
采用所有权模式。
编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。
另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：
其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。
「注意」：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：
shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。
shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
成员函数：
use_count 返回引用计数的个数
unique 返回是否是独占所有权( use_count 为 1)
swap 交换两个 shared_ptr 对象(即交换所拥有的对象)
reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptrsp(new int(1)); sp 与 sp.get()是等价的
weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。
可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。
「注意」：不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();
C++基础",
C++的顶层const和底层const ？,C++基础,
